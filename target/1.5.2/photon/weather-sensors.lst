
/Users/scottperkins/Documents/weather-station/weather-sensors/target/1.5.2/photon/weather-sensors.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000037a0  080a0020  080a0020  00010020  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .backup       00000004  40024000  080a37c0  00014000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000070  20000000  080a37c4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000005b8  20000070  20000070  00030070  2**2
                  ALLOC
  6 .module_info_suffix 00000028  080a3834  080a3834  00023834  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .module_info_crc 00000004  080a385c  080a385c  0002385c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_info   000ab7d4  00000000  00000000  00023860  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000f1ab  00000000  00000000  000cf034  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000155fe  00000000  00000000  000de1df  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00002100  00000000  00000000  000f37dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000036b0  00000000  00000000  000f58dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00023c76  00000000  00000000  000f8f8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000222bc  00000000  00000000  0011cc03  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000ae3c2  00000000  00000000  0013eebf  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000bd28  00000000  00000000  001ed284  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0020 <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0020:	4809      	ldr	r0, [pc, #36]	; (80a0048 <module_user_pre_init+0x28>)
 80a0022:	490a      	ldr	r1, [pc, #40]	; (80a004c <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0024:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0026:	4288      	cmp	r0, r1
 80a0028:	d005      	beq.n	80a0036 <module_user_pre_init+0x16>
 80a002a:	4a09      	ldr	r2, [pc, #36]	; (80a0050 <module_user_pre_init+0x30>)
 80a002c:	4282      	cmp	r2, r0
 80a002e:	d002      	beq.n	80a0036 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a0030:	1a12      	subs	r2, r2, r0
 80a0032:	f003 f90b 	bl	80a324c <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0036:	4807      	ldr	r0, [pc, #28]	; (80a0054 <module_user_pre_init+0x34>)
 80a0038:	4a07      	ldr	r2, [pc, #28]	; (80a0058 <module_user_pre_init+0x38>)
 80a003a:	2100      	movs	r1, #0
 80a003c:	1a12      	subs	r2, r2, r0
 80a003e:	f003 f910 	bl	80a3262 <memset>
    return &link_heap_start;
}
 80a0042:	4806      	ldr	r0, [pc, #24]	; (80a005c <module_user_pre_init+0x3c>)
 80a0044:	bd08      	pop	{r3, pc}
 80a0046:	bf00      	nop
 80a0048:	20000000 	.word	0x20000000
 80a004c:	080a37c4 	.word	0x080a37c4
 80a0050:	20000070 	.word	0x20000070
 80a0054:	20000070 	.word	0x20000070
 80a0058:	20000628 	.word	0x20000628
 80a005c:	20000628 	.word	0x20000628

080a0060 <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a0060:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a0062:	f001 ff99 	bl	80a1f98 <module_user_init_hook>
 80a0066:	4b07      	ldr	r3, [pc, #28]	; (80a0084 <module_user_init+0x24>)
 80a0068:	4c07      	ldr	r4, [pc, #28]	; (80a0088 <module_user_init+0x28>)
 80a006a:	461e      	mov	r6, r3
 80a006c:	1ae4      	subs	r4, r4, r3
 80a006e:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0070:	2500      	movs	r5, #0
 80a0072:	42a5      	cmp	r5, r4
 80a0074:	d004      	beq.n	80a0080 <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0076:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a007a:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a007c:	3501      	adds	r5, #1
 80a007e:	e7f8      	b.n	80a0072 <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a0080:	bd70      	pop	{r4, r5, r6, pc}
 80a0082:	bf00      	nop
 80a0084:	080a3788 	.word	0x080a3788
 80a0088:	080a37bc 	.word	0x080a37bc

080a008c <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a008c:	f000 baa0 	b.w	80a05d0 <setup>

080a0090 <module_user_loop>:
}

void module_user_loop() {
 80a0090:	b508      	push	{r3, lr}
    loop();
 80a0092:	f000 fc65 	bl	80a0960 <loop>
    _post_loop();
}
 80a0096:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a009a:	f001 bf3f 	b.w	80a1f1c <_post_loop>

080a009e <_Znwj>:
 80a009e:	f000 be57 	b.w	80a0d50 <malloc>

080a00a2 <_ZdlPv>:
 80a00a2:	f000 be5d 	b.w	80a0d60 <free>

080a00a6 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00a6:	7800      	ldrb	r0, [r0, #0]
 80a00a8:	fab0 f080 	clz	r0, r0
 80a00ac:	0940      	lsrs	r0, r0, #5
 80a00ae:	4770      	bx	lr

080a00b0 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00b0:	2301      	movs	r3, #1
 80a00b2:	7003      	strb	r3, [r0, #0]
 80a00b4:	4770      	bx	lr

080a00b6 <_ZN7TwoWire5writeEi>:
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
 80a00b6:	6803      	ldr	r3, [r0, #0]
 80a00b8:	b2c9      	uxtb	r1, r1
 80a00ba:	689b      	ldr	r3, [r3, #8]
 80a00bc:	4718      	bx	r3

080a00be <_ZN7WeatherC1Ev>:
 */

 #include "SparkFun_Photon_Weather_Shield_Library.h"

 //Initialize
 Weather::Weather(){}
 80a00be:	4770      	bx	lr

080a00c0 <_ZN7Weather7checkIDEv>:
	//Reset user resister
	writeReg(SOFT_RESET);
}

uint8_t Weather::checkID()
{
 80a00c0:	b508      	push	{r3, lr}
	uint8_t ID_1;

 	// Check device ID
	Wire.beginTransmission(ADDRESS);
 80a00c2:	f001 ffaf 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a00c6:	2140      	movs	r1, #64	; 0x40
 80a00c8:	f000 feef 	bl	80a0eaa <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(0xFC);
 80a00cc:	f001 ffaa 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a00d0:	21fc      	movs	r1, #252	; 0xfc
 80a00d2:	f7ff fff0 	bl	80a00b6 <_ZN7TwoWire5writeEi>
	Wire.write(0xC9);
 80a00d6:	f001 ffa5 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a00da:	21c9      	movs	r1, #201	; 0xc9
 80a00dc:	f7ff ffeb 	bl	80a00b6 <_ZN7TwoWire5writeEi>
	Wire.endTransmission();
 80a00e0:	f001 ffa0 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a00e4:	f000 fee8 	bl	80a0eb8 <_ZN7TwoWire15endTransmissionEv>

    Wire.requestFrom(ADDRESS,1);
 80a00e8:	f001 ff9c 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a00ec:	2201      	movs	r2, #1
 80a00ee:	2140      	movs	r1, #64	; 0x40
 80a00f0:	f000 fed4 	bl	80a0e9c <_ZN7TwoWire11requestFromEhj>

    ID_1 = Wire.read();
 80a00f4:	f001 ff96 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a00f8:	6803      	ldr	r3, [r0, #0]
 80a00fa:	695b      	ldr	r3, [r3, #20]
 80a00fc:	4798      	blx	r3

    return(ID_1);
}
 80a00fe:	b2c0      	uxtb	r0, r0
 80a0100:	bd08      	pop	{r3, pc}

080a0102 <_ZN7Weather14makeMeasurmentEh>:

uint16_t Weather::makeMeasurment(uint8_t command)
{
 80a0102:	b538      	push	{r3, r4, r5, lr}
	// It can be either temperature or relative humidity
	// TODO: implement checksum checking

	uint16_t nBytes = 3;
	// if we are only reading old temperature, read olny msb and lsb
	if (command == 0xE0) nBytes = 2;
 80a0104:	29e0      	cmp	r1, #224	; 0xe0
 80a0106:	bf14      	ite	ne
 80a0108:	2503      	movne	r5, #3
 80a010a:	2502      	moveq	r5, #2

    return(ID_1);
}

uint16_t Weather::makeMeasurment(uint8_t command)
{
 80a010c:	460c      	mov	r4, r1

	uint16_t nBytes = 3;
	// if we are only reading old temperature, read olny msb and lsb
	if (command == 0xE0) nBytes = 2;

	Wire.beginTransmission(ADDRESS);
 80a010e:	f001 ff89 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0112:	2140      	movs	r1, #64	; 0x40
 80a0114:	f000 fec9 	bl	80a0eaa <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(command);
 80a0118:	f001 ff84 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a011c:	6803      	ldr	r3, [r0, #0]
 80a011e:	4621      	mov	r1, r4
 80a0120:	689b      	ldr	r3, [r3, #8]
 80a0122:	4798      	blx	r3
	Wire.endTransmission();
 80a0124:	f001 ff7e 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0128:	f000 fec6 	bl	80a0eb8 <_ZN7TwoWire15endTransmissionEv>
	// When not using clock stretching (*_NOHOLD commands) delay here
	// is needed to wait for the measurement.
	// According to datasheet the max. conversion time is ~22ms
	 delay(100);
 80a012c:	2064      	movs	r0, #100	; 0x64
 80a012e:	f000 fe37 	bl	80a0da0 <delay>

	Wire.requestFrom(ADDRESS,nBytes);
 80a0132:	f001 ff77 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0136:	462a      	mov	r2, r5
 80a0138:	2140      	movs	r1, #64	; 0x40
 80a013a:	f000 feaf 	bl	80a0e9c <_ZN7TwoWire11requestFromEhj>
 80a013e:	2465      	movs	r4, #101	; 0x65
	//Wait for data
	int counter = 0;
	while (Wire.available() < nBytes){
 80a0140:	f001 ff70 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0144:	6803      	ldr	r3, [r0, #0]
 80a0146:	691b      	ldr	r3, [r3, #16]
 80a0148:	4798      	blx	r3
 80a014a:	42a8      	cmp	r0, r5
 80a014c:	da06      	bge.n	80a015c <_ZN7Weather14makeMeasurmentEh+0x5a>
	  delay(1);
 80a014e:	2001      	movs	r0, #1
 80a0150:	f000 fe26 	bl	80a0da0 <delay>
	  counter ++;
	  if (counter >100){
 80a0154:	3c01      	subs	r4, #1
 80a0156:	d1f3      	bne.n	80a0140 <_ZN7Weather14makeMeasurmentEh+0x3e>
	    // Timeout: Sensor did not return any data
	    return 100;
 80a0158:	2064      	movs	r0, #100	; 0x64
	// According to datasheet LSB of RH is always xxxxxx10
	lsb &= 0xFC;
	unsigned int mesurment = msb << 8 | lsb;

	return mesurment;
}
 80a015a:	bd38      	pop	{r3, r4, r5, pc}
	    // Timeout: Sensor did not return any data
	    return 100;
	  }
	}

	unsigned int msb = Wire.read();
 80a015c:	f001 ff62 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0160:	6803      	ldr	r3, [r0, #0]
 80a0162:	695b      	ldr	r3, [r3, #20]
 80a0164:	4798      	blx	r3
 80a0166:	4604      	mov	r4, r0
	unsigned int lsb = Wire.read();
 80a0168:	f001 ff5c 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a016c:	6803      	ldr	r3, [r0, #0]
 80a016e:	695b      	ldr	r3, [r3, #20]
 80a0170:	4798      	blx	r3
	// Clear the last to bits of LSB to 00.
	// According to datasheet LSB of RH is always xxxxxx10
	lsb &= 0xFC;
	unsigned int mesurment = msb << 8 | lsb;

	return mesurment;
 80a0172:	f000 00fc 	and.w	r0, r0, #252	; 0xfc
 80a0176:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
 80a017a:	b280      	uxth	r0, r0
 80a017c:	bd38      	pop	{r3, r4, r5, pc}
	...

080a0180 <_ZN7Weather5getRHEv>:

/****************Si7021 & HTU21D Functions**************************************/


float Weather::getRH()
{
 80a0180:	b508      	push	{r3, lr}
	// Measure the relative humidity
	uint16_t RH_Code = makeMeasurment(HUMD_MEASURE_NOHOLD);
 80a0182:	21f5      	movs	r1, #245	; 0xf5
 80a0184:	f7ff ffbd 	bl	80a0102 <_ZN7Weather14makeMeasurmentEh>
	float result = (125.0*RH_Code/65536)-6;
	return result;
 80a0188:	f002 fa46 	bl	80a2618 <__aeabi_i2d>
 80a018c:	2200      	movs	r2, #0
 80a018e:	4b07      	ldr	r3, [pc, #28]	; (80a01ac <_ZN7Weather5getRHEv+0x2c>)
 80a0190:	f002 faa8 	bl	80a26e4 <__aeabi_dmul>
 80a0194:	2200      	movs	r2, #0
 80a0196:	4b06      	ldr	r3, [pc, #24]	; (80a01b0 <_ZN7Weather5getRHEv+0x30>)
 80a0198:	f002 faa4 	bl	80a26e4 <__aeabi_dmul>
 80a019c:	2200      	movs	r2, #0
 80a019e:	4b05      	ldr	r3, [pc, #20]	; (80a01b4 <_ZN7Weather5getRHEv+0x34>)
 80a01a0:	f002 f8ec 	bl	80a237c <__aeabi_dsub>
 80a01a4:	f002 fd96 	bl	80a2cd4 <__aeabi_d2f>
}
 80a01a8:	bd08      	pop	{r3, pc}
 80a01aa:	bf00      	nop
 80a01ac:	405f4000 	.word	0x405f4000
 80a01b0:	3ef00000 	.word	0x3ef00000
 80a01b4:	40180000 	.word	0x40180000

080a01b8 <_ZN7Weather7getTempEv>:
	float result = (175.72*temp_Code/65536)-46.85;
	return result;
}

float Weather::getTemp()
{
 80a01b8:	b508      	push	{r3, lr}
	// Measure temperature
	uint16_t temp_Code = makeMeasurment(TEMP_MEASURE_NOHOLD);
 80a01ba:	21f3      	movs	r1, #243	; 0xf3
 80a01bc:	f7ff ffa1 	bl	80a0102 <_ZN7Weather14makeMeasurmentEh>
	float result = (175.72*temp_Code/65536)-46.85;
	return result;
 80a01c0:	f002 fa2a 	bl	80a2618 <__aeabi_i2d>
 80a01c4:	a308      	add	r3, pc, #32	; (adr r3, 80a01e8 <_ZN7Weather7getTempEv+0x30>)
 80a01c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a01ca:	f002 fa8b 	bl	80a26e4 <__aeabi_dmul>
 80a01ce:	2200      	movs	r2, #0
 80a01d0:	4b09      	ldr	r3, [pc, #36]	; (80a01f8 <_ZN7Weather7getTempEv+0x40>)
 80a01d2:	f002 fa87 	bl	80a26e4 <__aeabi_dmul>
 80a01d6:	a306      	add	r3, pc, #24	; (adr r3, 80a01f0 <_ZN7Weather7getTempEv+0x38>)
 80a01d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a01dc:	f002 f8ce 	bl	80a237c <__aeabi_dsub>
 80a01e0:	f002 fd78 	bl	80a2cd4 <__aeabi_d2f>
}
 80a01e4:	bd08      	pop	{r3, pc}
 80a01e6:	bf00      	nop
 80a01e8:	3d70a3d7 	.word	0x3d70a3d7
 80a01ec:	4065f70a 	.word	0x4065f70a
 80a01f0:	cccccccd 	.word	0xcccccccd
 80a01f4:	40476ccc 	.word	0x40476ccc
 80a01f8:	3ef00000 	.word	0x3ef00000
 80a01fc:	00000000 	.word	0x00000000

080a0200 <_ZN7Weather8getTempFEv>:
{
  return((readTemp() * 1.8) + 32.0); // Convert celsius to fahrenheit
}

float Weather::getTempF()
{
 80a0200:	b508      	push	{r3, lr}
  return((getTemp() * 1.8) + 32.0); // Convert celsius to fahrenheit
 80a0202:	f7ff ffd9 	bl	80a01b8 <_ZN7Weather7getTempEv>
 80a0206:	f002 fa19 	bl	80a263c <__aeabi_f2d>
 80a020a:	a307      	add	r3, pc, #28	; (adr r3, 80a0228 <_ZN7Weather8getTempFEv+0x28>)
 80a020c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0210:	f002 fa68 	bl	80a26e4 <__aeabi_dmul>
 80a0214:	2200      	movs	r2, #0
 80a0216:	4b06      	ldr	r3, [pc, #24]	; (80a0230 <_ZN7Weather8getTempFEv+0x30>)
 80a0218:	f002 f8b2 	bl	80a2380 <__adddf3>
 80a021c:	f002 fd5a 	bl	80a2cd4 <__aeabi_d2f>
}
 80a0220:	bd08      	pop	{r3, pc}
 80a0222:	bf00      	nop
 80a0224:	f3af 8000 	nop.w
 80a0228:	cccccccd 	.word	0xcccccccd
 80a022c:	3ffccccc 	.word	0x3ffccccc
 80a0230:	40400000 	.word	0x40400000

080a0234 <_ZN7Weather8IIC_ReadEh>:
}


// These are the two I2C functions in this sketch.
byte Weather::IIC_Read(byte regAddr)
{
 80a0234:	b510      	push	{r4, lr}
 80a0236:	460c      	mov	r4, r1
  // This function reads one byte over IIC
  Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a0238:	f001 fef4 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a023c:	2160      	movs	r1, #96	; 0x60
 80a023e:	f000 fe34 	bl	80a0eaa <_ZN7TwoWire17beginTransmissionEi>
  Wire.write(regAddr);  // Address of CTRL_REG1
 80a0242:	f001 feef 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0246:	6803      	ldr	r3, [r0, #0]
 80a0248:	4621      	mov	r1, r4
 80a024a:	689b      	ldr	r3, [r3, #8]
 80a024c:	4798      	blx	r3
  Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
 80a024e:	f001 fee9 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0252:	2100      	movs	r1, #0
 80a0254:	f000 fe2c 	bl	80a0eb0 <_ZN7TwoWire15endTransmissionEh>
  Wire.requestFrom(MPL3115A2_ADDRESS, 1); // Request the data...
 80a0258:	f001 fee4 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a025c:	2201      	movs	r2, #1
 80a025e:	2160      	movs	r1, #96	; 0x60
 80a0260:	f000 fe1c 	bl	80a0e9c <_ZN7TwoWire11requestFromEhj>
  return Wire.read();
 80a0264:	f001 fede 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0268:	6803      	ldr	r3, [r0, #0]
 80a026a:	695b      	ldr	r3, [r3, #20]
 80a026c:	4798      	blx	r3
}
 80a026e:	b2c0      	uxtb	r0, r0
 80a0270:	bd10      	pop	{r4, pc}
	...

080a0274 <_ZN7Weather5beginEv>:

 //Initialize
 Weather::Weather(){}

 void Weather::begin(void)
{
 80a0274:	b538      	push	{r3, r4, r5, lr}
 80a0276:	4605      	mov	r5, r0
  Wire.begin();
 80a0278:	f001 fed4 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a027c:	f000 fdda 	bl	80a0e34 <_ZN7TwoWire5beginEv>

  uint8_t ID_Barro = IIC_Read(WHO_AM_I );
 80a0280:	210c      	movs	r1, #12
 80a0282:	4628      	mov	r0, r5
 80a0284:	f7ff ffd6 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
 80a0288:	4604      	mov	r4, r0
  uint8_t ID_Temp_Hum = checkID();
 80a028a:	4628      	mov	r0, r5
 80a028c:	f7ff ff18 	bl	80a00c0 <_ZN7Weather7checkIDEv>
  if (ID_Barro == 0xC4)//Ping WhoAmI register
    x = 1;
  else
  	x = 0;

  if(ID_Temp_Hum == 0x15)//Ping CheckID register
 80a0290:	2815      	cmp	r0, #21
 80a0292:	d002      	beq.n	80a029a <_ZN7Weather5beginEv+0x26>
    y = 1;
  else if(ID_Temp_Hum == 0x32)
 80a0294:	2832      	cmp	r0, #50	; 0x32
 80a0296:	d115      	bne.n	80a02c4 <_ZN7Weather5beginEv+0x50>
 80a0298:	e00e      	b.n	80a02b8 <_ZN7Weather5beginEv+0x44>
    y = 2;
  else
    y = 0;

  if(x == 1 && y == 1)
 80a029a:	2cc4      	cmp	r4, #196	; 0xc4
 80a029c:	d103      	bne.n	80a02a6 <_ZN7Weather5beginEv+0x32>
  {
    Serial.println("MPL3115A2 Found");
 80a029e:	f001 fd49 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02a2:	4916      	ldr	r1, [pc, #88]	; (80a02fc <_ZN7Weather5beginEv+0x88>)
 80a02a4:	e002      	b.n	80a02ac <_ZN7Weather5beginEv+0x38>
    Serial.println("MPL3115A2 Found");
    Serial.println("HTU21D Found");
  }
  else if(x == 0 && y == 1)
  {
    Serial.println("MPL3115A2 NOT Found");
 80a02a6:	f001 fd45 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02aa:	4915      	ldr	r1, [pc, #84]	; (80a0300 <_ZN7Weather5beginEv+0x8c>)
 80a02ac:	f001 f80d 	bl	80a12ca <_ZN5Print7printlnEPKc>
    Serial.println("Si7021 Found");
 80a02b0:	f001 fd40 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02b4:	4913      	ldr	r1, [pc, #76]	; (80a0304 <_ZN7Weather5beginEv+0x90>)
 80a02b6:	e01c      	b.n	80a02f2 <_ZN7Weather5beginEv+0x7e>
  else if(ID_Temp_Hum == 0x32)
    y = 2;
  else
    y = 0;

  if(x == 1 && y == 1)
 80a02b8:	2cc4      	cmp	r4, #196	; 0xc4
 80a02ba:	d10e      	bne.n	80a02da <_ZN7Weather5beginEv+0x66>
    Serial.println("MPL3115A2 Found");
    Serial.println("Si7021 Found");
  }
  else if(x == 1 && y == 2)
  {
    Serial.println("MPL3115A2 Found");
 80a02bc:	f001 fd3a 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02c0:	490e      	ldr	r1, [pc, #56]	; (80a02fc <_ZN7Weather5beginEv+0x88>)
 80a02c2:	e00d      	b.n	80a02e0 <_ZN7Weather5beginEv+0x6c>
  else if(ID_Temp_Hum == 0x32)
    y = 2;
  else
    y = 0;

  if(x == 1 && y == 1)
 80a02c4:	2cc4      	cmp	r4, #196	; 0xc4
 80a02c6:	d111      	bne.n	80a02ec <_ZN7Weather5beginEv+0x78>
    Serial.println("MPL3115A2 NOT Found");
    Serial.println("HTU21D Found");
  }
  else if(x == 1 && y == 0)
  {
    Serial.println("MPL3115A2 Found");
 80a02c8:	f001 fd34 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02cc:	490b      	ldr	r1, [pc, #44]	; (80a02fc <_ZN7Weather5beginEv+0x88>)
 80a02ce:	f000 fffc 	bl	80a12ca <_ZN5Print7printlnEPKc>
    Serial.println("No Temp/Humidity Device Detected");
 80a02d2:	f001 fd2f 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02d6:	490c      	ldr	r1, [pc, #48]	; (80a0308 <_ZN7Weather5beginEv+0x94>)
 80a02d8:	e00b      	b.n	80a02f2 <_ZN7Weather5beginEv+0x7e>
    Serial.println("MPL3115A2 NOT Found");
    Serial.println("Si7021 Found");
  }
  else if(x == 0 && y == 2)
  {
    Serial.println("MPL3115A2 NOT Found");
 80a02da:	f001 fd2b 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02de:	4908      	ldr	r1, [pc, #32]	; (80a0300 <_ZN7Weather5beginEv+0x8c>)
 80a02e0:	f000 fff3 	bl	80a12ca <_ZN5Print7printlnEPKc>
    Serial.println("HTU21D Found");
 80a02e4:	f001 fd26 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02e8:	4908      	ldr	r1, [pc, #32]	; (80a030c <_ZN7Weather5beginEv+0x98>)
 80a02ea:	e002      	b.n	80a02f2 <_ZN7Weather5beginEv+0x7e>
  {
    Serial.println("MPL3115A2 Found");
    Serial.println("No Temp/Humidity Device Detected");
  }
  else
  	Serial.println("No Devices Detected");
 80a02ec:	f001 fd22 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a02f0:	4907      	ldr	r1, [pc, #28]	; (80a0310 <_ZN7Weather5beginEv+0x9c>)
}
 80a02f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    Serial.println("MPL3115A2 Found");
    Serial.println("No Temp/Humidity Device Detected");
  }
  else
  	Serial.println("No Devices Detected");
 80a02f6:	f000 bfe8 	b.w	80a12ca <_ZN5Print7printlnEPKc>
 80a02fa:	bf00      	nop
 80a02fc:	080a32e8 	.word	0x080a32e8
 80a0300:	080a3312 	.word	0x080a3312
 80a0304:	080a32f8 	.word	0x080a32f8
 80a0308:	080a3326 	.word	0x080a3326
 80a030c:	080a3305 	.word	0x080a3305
 80a0310:	080a3347 	.word	0x080a3347

080a0314 <_ZN7Weather9IIC_WriteEhh>:
  Wire.requestFrom(MPL3115A2_ADDRESS, 1); // Request the data...
  return Wire.read();
}

void Weather::IIC_Write(byte regAddr, byte value)
{
 80a0314:	b538      	push	{r3, r4, r5, lr}
 80a0316:	4614      	mov	r4, r2
 80a0318:	460d      	mov	r5, r1
  // This function writes one byte over IIC
  Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a031a:	f001 fe83 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a031e:	2160      	movs	r1, #96	; 0x60
 80a0320:	f000 fdc3 	bl	80a0eaa <_ZN7TwoWire17beginTransmissionEi>
  Wire.write(regAddr);
 80a0324:	f001 fe7e 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0328:	6803      	ldr	r3, [r0, #0]
 80a032a:	4629      	mov	r1, r5
 80a032c:	689b      	ldr	r3, [r3, #8]
 80a032e:	4798      	blx	r3
  Wire.write(value);
 80a0330:	f001 fe78 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0334:	6803      	ldr	r3, [r0, #0]
 80a0336:	4621      	mov	r1, r4
 80a0338:	689b      	ldr	r3, [r3, #8]
 80a033a:	4798      	blx	r3
  Wire.endTransmission(true);
 80a033c:	f001 fe72 	bl	80a2024 <_Z19__fetch_global_Wirev>
}
 80a0340:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
{
  // This function writes one byte over IIC
  Wire.beginTransmission(MPL3115A2_ADDRESS);
  Wire.write(regAddr);
  Wire.write(value);
  Wire.endTransmission(true);
 80a0344:	2101      	movs	r1, #1
 80a0346:	f000 bdb3 	b.w	80a0eb0 <_ZN7TwoWire15endTransmissionEh>

080a034a <_ZN7Weather16setModeBarometerEv>:
}

//Sets the mode to Barometer
//CTRL_REG1, ALT bit
void Weather::setModeBarometer()
{
 80a034a:	b510      	push	{r4, lr}
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a034c:	2126      	movs	r1, #38	; 0x26
}

//Sets the mode to Barometer
//CTRL_REG1, ALT bit
void Weather::setModeBarometer()
{
 80a034e:	4604      	mov	r4, r0
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a0350:	f7ff ff70 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
  tempSetting &= ~(1<<7); //Clear ALT bit
  IIC_Write(CTRL_REG1, tempSetting);
 80a0354:	2126      	movs	r1, #38	; 0x26
 80a0356:	f000 027f 	and.w	r2, r0, #127	; 0x7f
 80a035a:	4620      	mov	r0, r4
}
 80a035c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
//CTRL_REG1, ALT bit
void Weather::setModeBarometer()
{
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
  tempSetting &= ~(1<<7); //Clear ALT bit
  IIC_Write(CTRL_REG1, tempSetting);
 80a0360:	f7ff bfd8 	b.w	80a0314 <_ZN7Weather9IIC_WriteEhh>

080a0364 <_ZN7Weather17setOversampleRateEh>:
//Call with a rate from 0 to 7. See page 33 for table of ratios.
//Sets the over sample rate. Datasheet calls for 128 but you can set it
//from 1 to 128 samples. The higher the oversample rate the greater
//the time between data samples.
void Weather::setOversampleRate(byte sampleRate)
{
 80a0364:	2907      	cmp	r1, #7
 80a0366:	bf28      	it	cs
 80a0368:	2107      	movcs	r1, #7
 80a036a:	b538      	push	{r3, r4, r5, lr}
 80a036c:	460d      	mov	r5, r1
  if(sampleRate > 7) sampleRate = 7; //OS cannot be larger than 0b.0111
  sampleRate <<= 3; //Align it for the CTRL_REG1 register

  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a036e:	2126      	movs	r1, #38	; 0x26
//Call with a rate from 0 to 7. See page 33 for table of ratios.
//Sets the over sample rate. Datasheet calls for 128 but you can set it
//from 1 to 128 samples. The higher the oversample rate the greater
//the time between data samples.
void Weather::setOversampleRate(byte sampleRate)
{
 80a0370:	4604      	mov	r4, r0
  if(sampleRate > 7) sampleRate = 7; //OS cannot be larger than 0b.0111
  sampleRate <<= 3; //Align it for the CTRL_REG1 register

  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a0372:	f7ff ff5f 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
  tempSetting &= 0b11000111; //Clear out old OS bits
 80a0376:	f000 00c7 	and.w	r0, r0, #199	; 0xc7
  tempSetting |= sampleRate; //Mask in new OS bits
  IIC_Write(CTRL_REG1, tempSetting);
 80a037a:	ea40 02c5 	orr.w	r2, r0, r5, lsl #3
 80a037e:	b2d2      	uxtb	r2, r2
 80a0380:	4620      	mov	r0, r4
}
 80a0382:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  sampleRate <<= 3; //Align it for the CTRL_REG1 register

  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
  tempSetting &= 0b11000111; //Clear out old OS bits
  tempSetting |= sampleRate; //Mask in new OS bits
  IIC_Write(CTRL_REG1, tempSetting);
 80a0386:	2126      	movs	r1, #38	; 0x26
 80a0388:	f7ff bfc4 	b.w	80a0314 <_ZN7Weather9IIC_WriteEhh>

080a038c <_ZN7Weather16enableEventFlagsEv>:

//Enables the pressure and temp measurement event flags so that we can
//test against them. This is recommended in datasheet during setup.
void Weather::enableEventFlags()
{
  IIC_Write(PT_DATA_CFG, 0x07); // Enable all three pressure and temp event flags
 80a038c:	2207      	movs	r2, #7
 80a038e:	2113      	movs	r1, #19
 80a0390:	f7ff bfc0 	b.w	80a0314 <_ZN7Weather9IIC_WriteEhh>

080a0394 <_ZN7Weather13toggleOneShotEv>:
}

//Clears then sets the OST bit which causes the sensor to immediately take another reading
//Needed to sample faster than 1Hz
void Weather::toggleOneShot(void)
{
 80a0394:	b510      	push	{r4, lr}
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a0396:	2126      	movs	r1, #38	; 0x26
}

//Clears then sets the OST bit which causes the sensor to immediately take another reading
//Needed to sample faster than 1Hz
void Weather::toggleOneShot(void)
{
 80a0398:	4604      	mov	r4, r0
  byte tempSetting = IIC_Read(CTRL_REG1); //Read current settings
 80a039a:	f7ff ff4b 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
  tempSetting &= ~(1<<1); //Clear OST bit
  IIC_Write(CTRL_REG1, tempSetting);
 80a039e:	2126      	movs	r1, #38	; 0x26
 80a03a0:	f000 02fd 	and.w	r2, r0, #253	; 0xfd
 80a03a4:	4620      	mov	r0, r4
 80a03a6:	f7ff ffb5 	bl	80a0314 <_ZN7Weather9IIC_WriteEhh>

  tempSetting = IIC_Read(CTRL_REG1); //Read current settings to be safe
 80a03aa:	2126      	movs	r1, #38	; 0x26
 80a03ac:	4620      	mov	r0, r4
 80a03ae:	f7ff ff41 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
  tempSetting |= (1<<1); //Set OST bit
  IIC_Write(CTRL_REG1, tempSetting);
 80a03b2:	f040 0202 	orr.w	r2, r0, #2
 80a03b6:	b2d2      	uxtb	r2, r2
 80a03b8:	4620      	mov	r0, r4
}
 80a03ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  tempSetting &= ~(1<<1); //Clear OST bit
  IIC_Write(CTRL_REG1, tempSetting);

  tempSetting = IIC_Read(CTRL_REG1); //Read current settings to be safe
  tempSetting |= (1<<1); //Set OST bit
  IIC_Write(CTRL_REG1, tempSetting);
 80a03be:	2126      	movs	r1, #38	; 0x26
 80a03c0:	f7ff bfa8 	b.w	80a0314 <_ZN7Weather9IIC_WriteEhh>

080a03c4 <_ZN7Weather12readPressureEv>:

//Reads the current pressure in Pa
//Unit must be set in barometric pressure mode
//Returns -1 if no new data is available
float Weather::readPressure()
{
 80a03c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a03c6:	4607      	mov	r7, r0
	//Check PDR bit, if it's not set then toggle OST
	if(IIC_Read(STATUS) & (1<<2) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a03c8:	2100      	movs	r1, #0
 80a03ca:	f7ff ff33 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>

	//Wait for PDR bit, indicates we have new pressure data
	int counter = 0;
	while(IIC_Read(STATUS) & (1<<2) == 0)
 80a03ce:	2100      	movs	r1, #0
 80a03d0:	4638      	mov	r0, r7
 80a03d2:	f7ff ff2f 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
		if(++counter > 600) return(-999); //Error out after max of 512ms for a read
		delay(1);
	}

	// Read pressure registers
	Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a03d6:	f001 fe25 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a03da:	2160      	movs	r1, #96	; 0x60
 80a03dc:	f000 fd65 	bl	80a0eaa <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(OUT_P_MSB);  // Address of data to get
 80a03e0:	f001 fe20 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a03e4:	2101      	movs	r1, #1
 80a03e6:	f7ff fe66 	bl	80a00b6 <_ZN7TwoWire5writeEi>
	Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
 80a03ea:	f001 fe1b 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a03ee:	2100      	movs	r1, #0
 80a03f0:	f000 fd5e 	bl	80a0eb0 <_ZN7TwoWire15endTransmissionEh>
	if (Wire.requestFrom(MPL3115A2_ADDRESS, 3) != 3) { // Request three bytes
 80a03f4:	f001 fe16 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a03f8:	2203      	movs	r2, #3
 80a03fa:	2160      	movs	r1, #96	; 0x60
 80a03fc:	f000 fd4e 	bl	80a0e9c <_ZN7TwoWire11requestFromEhj>
 80a0400:	2803      	cmp	r0, #3
 80a0402:	d12d      	bne.n	80a0460 <_ZN7Weather12readPressureEv+0x9c>
		return -999;
	}

	byte msb, csb, lsb;
	msb = Wire.read();
 80a0404:	f001 fe0e 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0408:	6803      	ldr	r3, [r0, #0]
 80a040a:	695b      	ldr	r3, [r3, #20]
 80a040c:	4798      	blx	r3
 80a040e:	4604      	mov	r4, r0
	csb = Wire.read();
 80a0410:	f001 fe08 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0414:	6803      	ldr	r3, [r0, #0]
	lsb = Wire.read();

	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading

	// Pressure comes back as a left shifted 20 bit number
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a0416:	0424      	lsls	r4, r4, #16
		return -999;
	}

	byte msb, csb, lsb;
	msb = Wire.read();
	csb = Wire.read();
 80a0418:	695b      	ldr	r3, [r3, #20]
 80a041a:	4798      	blx	r3
 80a041c:	4605      	mov	r5, r0
	lsb = Wire.read();
 80a041e:	f001 fe01 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0422:	6803      	ldr	r3, [r0, #0]

	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading

	// Pressure comes back as a left shifted 20 bit number
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a0424:	022d      	lsls	r5, r5, #8
	}

	byte msb, csb, lsb;
	msb = Wire.read();
	csb = Wire.read();
	lsb = Wire.read();
 80a0426:	695b      	ldr	r3, [r3, #20]
 80a0428:	4798      	blx	r3
 80a042a:	b2c6      	uxtb	r6, r0

	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a042c:	4638      	mov	r0, r7
 80a042e:	f7ff ffb1 	bl	80a0394 <_ZN7Weather13toggleOneShotEv>

	lsb &= 0b00110000; //Bits 5/4 represent the fractional component
	lsb >>= 4; //Get it right aligned
	float pressure_decimal = (float)lsb/4.0; //Turn it into fraction

	float pressure = (float)pressure_whole + pressure_decimal;
 80a0432:	f3c6 1001 	ubfx	r0, r6, #4, #2
 80a0436:	f002 fd53 	bl	80a2ee0 <__aeabi_ui2f>
 80a043a:	f04f 517a 	mov.w	r1, #1048576000	; 0x3e800000
 80a043e:	f002 fda7 	bl	80a2f90 <__aeabi_fmul>
	lsb = Wire.read();

	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading

	// Pressure comes back as a left shifted 20 bit number
	long pressure_whole = (long)msb<<16 | (long)csb<<8 | (long)lsb;
 80a0442:	f405 457f 	and.w	r5, r5, #65280	; 0xff00
 80a0446:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
 80a044a:	432c      	orrs	r4, r5
 80a044c:	4334      	orrs	r4, r6

	lsb &= 0b00110000; //Bits 5/4 represent the fractional component
	lsb >>= 4; //Get it right aligned
	float pressure_decimal = (float)lsb/4.0; //Turn it into fraction

	float pressure = (float)pressure_whole + pressure_decimal;
 80a044e:	4605      	mov	r5, r0
 80a0450:	09a0      	lsrs	r0, r4, #6
 80a0452:	f002 fd49 	bl	80a2ee8 <__aeabi_i2f>
 80a0456:	4601      	mov	r1, r0
 80a0458:	4628      	mov	r0, r5
 80a045a:	f002 fc91 	bl	80a2d80 <__addsf3>

	return(pressure);
 80a045e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	// Read pressure registers
	Wire.beginTransmission(MPL3115A2_ADDRESS);
	Wire.write(OUT_P_MSB);  // Address of data to get
	Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
	if (Wire.requestFrom(MPL3115A2_ADDRESS, 3) != 3) { // Request three bytes
		return -999;
 80a0460:	4800      	ldr	r0, [pc, #0]	; (80a0464 <_ZN7Weather12readPressureEv+0xa0>)
	float pressure_decimal = (float)lsb/4.0; //Turn it into fraction

	float pressure = (float)pressure_whole + pressure_decimal;

	return(pressure);
}
 80a0462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0464:	c479c000 	.word	0xc479c000

080a0468 <_ZN7Weather12readBaroTempEv>:

float Weather::readBaroTemp()
{
 80a0468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if(IIC_Read(STATUS) & (1<<1) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a046a:	2100      	movs	r1, #0

	return(pressure);
}

float Weather::readBaroTemp()
{
 80a046c:	4607      	mov	r7, r0
	if(IIC_Read(STATUS) & (1<<1) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a046e:	f240 2459 	movw	r4, #601	; 0x259
 80a0472:	f7ff fedf 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>

	//Wait for TDR bit, indicates we have new temp data
	int counter = 0;
	while( (IIC_Read(STATUS) & (1<<1)) == 0)
 80a0476:	2100      	movs	r1, #0
 80a0478:	4638      	mov	r0, r7
 80a047a:	f7ff fedb 	bl	80a0234 <_ZN7Weather8IIC_ReadEh>
 80a047e:	0782      	lsls	r2, r0, #30
 80a0480:	d407      	bmi.n	80a0492 <_ZN7Weather12readBaroTempEv+0x2a>
	{
		if(++counter > 600) return(-999); //Error out after max of 512ms for a read
 80a0482:	3c01      	subs	r4, #1
 80a0484:	d101      	bne.n	80a048a <_ZN7Weather12readBaroTempEv+0x22>
 80a0486:	4829      	ldr	r0, [pc, #164]	; (80a052c <_ZN7Weather12readBaroTempEv+0xc4>)
 80a0488:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		delay(1);
 80a048a:	2001      	movs	r0, #1
 80a048c:	f000 fc88 	bl	80a0da0 <delay>
{
	if(IIC_Read(STATUS) & (1<<1) == 0) toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading

	//Wait for TDR bit, indicates we have new temp data
	int counter = 0;
	while( (IIC_Read(STATUS) & (1<<1)) == 0)
 80a0490:	e7f1      	b.n	80a0476 <_ZN7Weather12readBaroTempEv+0xe>
		if(++counter > 600) return(-999); //Error out after max of 512ms for a read
		delay(1);
	}

	// Read temperature registers
	Wire.beginTransmission(MPL3115A2_ADDRESS);
 80a0492:	f001 fdc7 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a0496:	2160      	movs	r1, #96	; 0x60
 80a0498:	f000 fd07 	bl	80a0eaa <_ZN7TwoWire17beginTransmissionEi>
	Wire.write(OUT_T_MSB);  // Address of data to get
 80a049c:	f001 fdc2 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a04a0:	2104      	movs	r1, #4
 80a04a2:	f7ff fe08 	bl	80a00b6 <_ZN7TwoWire5writeEi>
	Wire.endTransmission(false); // Send data to I2C dev with option for a repeated start. THIS IS NECESSARY and not supported before Arduino V1.0.1!
 80a04a6:	f001 fdbd 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a04aa:	2100      	movs	r1, #0
 80a04ac:	f000 fd00 	bl	80a0eb0 <_ZN7TwoWire15endTransmissionEh>
	if (Wire.requestFrom(MPL3115A2_ADDRESS, 2) != 2) { // Request two bytes
 80a04b0:	f001 fdb8 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a04b4:	2202      	movs	r2, #2
 80a04b6:	2160      	movs	r1, #96	; 0x60
 80a04b8:	f000 fcf0 	bl	80a0e9c <_ZN7TwoWire11requestFromEhj>
 80a04bc:	2802      	cmp	r0, #2
 80a04be:	d1e2      	bne.n	80a0486 <_ZN7Weather12readBaroTempEv+0x1e>
		return -999;
	}

	byte msb, lsb;
	msb = Wire.read();
 80a04c0:	f001 fdb0 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a04c4:	6803      	ldr	r3, [r0, #0]
 80a04c6:	695b      	ldr	r3, [r3, #20]
 80a04c8:	4798      	blx	r3
 80a04ca:	4606      	mov	r6, r0
 80a04cc:	b2c5      	uxtb	r5, r0
	lsb = Wire.read();
 80a04ce:	f001 fda9 	bl	80a2024 <_Z19__fetch_global_Wirev>
 80a04d2:	6803      	ldr	r3, [r0, #0]
 80a04d4:	695b      	ldr	r3, [r3, #20]
 80a04d6:	4798      	blx	r3
 80a04d8:	b2c4      	uxtb	r4, r0

	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading
 80a04da:	4638      	mov	r0, r7
 80a04dc:	f7ff ff5a 	bl	80a0394 <_ZN7Weather13toggleOneShotEv>
    //Negative temperature fix by D.D.G.
    uint16_t foo = 0;
    bool negSign = false;

    //Check for 2s compliment
	if(msb > 0x7F)
 80a04e0:	0633      	lsls	r3, r6, #24
	{
        foo = ~((msb << 8) + lsb) + 1;  //2’s complement
 80a04e2:	bf41      	itttt	mi
 80a04e4:	eb04 2405 	addmi.w	r4, r4, r5, lsl #8
 80a04e8:	4264      	negmi	r4, r4
 80a04ea:	b2a4      	uxthmi	r4, r4
        msb = foo >> 8;
 80a04ec:	0a25      	lsrmi	r5, r4, #8
        lsb = foo & 0x00F0;
 80a04ee:	bf48      	it	mi
 80a04f0:	f004 04f0 	andmi.w	r4, r4, #240	; 0xf0
	// fractional values, so you must cast the calulation in (float),
	// shift the value over 4 spots to the right and divide by 16 (since
	// there are 16 values in 4-bits).
	float templsb = (lsb>>4)/16.0; //temp, fraction of a degree

	float temperature = (float)(msb + templsb);
 80a04f4:	ea4f 1014 	mov.w	r0, r4, lsr #4
	if(msb > 0x7F)
	{
        foo = ~((msb << 8) + lsb) + 1;  //2’s complement
        msb = foo >> 8;
        lsb = foo & 0x00F0;
        negSign = true;
 80a04f8:	bf4c      	ite	mi
 80a04fa:	2601      	movmi	r6, #1

	toggleOneShot(); //Toggle the OST bit causing the sensor to immediately take another reading

    //Negative temperature fix by D.D.G.
    uint16_t foo = 0;
    bool negSign = false;
 80a04fc:	2600      	movpl	r6, #0
	// fractional values, so you must cast the calulation in (float),
	// shift the value over 4 spots to the right and divide by 16 (since
	// there are 16 values in 4-bits).
	float templsb = (lsb>>4)/16.0; //temp, fraction of a degree

	float temperature = (float)(msb + templsb);
 80a04fe:	f002 f88b 	bl	80a2618 <__aeabi_i2d>
 80a0502:	2200      	movs	r2, #0
 80a0504:	4b0a      	ldr	r3, [pc, #40]	; (80a0530 <_ZN7Weather12readBaroTempEv+0xc8>)
 80a0506:	f002 f8ed 	bl	80a26e4 <__aeabi_dmul>
 80a050a:	f002 fbe3 	bl	80a2cd4 <__aeabi_d2f>
 80a050e:	4604      	mov	r4, r0
 80a0510:	4628      	mov	r0, r5
 80a0512:	f002 fce9 	bl	80a2ee8 <__aeabi_i2f>
 80a0516:	4601      	mov	r1, r0
 80a0518:	4620      	mov	r0, r4
 80a051a:	f002 fc31 	bl	80a2d80 <__addsf3>

	if (negSign) temperature = 0 - temperature;
 80a051e:	b11e      	cbz	r6, 80a0528 <_ZN7Weather12readBaroTempEv+0xc0>
 80a0520:	4601      	mov	r1, r0
 80a0522:	2000      	movs	r0, #0
 80a0524:	f002 fc2a 	bl	80a2d7c <__aeabi_fsub>

	return(temperature);
}
 80a0528:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a052a:	bf00      	nop
 80a052c:	c479c000 	.word	0xc479c000
 80a0530:	3fb00000 	.word	0x3fb00000

080a0534 <_ZN7Weather13readBaroTempFEv>:

//Give me temperature in fahrenheit!
float Weather::readBaroTempF()
{
 80a0534:	b508      	push	{r3, lr}
  return((readBaroTemp() * 9.0)/ 5.0 + 32.0); // Convert celsius to fahrenheit
 80a0536:	f7ff ff97 	bl	80a0468 <_ZN7Weather12readBaroTempEv>
 80a053a:	f002 f87f 	bl	80a263c <__aeabi_f2d>
 80a053e:	2200      	movs	r2, #0
 80a0540:	4b06      	ldr	r3, [pc, #24]	; (80a055c <_ZN7Weather13readBaroTempFEv+0x28>)
 80a0542:	f002 f8cf 	bl	80a26e4 <__aeabi_dmul>
 80a0546:	2200      	movs	r2, #0
 80a0548:	4b05      	ldr	r3, [pc, #20]	; (80a0560 <_ZN7Weather13readBaroTempFEv+0x2c>)
 80a054a:	f002 f9f5 	bl	80a2938 <__aeabi_ddiv>
 80a054e:	2200      	movs	r2, #0
 80a0550:	4b04      	ldr	r3, [pc, #16]	; (80a0564 <_ZN7Weather13readBaroTempFEv+0x30>)
 80a0552:	f001 ff15 	bl	80a2380 <__adddf3>
 80a0556:	f002 fbbd 	bl	80a2cd4 <__aeabi_d2f>
}
 80a055a:	bd08      	pop	{r3, pc}
 80a055c:	40220000 	.word	0x40220000
 80a0560:	40140000 	.word	0x40140000
 80a0564:	40400000 	.word	0x40400000

080a0568 <_GLOBAL__sub_I__ZN7WeatherC2Ev>:
inline int32_t pinReadFast(pin_t _pin)
{
    return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static Hal_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a0568:	f000 ba4a 	b.w	80a0a00 <HAL_Pin_Map>

080a056c <_ZN9TCPClientD1Ev>:
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
 80a056c:	b538      	push	{r3, r4, r5, lr}
 80a056e:	4b0b      	ldr	r3, [pc, #44]	; (80a059c <_ZN9TCPClientD1Ev+0x30>)
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a0570:	6984      	ldr	r4, [r0, #24]
 80a0572:	4605      	mov	r5, r0
 80a0574:	6003      	str	r3, [r0, #0]
 80a0576:	b17c      	cbz	r4, 80a0598 <_ZN9TCPClientD1Ev+0x2c>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a0578:	6863      	ldr	r3, [r4, #4]
 80a057a:	3b01      	subs	r3, #1
 80a057c:	6063      	str	r3, [r4, #4]
 80a057e:	b95b      	cbnz	r3, 80a0598 <_ZN9TCPClientD1Ev+0x2c>
        {
          _M_dispose();
 80a0580:	6823      	ldr	r3, [r4, #0]
 80a0582:	4620      	mov	r0, r4
 80a0584:	689b      	ldr	r3, [r3, #8]
 80a0586:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a0588:	68a3      	ldr	r3, [r4, #8]
 80a058a:	3b01      	subs	r3, #1
 80a058c:	60a3      	str	r3, [r4, #8]
 80a058e:	b91b      	cbnz	r3, 80a0598 <_ZN9TCPClientD1Ev+0x2c>
            _M_destroy();
 80a0590:	6823      	ldr	r3, [r4, #0]
 80a0592:	4620      	mov	r0, r4
 80a0594:	68db      	ldr	r3, [r3, #12]
 80a0596:	4798      	blx	r3
 80a0598:	4628      	mov	r0, r5
 80a059a:	bd38      	pop	{r3, r4, r5, pc}
 80a059c:	080a3604 	.word	0x080a3604

080a05a0 <_ZN9TCPClientD0Ev>:
 80a05a0:	b510      	push	{r4, lr}
 80a05a2:	4604      	mov	r4, r0
 80a05a4:	f7ff ffe2 	bl	80a056c <_ZN9TCPClientD1Ev>
 80a05a8:	4620      	mov	r0, r4
 80a05aa:	211c      	movs	r1, #28
 80a05ac:	f001 fd7d 	bl	80a20aa <_ZdlPvj>
 80a05b0:	4620      	mov	r0, r4
 80a05b2:	bd10      	pop	{r4, pc}

080a05b4 <_ZN5spark10JSONWriter4nameEPKc>:
// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
}

inline spark::JSONWriter& spark::JSONWriter::name(const char *name) {
 80a05b4:	b538      	push	{r3, r4, r5, lr}
 80a05b6:	4605      	mov	r5, r0
    return this->name(name, strlen(name));
 80a05b8:	4608      	mov	r0, r1
// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
}

inline spark::JSONWriter& spark::JSONWriter::name(const char *name) {
 80a05ba:	460c      	mov	r4, r1
    return this->name(name, strlen(name));
 80a05bc:	f002 fe82 	bl	80a32c4 <strlen>
 80a05c0:	4621      	mov	r1, r4
 80a05c2:	4602      	mov	r2, r0
 80a05c4:	4628      	mov	r0, r5
}
 80a05c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
}

inline spark::JSONWriter& spark::JSONWriter::name(const char *name) {
    return this->name(name, strlen(name));
 80a05ca:	f000 bdbb 	b.w	80a1144 <_ZN5spark10JSONWriter4nameEPKcj>
	...

080a05d0 <setup>:
const char *ssid = "PerkyMesh"; // replace with your wifi ssid and wpa2 key
const char *pass = "phobicstreet139";

//---------------------------------------------------------------
void setup()
{
 80a05d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  WiFi.setCredentials(ssid, pass);
 80a05d4:	4b28      	ldr	r3, [pc, #160]	; (80a0678 <setup+0xa8>)
const char *ssid = "PerkyMesh"; // replace with your wifi ssid and wpa2 key
const char *pass = "phobicstreet139";

//---------------------------------------------------------------
void setup()
{
 80a05d6:	b094      	sub	sp, #80	; 0x50
  WiFi.setCredentials(ssid, pass);
 80a05d8:	681d      	ldr	r5, [r3, #0]
 80a05da:	4b28      	ldr	r3, [pc, #160]	; (80a067c <setup+0xac>)
 80a05dc:	681c      	ldr	r4, [r3, #0]
    bool setCredentials(const char *ssid, const char *password) {
        return setCredentials(ssid, password, WPA2);
    }

    bool setCredentials(const char *ssid, const char *password, unsigned long security, unsigned long cipher=WLAN_CIPHER_NOT_SET) {
        return setCredentials(ssid, ssid ? strlen(ssid) : 0, password, password ? strlen(password) : 0, security, cipher);
 80a05de:	b125      	cbz	r5, 80a05ea <setup+0x1a>
 80a05e0:	4628      	mov	r0, r5
 80a05e2:	f002 fe6f 	bl	80a32c4 <strlen>
 80a05e6:	4607      	mov	r7, r0
 80a05e8:	e000      	b.n	80a05ec <setup+0x1c>
 80a05ea:	462f      	mov	r7, r5
 80a05ec:	b124      	cbz	r4, 80a05f8 <setup+0x28>
 80a05ee:	4620      	mov	r0, r4
 80a05f0:	f002 fe68 	bl	80a32c4 <strlen>
 80a05f4:	4606      	mov	r6, r0
 80a05f6:	e000      	b.n	80a05fa <setup+0x2a>
 80a05f8:	4626      	mov	r6, r4

    bool setCredentials(const char *ssid, unsigned int ssidLen, const char *password,
            unsigned int passwordLen, unsigned long security=WLAN_SEC_UNSEC, unsigned long cipher=WLAN_CIPHER_NOT_SET) {

        WLanCredentials creds;
        memset(&creds, 0, sizeof(creds));
 80a05fa:	f04f 084c 	mov.w	r8, #76	; 0x4c
 80a05fe:	4642      	mov	r2, r8
 80a0600:	2100      	movs	r1, #0
 80a0602:	a801      	add	r0, sp, #4
 80a0604:	f002 fe2d 	bl	80a3262 <memset>
        creds.size = sizeof(creds);
        creds.ssid = ssid;
        creds.ssid_len = ssidLen;
        creds.password = password;
 80a0608:	9404      	str	r4, [sp, #16]
        creds.password_len = passwordLen;
        creds.security = WLanSecurityType(security);
 80a060a:	2303      	movs	r3, #3
 80a060c:	4c1c      	ldr	r4, [pc, #112]	; (80a0680 <setup+0xb0>)
 80a060e:	f88d 3018 	strb.w	r3, [sp, #24]
        creds.cipher = WLanSecurityCipher(cipher);
        return (network_set_credentials(*this, 0, &creds, NULL) == 0);
 80a0612:	2300      	movs	r3, #0
 80a0614:	4619      	mov	r1, r3
 80a0616:	aa01      	add	r2, sp, #4
 80a0618:	6860      	ldr	r0, [r4, #4]
    bool setCredentials(const char *ssid, unsigned int ssidLen, const char *password,
            unsigned int passwordLen, unsigned long security=WLAN_SEC_UNSEC, unsigned long cipher=WLAN_CIPHER_NOT_SET) {

        WLanCredentials creds;
        memset(&creds, 0, sizeof(creds));
        creds.size = sizeof(creds);
 80a061a:	f8cd 8004 	str.w	r8, [sp, #4]
        creds.ssid = ssid;
 80a061e:	9502      	str	r5, [sp, #8]
        creds.ssid_len = ssidLen;
 80a0620:	9703      	str	r7, [sp, #12]
        creds.password = password;
        creds.password_len = passwordLen;
 80a0622:	9605      	str	r6, [sp, #20]
        creds.security = WLanSecurityType(security);
        creds.cipher = WLanSecurityCipher(cipher);
        return (network_set_credentials(*this, 0, &creds, NULL) == 0);
 80a0624:	f000 fb7c 	bl	80a0d20 <network_set_credentials>
  Serial.begin(9600); // open serial over USB at 9600 baud
 80a0628:	f001 fb84 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a062c:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0630:	f001 fb66 	bl	80a1d00 <_ZN9USBSerial5beginEl>
    uint32_t ping(IPAddress remoteIP, uint8_t nTries) {
        return inet_ping(&remoteIP.raw(), *this, nTries, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
 80a0634:	2300      	movs	r3, #0
 80a0636:	461a      	mov	r2, r3
 80a0638:	4619      	mov	r1, r3
 80a063a:	6860      	ldr	r0, [r4, #4]
 80a063c:	f000 fb30 	bl	80a0ca0 <network_connect>
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a0640:	2200      	movs	r2, #0
 80a0642:	4611      	mov	r1, r2
 80a0644:	6860      	ldr	r0, [r4, #4]
 80a0646:	f000 fb43 	bl	80a0cd0 <network_ready>

  // Make sure your Serial Terminal app is closed before powering your device
  // Now open your Serial Terminal, and hit any key to continue!
  WiFi.connect();
  while (!WiFi.ready())
 80a064a:	b920      	cbnz	r0, 80a0656 <setup+0x86>
  {
    delay(500);
 80a064c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a0650:	f000 fba6 	bl	80a0da0 <delay>
  Serial.begin(9600); // open serial over USB at 9600 baud

  // Make sure your Serial Terminal app is closed before powering your device
  // Now open your Serial Terminal, and hit any key to continue!
  WiFi.connect();
  while (!WiFi.ready())
 80a0654:	e7f4      	b.n	80a0640 <setup+0x70>
  {
    delay(500);
  }

  //Initialize the I2C sensors and ping them
  sensor.begin();
 80a0656:	480b      	ldr	r0, [pc, #44]	; (80a0684 <setup+0xb4>)
 80a0658:	f7ff fe0c 	bl	80a0274 <_ZN7Weather5beginEv>
    tell the sensor what mode to use. You could easily write a function that
    takes a reading in one made and then switches to the other mode to grab that
    reading, resulting in data that contains both accurate altitude and barometric
    readings. For this example, we will only be using the barometer mode. Be sure
    to only uncomment one line at a time. */
  sensor.setModeBarometer(); //Set to Barometer Mode
 80a065c:	4809      	ldr	r0, [pc, #36]	; (80a0684 <setup+0xb4>)
 80a065e:	f7ff fe74 	bl	80a034a <_ZN7Weather16setModeBarometerEv>
  //sensor.setModeAltimeter();//Set to altimeter Mode

  //These are additional MPL3115A2 functions that MUST be called for the sensor to work.
  sensor.setOversampleRate(7); // Set Oversample rate
 80a0662:	2107      	movs	r1, #7
 80a0664:	4807      	ldr	r0, [pc, #28]	; (80a0684 <setup+0xb4>)
 80a0666:	f7ff fe7d 	bl	80a0364 <_ZN7Weather17setOversampleRateEh>
  //Call with a rate from 0 to 7. See page 33 for table of ratios.
  //Sets the over sample rate. Datasheet calls for 128 but you can set it
  //from 1 to 128 samples. The higher the oversample rate the greater
  //the time between data samples.

  sensor.enableEventFlags(); //Necessary register calls to enble temp, baro and alt
 80a066a:	4806      	ldr	r0, [pc, #24]	; (80a0684 <setup+0xb4>)
 80a066c:	f7ff fe8e 	bl	80a038c <_ZN7Weather16enableEventFlagsEv>
}
 80a0670:	b014      	add	sp, #80	; 0x50
 80a0672:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0676:	bf00      	nop
 80a0678:	20000004 	.word	0x20000004
 80a067c:	20000000 	.word	0x20000000
 80a0680:	20000540 	.word	0x20000540
 80a0684:	20000078 	.word	0x20000078

080a0688 <_Z10getWeatherv>:
    printInfo();
  }
}
//---------------------------------------------------------------
void getWeather()
{
 80a0688:	b510      	push	{r4, lr}
  // Measure Relative Humidity from the HTU21D or Si7021
  humidity = sensor.getRH();
 80a068a:	4c0b      	ldr	r4, [pc, #44]	; (80a06b8 <_Z10getWeatherv+0x30>)
 80a068c:	4620      	mov	r0, r4
 80a068e:	f7ff fd77 	bl	80a0180 <_ZN7Weather5getRHEv>
 80a0692:	4b0a      	ldr	r3, [pc, #40]	; (80a06bc <_Z10getWeatherv+0x34>)
 80a0694:	6018      	str	r0, [r3, #0]

  // Measure Temperature from the HTU21D or Si7021
  tempf = sensor.getTempF();
 80a0696:	4620      	mov	r0, r4
 80a0698:	f7ff fdb2 	bl	80a0200 <_ZN7Weather8getTempFEv>
 80a069c:	4b08      	ldr	r3, [pc, #32]	; (80a06c0 <_Z10getWeatherv+0x38>)
 80a069e:	6018      	str	r0, [r3, #0]
  // Temperature is measured every time RH is requested.
  // It is faster, therefore, to read it from previous RH
  // measurement with getTemp() instead with readTemp()

  //Measure the Barometer temperature in F from the MPL3115A2
  baroTemp = sensor.readBaroTempF();
 80a06a0:	4620      	mov	r0, r4
 80a06a2:	f7ff ff47 	bl	80a0534 <_ZN7Weather13readBaroTempFEv>
 80a06a6:	4b07      	ldr	r3, [pc, #28]	; (80a06c4 <_Z10getWeatherv+0x3c>)
 80a06a8:	6018      	str	r0, [r3, #0]

  //Measure Pressure from the MPL3115A2
  pascals = sensor.readPressure();
 80a06aa:	4620      	mov	r0, r4
 80a06ac:	f7ff fe8a 	bl	80a03c4 <_ZN7Weather12readPressureEv>
 80a06b0:	4b05      	ldr	r3, [pc, #20]	; (80a06c8 <_Z10getWeatherv+0x40>)
 80a06b2:	6018      	str	r0, [r3, #0]
 80a06b4:	bd10      	pop	{r4, pc}
 80a06b6:	bf00      	nop
 80a06b8:	20000078 	.word	0x20000078
 80a06bc:	200000a4 	.word	0x200000a4
 80a06c0:	20000074 	.word	0x20000074
 80a06c4:	20000080 	.word	0x20000080
 80a06c8:	200000a0 	.word	0x200000a0

080a06cc <_Z9send_dataPc>:
  Serial.printf("%s", buf);
  send_data(buf);
}

void send_data(char *buf)
{
 80a06cc:	b510      	push	{r4, lr}
 80a06ce:	b0a0      	sub	sp, #128	; 0x80
 80a06d0:	4604      	mov	r4, r0

  TCPClient client;
 80a06d2:	a805      	add	r0, sp, #20
 80a06d4:	f001 f9de 	bl	80a1a94 <_ZN9TCPClientC1Ev>
  byte server[] = {192, 168, 1, 49};
 80a06d8:	4b23      	ldr	r3, [pc, #140]	; (80a0768 <_Z9send_dataPc+0x9c>)

  String receivedData;
 80a06da:	4924      	ldr	r1, [pc, #144]	; (80a076c <_Z9send_dataPc+0xa0>)

void send_data(char *buf)
{

  TCPClient client;
  byte server[] = {192, 168, 1, 49};
 80a06dc:	6818      	ldr	r0, [r3, #0]
 80a06de:	9000      	str	r0, [sp, #0]

  String receivedData;
 80a06e0:	a801      	add	r0, sp, #4
 80a06e2:	f000 ff7e 	bl	80a15e2 <_ZN6StringC1EPK19__FlashStringHelper>

  if (client.connect(server, 3001))
 80a06e6:	4669      	mov	r1, sp
 80a06e8:	a80c      	add	r0, sp, #48	; 0x30
 80a06ea:	f000 fc57 	bl	80a0f9c <_ZN9IPAddressC1EPKh>
 80a06ee:	2300      	movs	r3, #0
 80a06f0:	f640 32b9 	movw	r2, #3001	; 0xbb9
 80a06f4:	a90c      	add	r1, sp, #48	; 0x30
 80a06f6:	a805      	add	r0, sp, #20
 80a06f8:	f001 f8b6 	bl	80a1868 <_ZN9TCPClient7connectE9IPAddresstm>
 80a06fc:	b338      	cbz	r0, 80a074e <_Z9send_dataPc+0x82>
  {
    char content_length[80];
    sprintf(content_length, "Content-Length: %d", strlen(buf));
 80a06fe:	4620      	mov	r0, r4
 80a0700:	f002 fde0 	bl	80a32c4 <strlen>
 80a0704:	491a      	ldr	r1, [pc, #104]	; (80a0770 <_Z9send_dataPc+0xa4>)
 80a0706:	4602      	mov	r2, r0
 80a0708:	a80c      	add	r0, sp, #48	; 0x30
 80a070a:	f000 fb39 	bl	80a0d80 <sprintf>
    Serial.print("connected");
 80a070e:	f001 fb11 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a0712:	4918      	ldr	r1, [pc, #96]	; (80a0774 <_Z9send_dataPc+0xa8>)
 80a0714:	f000 fdc6 	bl	80a12a4 <_ZN5Print5printEPKc>
    client.println("POST /weather HTTP/1.1");
 80a0718:	4917      	ldr	r1, [pc, #92]	; (80a0778 <_Z9send_dataPc+0xac>)
 80a071a:	a805      	add	r0, sp, #20
 80a071c:	f000 fdd5 	bl	80a12ca <_ZN5Print7printlnEPKc>
    client.println("Host: 192.168.1.49:3001");
 80a0720:	4916      	ldr	r1, [pc, #88]	; (80a077c <_Z9send_dataPc+0xb0>)
 80a0722:	a805      	add	r0, sp, #20
 80a0724:	f000 fdd1 	bl	80a12ca <_ZN5Print7printlnEPKc>
    client.println("Content-Type: application/json");
 80a0728:	4915      	ldr	r1, [pc, #84]	; (80a0780 <_Z9send_dataPc+0xb4>)
 80a072a:	a805      	add	r0, sp, #20
 80a072c:	f000 fdcd 	bl	80a12ca <_ZN5Print7printlnEPKc>
    client.println(content_length);
 80a0730:	a90c      	add	r1, sp, #48	; 0x30
 80a0732:	a805      	add	r0, sp, #20
 80a0734:	f000 fdc9 	bl	80a12ca <_ZN5Print7printlnEPKc>
    client.println();
 80a0738:	a805      	add	r0, sp, #20
 80a073a:	f000 fdba 	bl	80a12b2 <_ZN5Print7printlnEv>
    client.print(buf);
 80a073e:	4621      	mov	r1, r4
 80a0740:	a805      	add	r0, sp, #20
 80a0742:	f000 fdaf 	bl	80a12a4 <_ZN5Print5printEPKc>

    // Stop the current connection
    client.stop();
 80a0746:	a805      	add	r0, sp, #20
 80a0748:	f001 f874 	bl	80a1834 <_ZN9TCPClient4stopEv>
 80a074c:	e004      	b.n	80a0758 <_Z9send_dataPc+0x8c>
  }
  else
  {
    Serial.println("Unable To Connect");
 80a074e:	f001 faf1 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a0752:	490c      	ldr	r1, [pc, #48]	; (80a0784 <_Z9send_dataPc+0xb8>)
 80a0754:	f000 fdb9 	bl	80a12ca <_ZN5Print7printlnEPKc>
{

  TCPClient client;
  byte server[] = {192, 168, 1, 49};

  String receivedData;
 80a0758:	a801      	add	r0, sp, #4
 80a075a:	f000 fefb 	bl	80a1554 <_ZN6StringD1Ev>
}

void send_data(char *buf)
{

  TCPClient client;
 80a075e:	a805      	add	r0, sp, #20
 80a0760:	f7ff ff04 	bl	80a056c <_ZN9TCPClientD1Ev>
  }
  else
  {
    Serial.println("Unable To Connect");
  }
}
 80a0764:	b020      	add	sp, #128	; 0x80
 80a0766:	bd10      	pop	{r4, pc}
 80a0768:	080a335b 	.word	0x080a335b
 80a076c:	080a3562 	.word	0x080a3562
 80a0770:	080a335f 	.word	0x080a335f
 80a0774:	080a3372 	.word	0x080a3372
 80a0778:	080a337c 	.word	0x080a337c
 80a077c:	080a3393 	.word	0x080a3393
 80a0780:	080a33ab 	.word	0x080a33ab
 80a0784:	080a33ca 	.word	0x080a33ca

080a0788 <_Z9printInfov>:
  //If in altitude mode, you can get a reading in feet with this line:
  //float altf = sensor.readAltitudeFt();
}
//---------------------------------------------------------------
void printInfo()
{
 80a0788:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  //This function prints the weather data out to the default Serial Port

  Serial.print("Temp:");
  Serial.print(tempf);
 80a078c:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 80a0958 <_Z9printInfov+0x1d0>
  //If in altitude mode, you can get a reading in feet with this line:
  //float altf = sensor.readAltitudeFt();
}
//---------------------------------------------------------------
void printInfo()
{
 80a0790:	b0a0      	sub	sp, #128	; 0x80
  //This function prints the weather data out to the default Serial Port

  Serial.print("Temp:");
 80a0792:	f001 facf 	bl	80a1d34 <_Z16_fetch_usbserialv>
  Serial.print(tempf);
  Serial.print("F, ");
 80a0796:	4c60      	ldr	r4, [pc, #384]	; (80a0918 <_Z9printInfov+0x190>)
//---------------------------------------------------------------
void printInfo()
{
  //This function prints the weather data out to the default Serial Port

  Serial.print("Temp:");
 80a0798:	4960      	ldr	r1, [pc, #384]	; (80a091c <_Z9printInfov+0x194>)
 80a079a:	f000 fd83 	bl	80a12a4 <_ZN5Print5printEPKc>
  Serial.print(tempf);
 80a079e:	f001 fac9 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07a2:	2202      	movs	r2, #2
 80a07a4:	f8d9 1000 	ldr.w	r1, [r9]
 80a07a8:	f000 fe72 	bl	80a1490 <_ZN5Print5printEfi>
  Serial.print("F, ");

  Serial.print("Humidity:");
  Serial.print(humidity);
 80a07ac:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 80a095c <_Z9printInfov+0x1d4>
{
  //This function prints the weather data out to the default Serial Port

  Serial.print("Temp:");
  Serial.print(tempf);
  Serial.print("F, ");
 80a07b0:	f001 fac0 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07b4:	4621      	mov	r1, r4
 80a07b6:	f000 fd75 	bl	80a12a4 <_ZN5Print5printEPKc>

  Serial.print("Humidity:");
 80a07ba:	f001 fabb 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07be:	4958      	ldr	r1, [pc, #352]	; (80a0920 <_Z9printInfov+0x198>)
 80a07c0:	f000 fd70 	bl	80a12a4 <_ZN5Print5printEPKc>
  Serial.print(humidity);
 80a07c4:	f001 fab6 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07c8:	2202      	movs	r2, #2
 80a07ca:	f8d8 1000 	ldr.w	r1, [r8]
 80a07ce:	f000 fe5f 	bl	80a1490 <_ZN5Print5printEfi>
  Serial.print("%, ");

  Serial.print("Baro_Temp:");
  Serial.print(baroTemp);
 80a07d2:	4f54      	ldr	r7, [pc, #336]	; (80a0924 <_Z9printInfov+0x19c>)
  Serial.print(tempf);
  Serial.print("F, ");

  Serial.print("Humidity:");
  Serial.print(humidity);
  Serial.print("%, ");
 80a07d4:	f001 faae 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07d8:	4953      	ldr	r1, [pc, #332]	; (80a0928 <_Z9printInfov+0x1a0>)
 80a07da:	f000 fd63 	bl	80a12a4 <_ZN5Print5printEPKc>

  Serial.print("Baro_Temp:");
 80a07de:	f001 faa9 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07e2:	4952      	ldr	r1, [pc, #328]	; (80a092c <_Z9printInfov+0x1a4>)
 80a07e4:	f000 fd5e 	bl	80a12a4 <_ZN5Print5printEPKc>
  Serial.print(baroTemp);
 80a07e8:	f001 faa4 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07ec:	2202      	movs	r2, #2
 80a07ee:	6839      	ldr	r1, [r7, #0]
 80a07f0:	f000 fe4e 	bl	80a1490 <_ZN5Print5printEfi>
  Serial.print("F, ");
 80a07f4:	f001 fa9e 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a07f8:	4621      	mov	r1, r4
 80a07fa:	f000 fd53 	bl	80a12a4 <_ZN5Print5printEPKc>

  Serial.print("Pressure:");
 80a07fe:	f001 fa99 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a0802:	494b      	ldr	r1, [pc, #300]	; (80a0930 <_Z9printInfov+0x1a8>)
 80a0804:	f000 fd4e 	bl	80a12a4 <_ZN5Print5printEPKc>
  Serial.print(pascals / 100);
 80a0808:	f001 fa94 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a080c:	4e49      	ldr	r6, [pc, #292]	; (80a0934 <_Z9printInfov+0x1ac>)
 80a080e:	4604      	mov	r4, r0
 80a0810:	4949      	ldr	r1, [pc, #292]	; (80a0938 <_Z9printInfov+0x1b0>)
 80a0812:	6830      	ldr	r0, [r6, #0]
 80a0814:	f002 fc70 	bl	80a30f8 <__aeabi_fdiv>
 80a0818:	2202      	movs	r2, #2
 80a081a:	4601      	mov	r1, r0
 80a081c:	4620      	mov	r0, r4
 80a081e:	f000 fe37 	bl	80a1490 <_ZN5Print5printEfi>
  Serial.print("hPa, ");
 80a0822:	f001 fa87 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a0826:	4945      	ldr	r1, [pc, #276]	; (80a093c <_Z9printInfov+0x1b4>)
 80a0828:	f000 fd3c 	bl	80a12a4 <_ZN5Print5printEPKc>
  Serial.print((pascals / 100) * 0.0295300);
 80a082c:	f001 fa82 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a0830:	4941      	ldr	r1, [pc, #260]	; (80a0938 <_Z9printInfov+0x1b0>)
 80a0832:	4604      	mov	r4, r0
 80a0834:	6830      	ldr	r0, [r6, #0]
 80a0836:	f002 fc5f 	bl	80a30f8 <__aeabi_fdiv>
 80a083a:	f001 feff 	bl	80a263c <__aeabi_f2d>
 80a083e:	a334      	add	r3, pc, #208	; (adr r3, 80a0910 <_Z9printInfov+0x188>)
 80a0840:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a0844:	f001 ff4e 	bl	80a26e4 <__aeabi_dmul>
 80a0848:	2302      	movs	r3, #2
 80a084a:	9300      	str	r3, [sp, #0]
 80a084c:	4602      	mov	r2, r0
 80a084e:	460b      	mov	r3, r1
 80a0850:	4620      	mov	r0, r4
  //Serial.print(altf);

  char buf[100];
  JSONWriter &beginObject();
  // EXAMPLE
  memset(buf, 0, sizeof(buf));
 80a0852:	ac07      	add	r4, sp, #28
  Serial.print("F, ");

  Serial.print("Pressure:");
  Serial.print(pascals / 100);
  Serial.print("hPa, ");
  Serial.print((pascals / 100) * 0.0295300);
 80a0854:	f000 fe2b 	bl	80a14ae <_ZN5Print5printEdi>
  //Serial.print(altf);

  char buf[100];
  JSONWriter &beginObject();
  // EXAMPLE
  memset(buf, 0, sizeof(buf));
 80a0858:	2264      	movs	r2, #100	; 0x64
 80a085a:	2100      	movs	r1, #0
 80a085c:	4620      	mov	r0, r4
 80a085e:	f002 fd00 	bl	80a3262 <memset>

// spark::JSONBufferWriter
inline spark::JSONBufferWriter::JSONBufferWriter(char *buf, size_t size) :
        buf_(buf),
        bufSize_(size),
        n_(0) {
 80a0862:	4b37      	ldr	r3, [pc, #220]	; (80a0940 <_Z9printInfov+0x1b8>)
    return n_;
}

// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
 80a0864:	2500      	movs	r5, #0

// spark::JSONBufferWriter
inline spark::JSONBufferWriter::JSONBufferWriter(char *buf, size_t size) :
        buf_(buf),
        bufSize_(size),
        n_(0) {
 80a0866:	9302      	str	r3, [sp, #8]
  JSONBufferWriter writer(buf, sizeof(buf) - 1);
  writer.beginObject();
 80a0868:	a802      	add	r0, sp, #8
 80a086a:	2363      	movs	r3, #99	; 0x63
 80a086c:	9305      	str	r3, [sp, #20]
    return n_;
}

// spark::JSONWriter
inline spark::JSONWriter::JSONWriter() :
        state_(BEGIN) {
 80a086e:	f88d 500c 	strb.w	r5, [sp, #12]

// spark::JSONBufferWriter
inline spark::JSONBufferWriter::JSONBufferWriter(char *buf, size_t size) :
        buf_(buf),
        bufSize_(size),
        n_(0) {
 80a0872:	9404      	str	r4, [sp, #16]
 80a0874:	9506      	str	r5, [sp, #24]
 80a0876:	f000 fbf1 	bl	80a105c <_ZN5spark10JSONWriter11beginObjectEv>
  writer.name("temp").value(tempf);
 80a087a:	4932      	ldr	r1, [pc, #200]	; (80a0944 <_Z9printInfov+0x1bc>)
 80a087c:	a802      	add	r0, sp, #8
 80a087e:	f7ff fe99 	bl	80a05b4 <_ZN5spark10JSONWriter4nameEPKc>
 80a0882:	4682      	mov	sl, r0
 80a0884:	f8d9 0000 	ldr.w	r0, [r9]
 80a0888:	f001 fed8 	bl	80a263c <__aeabi_f2d>
 80a088c:	4602      	mov	r2, r0
 80a088e:	460b      	mov	r3, r1
 80a0890:	4650      	mov	r0, sl
 80a0892:	f000 fbef 	bl	80a1074 <_ZN5spark10JSONWriter5valueEd>
  writer.name("humidity").value(humidity);
 80a0896:	492c      	ldr	r1, [pc, #176]	; (80a0948 <_Z9printInfov+0x1c0>)
 80a0898:	a802      	add	r0, sp, #8
 80a089a:	f7ff fe8b 	bl	80a05b4 <_ZN5spark10JSONWriter4nameEPKc>
 80a089e:	4681      	mov	r9, r0
 80a08a0:	f8d8 0000 	ldr.w	r0, [r8]
 80a08a4:	f001 feca 	bl	80a263c <__aeabi_f2d>
 80a08a8:	4602      	mov	r2, r0
 80a08aa:	460b      	mov	r3, r1
 80a08ac:	4648      	mov	r0, r9
 80a08ae:	f000 fbe1 	bl	80a1074 <_ZN5spark10JSONWriter5valueEd>
  writer.name("baro_temp").value(baroTemp);
 80a08b2:	4926      	ldr	r1, [pc, #152]	; (80a094c <_Z9printInfov+0x1c4>)
 80a08b4:	a802      	add	r0, sp, #8
 80a08b6:	f7ff fe7d 	bl	80a05b4 <_ZN5spark10JSONWriter4nameEPKc>
 80a08ba:	4680      	mov	r8, r0
 80a08bc:	6838      	ldr	r0, [r7, #0]
 80a08be:	f001 febd 	bl	80a263c <__aeabi_f2d>
 80a08c2:	4602      	mov	r2, r0
 80a08c4:	460b      	mov	r3, r1
 80a08c6:	4640      	mov	r0, r8
 80a08c8:	f000 fbd4 	bl	80a1074 <_ZN5spark10JSONWriter5valueEd>
  writer.name("pressure").value(pascals / 100);
 80a08cc:	4920      	ldr	r1, [pc, #128]	; (80a0950 <_Z9printInfov+0x1c8>)
 80a08ce:	a802      	add	r0, sp, #8
 80a08d0:	f7ff fe70 	bl	80a05b4 <_ZN5spark10JSONWriter4nameEPKc>
 80a08d4:	4918      	ldr	r1, [pc, #96]	; (80a0938 <_Z9printInfov+0x1b0>)
 80a08d6:	4607      	mov	r7, r0
 80a08d8:	6830      	ldr	r0, [r6, #0]
 80a08da:	f002 fc0d 	bl	80a30f8 <__aeabi_fdiv>
 80a08de:	f001 fead 	bl	80a263c <__aeabi_f2d>
 80a08e2:	4602      	mov	r2, r0
 80a08e4:	460b      	mov	r3, r1
 80a08e6:	4638      	mov	r0, r7
 80a08e8:	f000 fbc4 	bl	80a1074 <_ZN5spark10JSONWriter5valueEd>
  writer.endObject();
 80a08ec:	a802      	add	r0, sp, #8
 80a08ee:	f000 fb9f 	bl	80a1030 <_ZN5spark10JSONWriter9endObjectEv>
  Serial.printf("%s", buf);
 80a08f2:	f001 fa1f 	bl	80a1d34 <_Z16_fetch_usbserialv>
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a08f6:	4623      	mov	r3, r4
 80a08f8:	4a16      	ldr	r2, [pc, #88]	; (80a0954 <_Z9printInfov+0x1cc>)
 80a08fa:	4629      	mov	r1, r5
 80a08fc:	f000 fddc 	bl	80a14b8 <_ZN5Print11printf_implEbPKcz>
  send_data(buf);
 80a0900:	4620      	mov	r0, r4
 80a0902:	f7ff fee3 	bl	80a06cc <_Z9send_dataPc>
}
 80a0906:	b020      	add	sp, #128	; 0x80
 80a0908:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a090c:	f3af 8000 	nop.w
 80a0910:	c100e6b0 	.word	0xc100e6b0
 80a0914:	3f9e3d1c 	.word	0x3f9e3d1c
 80a0918:	080a33dc 	.word	0x080a33dc
 80a091c:	080a33f3 	.word	0x080a33f3
 80a0920:	080a33e0 	.word	0x080a33e0
 80a0924:	20000080 	.word	0x20000080
 80a0928:	080a33ea 	.word	0x080a33ea
 80a092c:	080a33ee 	.word	0x080a33ee
 80a0930:	080a33f9 	.word	0x080a33f9
 80a0934:	200000a0 	.word	0x200000a0
 80a0938:	42c80000 	.word	0x42c80000
 80a093c:	080a3403 	.word	0x080a3403
 80a0940:	080a3488 	.word	0x080a3488
 80a0944:	080a3417 	.word	0x080a3417
 80a0948:	080a3409 	.word	0x080a3409
 80a094c:	080a3412 	.word	0x080a3412
 80a0950:	080a341c 	.word	0x080a341c
 80a0954:	080a3425 	.word	0x080a3425
 80a0958:	20000074 	.word	0x20000074
 80a095c:	200000a4 	.word	0x200000a4

080a0960 <loop>:

  sensor.enableEventFlags(); //Necessary register calls to enble temp, baro and alt
}
//---------------------------------------------------------------
void loop()
{
 80a0960:	b510      	push	{r4, lr}
  //Get readings from all sensors
  getWeather();
 80a0962:	f7ff fe91 	bl	80a0688 <_Z10getWeatherv>

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a0966:	f000 f843 	bl	80a09f0 <HAL_Timer_Get_Milli_Seconds>

  // This math looks at the current time vs the last time a publish happened
  if (millis() - lastPrint > 5000) //Publishes every 5000 milliseconds, or 5 seconds
 80a096a:	4c07      	ldr	r4, [pc, #28]	; (80a0988 <loop+0x28>)
 80a096c:	6823      	ldr	r3, [r4, #0]
 80a096e:	1ac0      	subs	r0, r0, r3
 80a0970:	f241 3388 	movw	r3, #5000	; 0x1388
 80a0974:	4298      	cmp	r0, r3
 80a0976:	d906      	bls.n	80a0986 <loop+0x26>
 80a0978:	f000 f83a 	bl	80a09f0 <HAL_Timer_Get_Milli_Seconds>
  {
    // Record when you published
    lastPrint = millis();
 80a097c:	6020      	str	r0, [r4, #0]

    // Use the printInfo() function to print data out to Serial
    printInfo();
  }
}
 80a097e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  {
    // Record when you published
    lastPrint = millis();

    // Use the printInfo() function to print data out to Serial
    printInfo();
 80a0982:	f7ff bf01 	b.w	80a0788 <_Z9printInfov>
 80a0986:	bd10      	pop	{r4, pc}
 80a0988:	2000007c 	.word	0x2000007c

080a098c <_GLOBAL__sub_I_client>:
  }
  else
  {
    Serial.println("Unable To Connect");
  }
}
 80a098c:	b538      	push	{r3, r4, r5, lr}
  Distributed as-is; no warranty is given.
*******************************************************************************/
#include "SparkFun_Photon_Weather_Shield_Library.h"
#include <string>

TCPClient client;
 80a098e:	4c0d      	ldr	r4, [pc, #52]	; (80a09c4 <_GLOBAL__sub_I_client+0x38>)
 80a0990:	f000 f836 	bl	80a0a00 <HAL_Pin_Map>
 80a0994:	4d0c      	ldr	r5, [pc, #48]	; (80a09c8 <_GLOBAL__sub_I_client+0x3c>)
 80a0996:	4620      	mov	r0, r4
 80a0998:	f001 f87c 	bl	80a1a94 <_ZN9TCPClientC1Ev>
 80a099c:	4620      	mov	r0, r4
byte server[] = {192, 168, 0, 28};
byte dataBuffer[1024];

String receivedData;
 80a099e:	4c0b      	ldr	r4, [pc, #44]	; (80a09cc <_GLOBAL__sub_I_client+0x40>)
  Distributed as-is; no warranty is given.
*******************************************************************************/
#include "SparkFun_Photon_Weather_Shield_Library.h"
#include <string>

TCPClient client;
 80a09a0:	462a      	mov	r2, r5
 80a09a2:	490b      	ldr	r1, [pc, #44]	; (80a09d0 <_GLOBAL__sub_I_client+0x44>)
 80a09a4:	f001 fb7c 	bl	80a20a0 <__aeabi_atexit>
byte server[] = {192, 168, 0, 28};
byte dataBuffer[1024];

String receivedData;
 80a09a8:	490a      	ldr	r1, [pc, #40]	; (80a09d4 <_GLOBAL__sub_I_client+0x48>)
 80a09aa:	4620      	mov	r0, r4
 80a09ac:	f000 fe19 	bl	80a15e2 <_ZN6StringC1EPK19__FlashStringHelper>
 80a09b0:	462a      	mov	r2, r5
 80a09b2:	4620      	mov	r0, r4
 80a09b4:	4908      	ldr	r1, [pc, #32]	; (80a09d8 <_GLOBAL__sub_I_client+0x4c>)
 80a09b6:	f001 fb73 	bl	80a20a0 <__aeabi_atexit>
  }
  else
  {
    Serial.println("Unable To Connect");
  }
}
 80a09ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
float baroTemp = 0;

long lastPrint = 0;

//Create Instance of HTU21D or SI7021 temp and humidity sensor and MPL3115A2 barometric sensor
Weather sensor;
 80a09be:	4807      	ldr	r0, [pc, #28]	; (80a09dc <_GLOBAL__sub_I_client+0x50>)
 80a09c0:	f7ff bb7d 	b.w	80a00be <_ZN7WeatherC1Ev>
 80a09c4:	20000084 	.word	0x20000084
 80a09c8:	20000070 	.word	0x20000070
 80a09cc:	200000a8 	.word	0x200000a8
 80a09d0:	080a056d 	.word	0x080a056d
 80a09d4:	080a3562 	.word	0x080a3562
 80a09d8:	080a1555 	.word	0x080a1555
 80a09dc:	20000078 	.word	0x20000078

080a09e0 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a09e0:	b508      	push	{r3, lr}
 80a09e2:	4b02      	ldr	r3, [pc, #8]	; (80a09ec <HAL_RNG_GetRandomNumber+0xc>)
 80a09e4:	681b      	ldr	r3, [r3, #0]
 80a09e6:	685b      	ldr	r3, [r3, #4]
 80a09e8:	9301      	str	r3, [sp, #4]
 80a09ea:	bd08      	pop	{r3, pc}
 80a09ec:	0806019c 	.word	0x0806019c

080a09f0 <HAL_Timer_Get_Milli_Seconds>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a09f0:	b508      	push	{r3, lr}
 80a09f2:	4b02      	ldr	r3, [pc, #8]	; (80a09fc <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a09f4:	681b      	ldr	r3, [r3, #0]
 80a09f6:	695b      	ldr	r3, [r3, #20]
 80a09f8:	9301      	str	r3, [sp, #4]
 80a09fa:	bd08      	pop	{r3, pc}
 80a09fc:	0806019c 	.word	0x0806019c

080a0a00 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a0a00:	b508      	push	{r3, lr}
 80a0a02:	4b02      	ldr	r3, [pc, #8]	; (80a0a0c <HAL_Pin_Map+0xc>)
 80a0a04:	681b      	ldr	r3, [r3, #0]
 80a0a06:	681b      	ldr	r3, [r3, #0]
 80a0a08:	9301      	str	r3, [sp, #4]
 80a0a0a:	bd08      	pop	{r3, pc}
 80a0a0c:	080601b0 	.word	0x080601b0

080a0a10 <HAL_I2C_Begin>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
 80a0a10:	b508      	push	{r3, lr}
 80a0a12:	4b02      	ldr	r3, [pc, #8]	; (80a0a1c <HAL_I2C_Begin+0xc>)
 80a0a14:	681b      	ldr	r3, [r3, #0]
 80a0a16:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a0a18:	9301      	str	r3, [sp, #4]
 80a0a1a:	bd08      	pop	{r3, pc}
 80a0a1c:	080601ac 	.word	0x080601ac

080a0a20 <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, const HAL_I2C_Transmission_Config*))
 80a0a20:	b508      	push	{r3, lr}
 80a0a22:	4b02      	ldr	r3, [pc, #8]	; (80a0a2c <HAL_I2C_Begin_Transmission+0xc>)
 80a0a24:	681b      	ldr	r3, [r3, #0]
 80a0a26:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a0a28:	9301      	str	r3, [sp, #4]
 80a0a2a:	bd08      	pop	{r3, pc}
 80a0a2c:	080601ac 	.word	0x080601ac

080a0a30 <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
 80a0a30:	b508      	push	{r3, lr}
 80a0a32:	4b02      	ldr	r3, [pc, #8]	; (80a0a3c <HAL_I2C_End_Transmission+0xc>)
 80a0a34:	681b      	ldr	r3, [r3, #0]
 80a0a36:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a0a38:	9301      	str	r3, [sp, #4]
 80a0a3a:	bd08      	pop	{r3, pc}
 80a0a3c:	080601ac 	.word	0x080601ac

080a0a40 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a0a40:	b508      	push	{r3, lr}
 80a0a42:	4b02      	ldr	r3, [pc, #8]	; (80a0a4c <HAL_I2C_Write_Data+0xc>)
 80a0a44:	681b      	ldr	r3, [r3, #0]
 80a0a46:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a0a48:	9301      	str	r3, [sp, #4]
 80a0a4a:	bd08      	pop	{r3, pc}
 80a0a4c:	080601ac 	.word	0x080601ac

080a0a50 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a0a50:	b508      	push	{r3, lr}
 80a0a52:	4b02      	ldr	r3, [pc, #8]	; (80a0a5c <HAL_I2C_Available_Data+0xc>)
 80a0a54:	681b      	ldr	r3, [r3, #0]
 80a0a56:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a0a58:	9301      	str	r3, [sp, #4]
 80a0a5a:	bd08      	pop	{r3, pc}
 80a0a5c:	080601ac 	.word	0x080601ac

080a0a60 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a0a60:	b508      	push	{r3, lr}
 80a0a62:	4b02      	ldr	r3, [pc, #8]	; (80a0a6c <HAL_I2C_Read_Data+0xc>)
 80a0a64:	681b      	ldr	r3, [r3, #0]
 80a0a66:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a0a68:	9301      	str	r3, [sp, #4]
 80a0a6a:	bd08      	pop	{r3, pc}
 80a0a6c:	080601ac 	.word	0x080601ac

080a0a70 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a0a70:	b508      	push	{r3, lr}
 80a0a72:	4b02      	ldr	r3, [pc, #8]	; (80a0a7c <HAL_I2C_Peek_Data+0xc>)
 80a0a74:	681b      	ldr	r3, [r3, #0]
 80a0a76:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a0a78:	9301      	str	r3, [sp, #4]
 80a0a7a:	bd08      	pop	{r3, pc}
 80a0a7c:	080601ac 	.word	0x080601ac

080a0a80 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a0a80:	b508      	push	{r3, lr}
 80a0a82:	4b02      	ldr	r3, [pc, #8]	; (80a0a8c <HAL_I2C_Flush_Data+0xc>)
 80a0a84:	681b      	ldr	r3, [r3, #0]
 80a0a86:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a0a88:	9301      	str	r3, [sp, #4]
 80a0a8a:	bd08      	pop	{r3, pc}
 80a0a8c:	080601ac 	.word	0x080601ac

080a0a90 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, int(HAL_I2C_Interface, const HAL_I2C_Config*))
 80a0a90:	b508      	push	{r3, lr}
 80a0a92:	4b03      	ldr	r3, [pc, #12]	; (80a0aa0 <HAL_I2C_Init+0x10>)
 80a0a94:	681b      	ldr	r3, [r3, #0]
 80a0a96:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a0a9a:	9301      	str	r3, [sp, #4]
 80a0a9c:	bd08      	pop	{r3, pc}
 80a0a9e:	0000      	.short	0x0000
 80a0aa0:	080601ac 	.word	0x080601ac

080a0aa4 <HAL_I2C_Request_Data_Ex>:
DYNALIB_FN(BASE_IDX + 17, hal_i2c, HAL_I2C_Reset, uint8_t(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 18, hal_i2c, HAL_I2C_Acquire, int32_t(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 19, hal_i2c, HAL_I2C_Release, int32_t(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 20, hal_i2c, HAL_I2C_Request_Data_Ex, int32_t(HAL_I2C_Interface, const HAL_I2C_Transmission_Config*, void*))
 80a0aa4:	b508      	push	{r3, lr}
 80a0aa6:	4b03      	ldr	r3, [pc, #12]	; (80a0ab4 <HAL_I2C_Request_Data_Ex+0x10>)
 80a0aa8:	681b      	ldr	r3, [r3, #0]
 80a0aaa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a0aae:	9301      	str	r3, [sp, #4]
 80a0ab0:	bd08      	pop	{r3, pc}
 80a0ab2:	0000      	.short	0x0000
 80a0ab4:	080601ac 	.word	0x080601ac

080a0ab8 <socket_active_status>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, socket_active_status, uint8_t(sock_handle_t))
 80a0ab8:	b508      	push	{r3, lr}
 80a0aba:	4b02      	ldr	r3, [pc, #8]	; (80a0ac4 <socket_active_status+0xc>)
 80a0abc:	681b      	ldr	r3, [r3, #0]
 80a0abe:	681b      	ldr	r3, [r3, #0]
 80a0ac0:	9301      	str	r3, [sp, #4]
 80a0ac2:	bd08      	pop	{r3, pc}
 80a0ac4:	080601bc 	.word	0x080601bc

080a0ac8 <socket_handle_valid>:
DYNALIB_FN(1, hal_socket, socket_handle_valid, uint8_t(sock_handle_t))
 80a0ac8:	b508      	push	{r3, lr}
 80a0aca:	4b02      	ldr	r3, [pc, #8]	; (80a0ad4 <socket_handle_valid+0xc>)
 80a0acc:	681b      	ldr	r3, [r3, #0]
 80a0ace:	685b      	ldr	r3, [r3, #4]
 80a0ad0:	9301      	str	r3, [sp, #4]
 80a0ad2:	bd08      	pop	{r3, pc}
 80a0ad4:	080601bc 	.word	0x080601bc

080a0ad8 <socket_create>:
DYNALIB_FN(2, hal_socket, socket_create, sock_handle_t(uint8_t, uint8_t, uint8_t, uint16_t, network_interface_t))
 80a0ad8:	b508      	push	{r3, lr}
 80a0ada:	4b02      	ldr	r3, [pc, #8]	; (80a0ae4 <socket_create+0xc>)
 80a0adc:	681b      	ldr	r3, [r3, #0]
 80a0ade:	689b      	ldr	r3, [r3, #8]
 80a0ae0:	9301      	str	r3, [sp, #4]
 80a0ae2:	bd08      	pop	{r3, pc}
 80a0ae4:	080601bc 	.word	0x080601bc

080a0ae8 <socket_connect>:
DYNALIB_FN(3, hal_socket, socket_connect, int32_t(sock_handle_t, const sockaddr_t*, long))
 80a0ae8:	b508      	push	{r3, lr}
 80a0aea:	4b02      	ldr	r3, [pc, #8]	; (80a0af4 <socket_connect+0xc>)
 80a0aec:	681b      	ldr	r3, [r3, #0]
 80a0aee:	68db      	ldr	r3, [r3, #12]
 80a0af0:	9301      	str	r3, [sp, #4]
 80a0af2:	bd08      	pop	{r3, pc}
 80a0af4:	080601bc 	.word	0x080601bc

080a0af8 <socket_receive>:
DYNALIB_FN(4, hal_socket, socket_receive, sock_result_t(sock_handle_t, void*, socklen_t, system_tick_t))
 80a0af8:	b508      	push	{r3, lr}
 80a0afa:	4b02      	ldr	r3, [pc, #8]	; (80a0b04 <socket_receive+0xc>)
 80a0afc:	681b      	ldr	r3, [r3, #0]
 80a0afe:	691b      	ldr	r3, [r3, #16]
 80a0b00:	9301      	str	r3, [sp, #4]
 80a0b02:	bd08      	pop	{r3, pc}
 80a0b04:	080601bc 	.word	0x080601bc

080a0b08 <socket_close>:
DYNALIB_FN(5, hal_socket, socket_receivefrom, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*))
DYNALIB_FN(6, hal_socket, socket_send, sock_result_t(sock_handle_t, const void*, socklen_t))
DYNALIB_FN(7, hal_socket, socket_sendto, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, sockaddr_t*, socklen_t))
DYNALIB_FN(8, hal_socket, socket_close, sock_result_t(sock_handle_t))
 80a0b08:	b508      	push	{r3, lr}
 80a0b0a:	4b02      	ldr	r3, [pc, #8]	; (80a0b14 <socket_close+0xc>)
 80a0b0c:	681b      	ldr	r3, [r3, #0]
 80a0b0e:	6a1b      	ldr	r3, [r3, #32]
 80a0b10:	9301      	str	r3, [sp, #4]
 80a0b12:	bd08      	pop	{r3, pc}
 80a0b14:	080601bc 	.word	0x080601bc

080a0b18 <socket_handle_invalid>:
DYNALIB_FN(9, hal_socket, socket_reset_blocking_call, sock_result_t(void))
DYNALIB_FN(10, hal_socket, socket_create_tcp_server, sock_result_t(uint16_t, network_interface_t))
DYNALIB_FN(11, hal_socket, socket_accept, sock_result_t(sock_handle_t))
DYNALIB_FN(12, hal_socket, socket_handle_invalid, sock_handle_t(void))
 80a0b18:	b508      	push	{r3, lr}
 80a0b1a:	4b02      	ldr	r3, [pc, #8]	; (80a0b24 <socket_handle_invalid+0xc>)
 80a0b1c:	681b      	ldr	r3, [r3, #0]
 80a0b1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0b20:	9301      	str	r3, [sp, #4]
 80a0b22:	bd08      	pop	{r3, pc}
 80a0b24:	080601bc 	.word	0x080601bc

080a0b28 <socket_send_ex>:
DYNALIB_FN(13, hal_socket, socket_join_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(14, hal_socket, socket_leave_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(15, hal_socket, socket_peer, sock_result_t(sock_handle_t, sock_peer_t*, void*))
DYNALIB_FN(16, hal_socket, socket_shutdown, sock_result_t(sock_handle_t, int))
DYNALIB_FN(17, hal_socket, socket_send_ex, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, system_tick_t, void*))
 80a0b28:	b508      	push	{r3, lr}
 80a0b2a:	4b02      	ldr	r3, [pc, #8]	; (80a0b34 <socket_send_ex+0xc>)
 80a0b2c:	681b      	ldr	r3, [r3, #0]
 80a0b2e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a0b30:	9301      	str	r3, [sp, #4]
 80a0b32:	bd08      	pop	{r3, pc}
 80a0b34:	080601bc 	.word	0x080601bc

080a0b38 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a0b38:	b508      	push	{r3, lr}
 80a0b3a:	4b02      	ldr	r3, [pc, #8]	; (80a0b44 <HAL_USART_Init+0xc>)
 80a0b3c:	681b      	ldr	r3, [r3, #0]
 80a0b3e:	699b      	ldr	r3, [r3, #24]
 80a0b40:	9301      	str	r3, [sp, #4]
 80a0b42:	bd08      	pop	{r3, pc}
 80a0b44:	080601c4 	.word	0x080601c4

080a0b48 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0b48:	b508      	push	{r3, lr}
 80a0b4a:	4b02      	ldr	r3, [pc, #8]	; (80a0b54 <HAL_USART_Write_Data+0xc>)
 80a0b4c:	681b      	ldr	r3, [r3, #0]
 80a0b4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0b50:	9301      	str	r3, [sp, #4]
 80a0b52:	bd08      	pop	{r3, pc}
 80a0b54:	080601c4 	.word	0x080601c4

080a0b58 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0b58:	b508      	push	{r3, lr}
 80a0b5a:	4b02      	ldr	r3, [pc, #8]	; (80a0b64 <HAL_USART_Available_Data+0xc>)
 80a0b5c:	681b      	ldr	r3, [r3, #0]
 80a0b5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0b60:	9301      	str	r3, [sp, #4]
 80a0b62:	bd08      	pop	{r3, pc}
 80a0b64:	080601c4 	.word	0x080601c4

080a0b68 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a0b68:	b508      	push	{r3, lr}
 80a0b6a:	4b02      	ldr	r3, [pc, #8]	; (80a0b74 <HAL_USART_Read_Data+0xc>)
 80a0b6c:	681b      	ldr	r3, [r3, #0]
 80a0b6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0b70:	9301      	str	r3, [sp, #4]
 80a0b72:	bd08      	pop	{r3, pc}
 80a0b74:	080601c4 	.word	0x080601c4

080a0b78 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a0b78:	b508      	push	{r3, lr}
 80a0b7a:	4b02      	ldr	r3, [pc, #8]	; (80a0b84 <HAL_USART_Peek_Data+0xc>)
 80a0b7c:	681b      	ldr	r3, [r3, #0]
 80a0b7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0b80:	9301      	str	r3, [sp, #4]
 80a0b82:	bd08      	pop	{r3, pc}
 80a0b84:	080601c4 	.word	0x080601c4

080a0b88 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a0b88:	b508      	push	{r3, lr}
 80a0b8a:	4b02      	ldr	r3, [pc, #8]	; (80a0b94 <HAL_USART_Flush_Data+0xc>)
 80a0b8c:	681b      	ldr	r3, [r3, #0]
 80a0b8e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0b90:	9301      	str	r3, [sp, #4]
 80a0b92:	bd08      	pop	{r3, pc}
 80a0b94:	080601c4 	.word	0x080601c4

080a0b98 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a0b98:	b508      	push	{r3, lr}
 80a0b9a:	4b02      	ldr	r3, [pc, #8]	; (80a0ba4 <HAL_USART_Available_Data_For_Write+0xc>)
 80a0b9c:	681b      	ldr	r3, [r3, #0]
 80a0b9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a0ba0:	9301      	str	r3, [sp, #4]
 80a0ba2:	bd08      	pop	{r3, pc}
 80a0ba4:	080601c4 	.word	0x080601c4

080a0ba8 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a0ba8:	b508      	push	{r3, lr}
 80a0baa:	4b02      	ldr	r3, [pc, #8]	; (80a0bb4 <HAL_USB_USART_Init+0xc>)
 80a0bac:	681b      	ldr	r3, [r3, #0]
 80a0bae:	681b      	ldr	r3, [r3, #0]
 80a0bb0:	9301      	str	r3, [sp, #4]
 80a0bb2:	bd08      	pop	{r3, pc}
 80a0bb4:	080601d8 	.word	0x080601d8

080a0bb8 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a0bb8:	b508      	push	{r3, lr}
 80a0bba:	4b02      	ldr	r3, [pc, #8]	; (80a0bc4 <HAL_USB_USART_Begin+0xc>)
 80a0bbc:	681b      	ldr	r3, [r3, #0]
 80a0bbe:	685b      	ldr	r3, [r3, #4]
 80a0bc0:	9301      	str	r3, [sp, #4]
 80a0bc2:	bd08      	pop	{r3, pc}
 80a0bc4:	080601d8 	.word	0x080601d8

080a0bc8 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a0bc8:	b508      	push	{r3, lr}
 80a0bca:	4b02      	ldr	r3, [pc, #8]	; (80a0bd4 <HAL_USB_USART_Available_Data+0xc>)
 80a0bcc:	681b      	ldr	r3, [r3, #0]
 80a0bce:	691b      	ldr	r3, [r3, #16]
 80a0bd0:	9301      	str	r3, [sp, #4]
 80a0bd2:	bd08      	pop	{r3, pc}
 80a0bd4:	080601d8 	.word	0x080601d8

080a0bd8 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a0bd8:	b508      	push	{r3, lr}
 80a0bda:	4b02      	ldr	r3, [pc, #8]	; (80a0be4 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a0bdc:	681b      	ldr	r3, [r3, #0]
 80a0bde:	695b      	ldr	r3, [r3, #20]
 80a0be0:	9301      	str	r3, [sp, #4]
 80a0be2:	bd08      	pop	{r3, pc}
 80a0be4:	080601d8 	.word	0x080601d8

080a0be8 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a0be8:	b508      	push	{r3, lr}
 80a0bea:	4b02      	ldr	r3, [pc, #8]	; (80a0bf4 <HAL_USB_USART_Receive_Data+0xc>)
 80a0bec:	681b      	ldr	r3, [r3, #0]
 80a0bee:	699b      	ldr	r3, [r3, #24]
 80a0bf0:	9301      	str	r3, [sp, #4]
 80a0bf2:	bd08      	pop	{r3, pc}
 80a0bf4:	080601d8 	.word	0x080601d8

080a0bf8 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a0bf8:	b508      	push	{r3, lr}
 80a0bfa:	4b02      	ldr	r3, [pc, #8]	; (80a0c04 <HAL_USB_USART_Send_Data+0xc>)
 80a0bfc:	681b      	ldr	r3, [r3, #0]
 80a0bfe:	69db      	ldr	r3, [r3, #28]
 80a0c00:	9301      	str	r3, [sp, #4]
 80a0c02:	bd08      	pop	{r3, pc}
 80a0c04:	080601d8 	.word	0x080601d8

080a0c08 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a0c08:	b508      	push	{r3, lr}
 80a0c0a:	4b02      	ldr	r3, [pc, #8]	; (80a0c14 <HAL_USB_USART_Flush_Data+0xc>)
 80a0c0c:	681b      	ldr	r3, [r3, #0]
 80a0c0e:	6a1b      	ldr	r3, [r3, #32]
 80a0c10:	9301      	str	r3, [sp, #4]
 80a0c12:	bd08      	pop	{r3, pc}
 80a0c14:	080601d8 	.word	0x080601d8

080a0c18 <HAL_NET_SetNetWatchDog>:

DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
 80a0c18:	b508      	push	{r3, lr}
 80a0c1a:	4b02      	ldr	r3, [pc, #8]	; (80a0c24 <HAL_NET_SetNetWatchDog+0xc>)
 80a0c1c:	681b      	ldr	r3, [r3, #0]
 80a0c1e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a0c20:	9301      	str	r3, [sp, #4]
 80a0c22:	bd08      	pop	{r3, pc}
 80a0c24:	080601c0 	.word	0x080601c0

080a0c28 <inet_gethostbyname>:
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a0c28:	b508      	push	{r3, lr}
 80a0c2a:	4b02      	ldr	r3, [pc, #8]	; (80a0c34 <inet_gethostbyname+0xc>)
 80a0c2c:	681b      	ldr	r3, [r3, #0]
 80a0c2e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a0c30:	9301      	str	r3, [sp, #4]
 80a0c32:	bd08      	pop	{r3, pc}
 80a0c34:	080601c0 	.word	0x080601c0

080a0c38 <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
 80a0c38:	b508      	push	{r3, lr}
 80a0c3a:	4b02      	ldr	r3, [pc, #8]	; (80a0c44 <log_message+0xc>)
 80a0c3c:	681b      	ldr	r3, [r3, #0]
 80a0c3e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80a0c40:	9301      	str	r3, [sp, #4]
 80a0c42:	bd08      	pop	{r3, pc}
 80a0c44:	080201a8 	.word	0x080201a8

080a0c48 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a0c48:	b508      	push	{r3, lr}
 80a0c4a:	4b02      	ldr	r3, [pc, #8]	; (80a0c54 <set_system_mode+0xc>)
 80a0c4c:	681b      	ldr	r3, [r3, #0]
 80a0c4e:	685b      	ldr	r3, [r3, #4]
 80a0c50:	9301      	str	r3, [sp, #4]
 80a0c52:	bd08      	pop	{r3, pc}
 80a0c54:	080601a4 	.word	0x080601a4

080a0c58 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a0c58:	b508      	push	{r3, lr}
 80a0c5a:	4b02      	ldr	r3, [pc, #8]	; (80a0c64 <system_delay_ms+0xc>)
 80a0c5c:	681b      	ldr	r3, [r3, #0]
 80a0c5e:	695b      	ldr	r3, [r3, #20]
 80a0c60:	9301      	str	r3, [sp, #4]
 80a0c62:	bd08      	pop	{r3, pc}
 80a0c64:	080601a4 	.word	0x080601a4

080a0c68 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a0c68:	b508      	push	{r3, lr}
 80a0c6a:	4b03      	ldr	r3, [pc, #12]	; (80a0c78 <system_ctrl_set_app_request_handler+0x10>)
 80a0c6c:	681b      	ldr	r3, [r3, #0]
 80a0c6e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a0c72:	9301      	str	r3, [sp, #4]
 80a0c74:	bd08      	pop	{r3, pc}
 80a0c76:	0000      	.short	0x0000
 80a0c78:	080601a4 	.word	0x080601a4

080a0c7c <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a0c7c:	b508      	push	{r3, lr}
 80a0c7e:	4b03      	ldr	r3, [pc, #12]	; (80a0c8c <system_ctrl_set_result+0x10>)
 80a0c80:	681b      	ldr	r3, [r3, #0]
 80a0c82:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a0c86:	9301      	str	r3, [sp, #4]
 80a0c88:	bd08      	pop	{r3, pc}
 80a0c8a:	0000      	.short	0x0000
 80a0c8c:	080601a4 	.word	0x080601a4

080a0c90 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a0c90:	b508      	push	{r3, lr}
 80a0c92:	4b02      	ldr	r3, [pc, #8]	; (80a0c9c <spark_set_random_seed_from_cloud_handler+0xc>)
 80a0c94:	681b      	ldr	r3, [r3, #0]
 80a0c96:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a0c98:	9301      	str	r3, [sp, #4]
 80a0c9a:	bd08      	pop	{r3, pc}
 80a0c9c:	080601cc 	.word	0x080601cc

080a0ca0 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a0ca0:	b508      	push	{r3, lr}
 80a0ca2:	4b02      	ldr	r3, [pc, #8]	; (80a0cac <network_connect+0xc>)
 80a0ca4:	681b      	ldr	r3, [r3, #0]
 80a0ca6:	685b      	ldr	r3, [r3, #4]
 80a0ca8:	9301      	str	r3, [sp, #4]
 80a0caa:	bd08      	pop	{r3, pc}
 80a0cac:	080601c8 	.word	0x080601c8

080a0cb0 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a0cb0:	b508      	push	{r3, lr}
 80a0cb2:	4b02      	ldr	r3, [pc, #8]	; (80a0cbc <network_connecting+0xc>)
 80a0cb4:	681b      	ldr	r3, [r3, #0]
 80a0cb6:	689b      	ldr	r3, [r3, #8]
 80a0cb8:	9301      	str	r3, [sp, #4]
 80a0cba:	bd08      	pop	{r3, pc}
 80a0cbc:	080601c8 	.word	0x080601c8

080a0cc0 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a0cc0:	b508      	push	{r3, lr}
 80a0cc2:	4b02      	ldr	r3, [pc, #8]	; (80a0ccc <network_disconnect+0xc>)
 80a0cc4:	681b      	ldr	r3, [r3, #0]
 80a0cc6:	68db      	ldr	r3, [r3, #12]
 80a0cc8:	9301      	str	r3, [sp, #4]
 80a0cca:	bd08      	pop	{r3, pc}
 80a0ccc:	080601c8 	.word	0x080601c8

080a0cd0 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a0cd0:	b508      	push	{r3, lr}
 80a0cd2:	4b02      	ldr	r3, [pc, #8]	; (80a0cdc <network_ready+0xc>)
 80a0cd4:	681b      	ldr	r3, [r3, #0]
 80a0cd6:	691b      	ldr	r3, [r3, #16]
 80a0cd8:	9301      	str	r3, [sp, #4]
 80a0cda:	bd08      	pop	{r3, pc}
 80a0cdc:	080601c8 	.word	0x080601c8

080a0ce0 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a0ce0:	b508      	push	{r3, lr}
 80a0ce2:	4b02      	ldr	r3, [pc, #8]	; (80a0cec <network_on+0xc>)
 80a0ce4:	681b      	ldr	r3, [r3, #0]
 80a0ce6:	695b      	ldr	r3, [r3, #20]
 80a0ce8:	9301      	str	r3, [sp, #4]
 80a0cea:	bd08      	pop	{r3, pc}
 80a0cec:	080601c8 	.word	0x080601c8

080a0cf0 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a0cf0:	b508      	push	{r3, lr}
 80a0cf2:	4b02      	ldr	r3, [pc, #8]	; (80a0cfc <network_off+0xc>)
 80a0cf4:	681b      	ldr	r3, [r3, #0]
 80a0cf6:	699b      	ldr	r3, [r3, #24]
 80a0cf8:	9301      	str	r3, [sp, #4]
 80a0cfa:	bd08      	pop	{r3, pc}
 80a0cfc:	080601c8 	.word	0x080601c8

080a0d00 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a0d00:	b508      	push	{r3, lr}
 80a0d02:	4b02      	ldr	r3, [pc, #8]	; (80a0d0c <network_listen+0xc>)
 80a0d04:	681b      	ldr	r3, [r3, #0]
 80a0d06:	69db      	ldr	r3, [r3, #28]
 80a0d08:	9301      	str	r3, [sp, #4]
 80a0d0a:	bd08      	pop	{r3, pc}
 80a0d0c:	080601c8 	.word	0x080601c8

080a0d10 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a0d10:	b508      	push	{r3, lr}
 80a0d12:	4b02      	ldr	r3, [pc, #8]	; (80a0d1c <network_listening+0xc>)
 80a0d14:	681b      	ldr	r3, [r3, #0]
 80a0d16:	6a1b      	ldr	r3, [r3, #32]
 80a0d18:	9301      	str	r3, [sp, #4]
 80a0d1a:	bd08      	pop	{r3, pc}
 80a0d1c:	080601c8 	.word	0x080601c8

080a0d20 <network_set_credentials>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
 80a0d20:	b508      	push	{r3, lr}
 80a0d22:	4b02      	ldr	r3, [pc, #8]	; (80a0d2c <network_set_credentials+0xc>)
 80a0d24:	681b      	ldr	r3, [r3, #0]
 80a0d26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0d28:	9301      	str	r3, [sp, #4]
 80a0d2a:	bd08      	pop	{r3, pc}
 80a0d2c:	080601c8 	.word	0x080601c8

080a0d30 <network_set_listen_timeout>:
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a0d30:	b508      	push	{r3, lr}
 80a0d32:	4b02      	ldr	r3, [pc, #8]	; (80a0d3c <network_set_listen_timeout+0xc>)
 80a0d34:	681b      	ldr	r3, [r3, #0]
 80a0d36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0d38:	9301      	str	r3, [sp, #4]
 80a0d3a:	bd08      	pop	{r3, pc}
 80a0d3c:	080601c8 	.word	0x080601c8

080a0d40 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a0d40:	b508      	push	{r3, lr}
 80a0d42:	4b02      	ldr	r3, [pc, #8]	; (80a0d4c <network_get_listen_timeout+0xc>)
 80a0d44:	681b      	ldr	r3, [r3, #0]
 80a0d46:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0d48:	9301      	str	r3, [sp, #4]
 80a0d4a:	bd08      	pop	{r3, pc}
 80a0d4c:	080601c8 	.word	0x080601c8

080a0d50 <malloc>:
#include <assert.h>
#endif

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a0d50:	b508      	push	{r3, lr}
 80a0d52:	4b02      	ldr	r3, [pc, #8]	; (80a0d5c <malloc+0xc>)
 80a0d54:	681b      	ldr	r3, [r3, #0]
 80a0d56:	681b      	ldr	r3, [r3, #0]
 80a0d58:	9301      	str	r3, [sp, #4]
 80a0d5a:	bd08      	pop	{r3, pc}
 80a0d5c:	080601a0 	.word	0x080601a0

080a0d60 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a0d60:	b508      	push	{r3, lr}
 80a0d62:	4b02      	ldr	r3, [pc, #8]	; (80a0d6c <free+0xc>)
 80a0d64:	681b      	ldr	r3, [r3, #0]
 80a0d66:	685b      	ldr	r3, [r3, #4]
 80a0d68:	9301      	str	r3, [sp, #4]
 80a0d6a:	bd08      	pop	{r3, pc}
 80a0d6c:	080601a0 	.word	0x080601a0

080a0d70 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a0d70:	b508      	push	{r3, lr}
 80a0d72:	4b02      	ldr	r3, [pc, #8]	; (80a0d7c <realloc+0xc>)
 80a0d74:	681b      	ldr	r3, [r3, #0]
 80a0d76:	689b      	ldr	r3, [r3, #8]
 80a0d78:	9301      	str	r3, [sp, #4]
 80a0d7a:	bd08      	pop	{r3, pc}
 80a0d7c:	080601a0 	.word	0x080601a0

080a0d80 <sprintf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
 80a0d80:	b508      	push	{r3, lr}
 80a0d82:	4b02      	ldr	r3, [pc, #8]	; (80a0d8c <sprintf+0xc>)
 80a0d84:	681b      	ldr	r3, [r3, #0]
 80a0d86:	68db      	ldr	r3, [r3, #12]
 80a0d88:	9301      	str	r3, [sp, #4]
 80a0d8a:	bd08      	pop	{r3, pc}
 80a0d8c:	080601a0 	.word	0x080601a0

080a0d90 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a0d90:	b508      	push	{r3, lr}
 80a0d92:	4b02      	ldr	r3, [pc, #8]	; (80a0d9c <vsnprintf+0xc>)
 80a0d94:	681b      	ldr	r3, [r3, #0]
 80a0d96:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0d98:	9301      	str	r3, [sp, #4]
 80a0d9a:	bd08      	pop	{r3, pc}
 80a0d9c:	080601a0 	.word	0x080601a0

080a0da0 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0da0:	2100      	movs	r1, #0
 80a0da2:	f7ff bf59 	b.w	80a0c58 <system_delay_ms>

080a0da6 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0da6:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a0da8:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0daa:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a0dac:	b113      	cbz	r3, 80a0db4 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0dae:	2203      	movs	r2, #3
 80a0db0:	4601      	mov	r1, r0
 80a0db2:	4798      	blx	r3
    }
 80a0db4:	4620      	mov	r0, r4
 80a0db6:	bd10      	pop	{r4, pc}

080a0db8 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& config);
  virtual ~TwoWire() {};
 80a0db8:	4770      	bx	lr

080a0dba <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a0dba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0dbc:	4606      	mov	r6, r0
 80a0dbe:	4615      	mov	r5, r2
 80a0dc0:	460c      	mov	r4, r1
 80a0dc2:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0dc4:	42bc      	cmp	r4, r7
 80a0dc6:	d006      	beq.n	80a0dd6 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a0dc8:	6833      	ldr	r3, [r6, #0]
 80a0dca:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a0dce:	689b      	ldr	r3, [r3, #8]
 80a0dd0:	4630      	mov	r0, r6
 80a0dd2:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0dd4:	e7f6      	b.n	80a0dc4 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a0dd6:	4628      	mov	r0, r5
 80a0dd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0dda <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a0dda:	2200      	movs	r2, #0
 80a0ddc:	7c00      	ldrb	r0, [r0, #16]
 80a0dde:	f7ff be2f 	b.w	80a0a40 <HAL_I2C_Write_Data>

080a0de2 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a0de2:	2100      	movs	r1, #0
 80a0de4:	7c00      	ldrb	r0, [r0, #16]
 80a0de6:	f7ff be33 	b.w	80a0a50 <HAL_I2C_Available_Data>

080a0dea <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a0dea:	2100      	movs	r1, #0
 80a0dec:	7c00      	ldrb	r0, [r0, #16]
 80a0dee:	f7ff be37 	b.w	80a0a60 <HAL_I2C_Read_Data>

080a0df2 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0df2:	2100      	movs	r1, #0
 80a0df4:	7c00      	ldrb	r0, [r0, #16]
 80a0df6:	f7ff be3b 	b.w	80a0a70 <HAL_I2C_Peek_Data>

080a0dfa <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a0dfa:	2100      	movs	r1, #0
 80a0dfc:	7c00      	ldrb	r0, [r0, #16]
 80a0dfe:	f7ff be3f 	b.w	80a0a80 <HAL_I2C_Flush_Data>

080a0e02 <_ZN7TwoWireD0Ev>:
 80a0e02:	b510      	push	{r4, lr}
 80a0e04:	4604      	mov	r4, r0
 80a0e06:	2114      	movs	r1, #20
 80a0e08:	f001 f94f 	bl	80a20aa <_ZdlPvj>
 80a0e0c:	4620      	mov	r0, r4
 80a0e0e:	bd10      	pop	{r4, pc}

080a0e10 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
 80a0e10:	b510      	push	{r4, lr}
 80a0e12:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0e14:	2300      	movs	r3, #0
 80a0e16:	6063      	str	r3, [r4, #4]
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0e18:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a0e1c:	60a3      	str	r3, [r4, #8]
 80a0e1e:	4b04      	ldr	r3, [pc, #16]	; (80a0e30 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config+0x20>)
{
  _i2c = i2c;
 80a0e20:	7421      	strb	r1, [r4, #16]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c, const HAL_I2C_Config& conf)
 80a0e22:	4608      	mov	r0, r1
 80a0e24:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, &conf);
 80a0e26:	4611      	mov	r1, r2
 80a0e28:	f7ff fe32 	bl	80a0a90 <HAL_I2C_Init>
}
 80a0e2c:	4620      	mov	r0, r4
 80a0e2e:	bd10      	pop	{r4, pc}
 80a0e30:	080a344c 	.word	0x080a344c

080a0e34 <_ZN7TwoWire5beginEv>:
  HAL_I2C_Stretch_Clock(_i2c, stretch, NULL);
}

void TwoWire::begin(void)
{
	HAL_I2C_Begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a0e34:	2300      	movs	r3, #0
 80a0e36:	461a      	mov	r2, r3
 80a0e38:	4619      	mov	r1, r3
 80a0e3a:	7c00      	ldrb	r0, [r0, #16]
 80a0e3c:	f7ff bde8 	b.w	80a0a10 <HAL_I2C_Begin>

080a0e40 <_ZN7TwoWire11requestFromERK16WireTransmission>:
size_t TwoWire::requestFrom(uint8_t address, size_t quantity)
{
  return requestFrom(address, quantity, (uint8_t)true);
}

size_t TwoWire::requestFrom(const WireTransmission& transfer) {
 80a0e40:	b570      	push	{r4, r5, r6, lr}
 80a0e42:	460c      	mov	r4, r1
 80a0e44:	4606      	mov	r6, r0
 80a0e46:	b086      	sub	sp, #24
      .address = address_,
      .reserved = {0},
      .quantity = (uint32_t)size_,
      .timeout_ms = timeout_,
      .flags = (uint32_t)(stop_ ? HAL_I2C_TRANSMISSION_FLAG_STOP : 0)
    };
 80a0e48:	2514      	movs	r5, #20
 80a0e4a:	462a      	mov	r2, r5
 80a0e4c:	2100      	movs	r1, #0
 80a0e4e:	a801      	add	r0, sp, #4
 80a0e50:	f002 fa07 	bl	80a3262 <memset>
 80a0e54:	7823      	ldrb	r3, [r4, #0]
  auto conf = transfer.halConfig();
  return HAL_I2C_Request_Data_Ex(_i2c, &conf, nullptr);
 80a0e56:	2200      	movs	r2, #0
 80a0e58:	f88d 3008 	strb.w	r3, [sp, #8]
 80a0e5c:	6863      	ldr	r3, [r4, #4]
 80a0e5e:	a901      	add	r1, sp, #4
 80a0e60:	9303      	str	r3, [sp, #12]
 80a0e62:	68e3      	ldr	r3, [r4, #12]
 80a0e64:	7c30      	ldrb	r0, [r6, #16]
 80a0e66:	9304      	str	r3, [sp, #16]
 80a0e68:	7a23      	ldrb	r3, [r4, #8]
 80a0e6a:	f8ad 5004 	strh.w	r5, [sp, #4]
 80a0e6e:	9305      	str	r3, [sp, #20]
 80a0e70:	f7ff fe18 	bl	80a0aa4 <HAL_I2C_Request_Data_Ex>
}
 80a0e74:	b006      	add	sp, #24
 80a0e76:	bd70      	pop	{r4, r5, r6, pc}

080a0e78 <_ZN7TwoWire11requestFromEhjh>:
{
	HAL_I2C_End(_i2c, NULL);
}

size_t TwoWire::requestFrom(uint8_t address, size_t quantity, uint8_t sendStop)
{
 80a0e78:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  WireTransmission& timeout(std::chrono::milliseconds ms) {
    return timeout((system_tick_t)ms.count());
  }

  WireTransmission& stop(bool stop) {
    stop_ = stop;
 80a0e7a:	3300      	adds	r3, #0
public:
  WireTransmission(uint8_t address)
      : address_{address},
        size_{0},
        stop_{true},
        timeout_{HAL_I2C_DEFAULT_TIMEOUT_MS} {
 80a0e7c:	f88d 1000 	strb.w	r1, [sp]
 80a0e80:	f04f 0164 	mov.w	r1, #100	; 0x64
 80a0e84:	9103      	str	r1, [sp, #12]
  WireTransmission& timeout(std::chrono::milliseconds ms) {
    return timeout((system_tick_t)ms.count());
  }

  WireTransmission& stop(bool stop) {
    stop_ = stop;
 80a0e86:	bf18      	it	ne
 80a0e88:	2301      	movne	r3, #1
  return requestFrom(WireTransmission(address).quantity(quantity).stop(sendStop));
 80a0e8a:	4669      	mov	r1, sp
  }

  WireTransmission() = delete;

  WireTransmission& quantity(size_t size) {
    size_ = size;
 80a0e8c:	9201      	str	r2, [sp, #4]
  WireTransmission& timeout(std::chrono::milliseconds ms) {
    return timeout((system_tick_t)ms.count());
  }

  WireTransmission& stop(bool stop) {
    stop_ = stop;
 80a0e8e:	f88d 3008 	strb.w	r3, [sp, #8]
 80a0e92:	f7ff ffd5 	bl	80a0e40 <_ZN7TwoWire11requestFromERK16WireTransmission>
}
 80a0e96:	b005      	add	sp, #20
 80a0e98:	f85d fb04 	ldr.w	pc, [sp], #4

080a0e9c <_ZN7TwoWire11requestFromEhj>:

size_t TwoWire::requestFrom(uint8_t address, size_t quantity)
{
  return requestFrom(address, quantity, (uint8_t)true);
 80a0e9c:	2301      	movs	r3, #1
 80a0e9e:	f7ff bfeb 	b.w	80a0e78 <_ZN7TwoWire11requestFromEhjh>

080a0ea2 <_ZN7TwoWire17beginTransmissionEh>:
  return HAL_I2C_Request_Data_Ex(_i2c, &conf, nullptr);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
 80a0ea2:	2200      	movs	r2, #0
 80a0ea4:	7c00      	ldrb	r0, [r0, #16]
 80a0ea6:	f7ff bdbb 	b.w	80a0a20 <HAL_I2C_Begin_Transmission>

080a0eaa <_ZN7TwoWire17beginTransmissionEi>:
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
 80a0eaa:	b2c9      	uxtb	r1, r1
 80a0eac:	f7ff bff9 	b.w	80a0ea2 <_ZN7TwoWire17beginTransmissionEh>

080a0eb0 <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
 80a0eb0:	2200      	movs	r2, #0
 80a0eb2:	7c00      	ldrb	r0, [r0, #16]
 80a0eb4:	f7ff bdbc 	b.w	80a0a30 <HAL_I2C_End_Transmission>

080a0eb8 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
 80a0eb8:	2101      	movs	r1, #1
 80a0eba:	f7ff bff9 	b.w	80a0eb0 <_ZN7TwoWire15endTransmissionEh>

080a0ebe <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a0ebe:	4770      	bx	lr

080a0ec0 <_ZN9IPAddressD0Ev>:
 80a0ec0:	b510      	push	{r4, lr}
 80a0ec2:	4604      	mov	r4, r0
 80a0ec4:	2118      	movs	r1, #24
 80a0ec6:	f001 f8f0 	bl	80a20aa <_ZdlPvj>
 80a0eca:	4620      	mov	r0, r4
 80a0ecc:	bd10      	pop	{r4, pc}

080a0ece <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a0ece:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0ed0:	460f      	mov	r7, r1
 80a0ed2:	f100 0608 	add.w	r6, r0, #8
 80a0ed6:	1d05      	adds	r5, r0, #4
 80a0ed8:	2400      	movs	r4, #0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
 80a0eda:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a0ede:	220a      	movs	r2, #10
 80a0ee0:	4638      	mov	r0, r7
 80a0ee2:	f000 f9fc 	bl	80a12de <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0ee6:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0ee8:	4404      	add	r4, r0
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0eea:	d007      	beq.n	80a0efc <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a0eec:	2c00      	cmp	r4, #0
 80a0eee:	d0f4      	beq.n	80a0eda <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0ef0:	212e      	movs	r1, #46	; 0x2e
 80a0ef2:	4638      	mov	r0, r7
 80a0ef4:	f000 f9da 	bl	80a12ac <_ZN5Print5printEc>
 80a0ef8:	4404      	add	r4, r0
 80a0efa:	e7ee      	b.n	80a0eda <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a0efc:	4620      	mov	r0, r4
 80a0efe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0f00 <_ZN9IPAddressC1Ev>:

#if HAL_USE_INET_HAL_POSIX
#include <arpa/inet.h>
#endif // HAL_USE_INET_HAL_POSIX

IPAddress::IPAddress()
 80a0f00:	b510      	push	{r4, lr}
 80a0f02:	4604      	mov	r4, r0
 80a0f04:	4b04      	ldr	r3, [pc, #16]	; (80a0f18 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a0f06:	2211      	movs	r2, #17
 80a0f08:	f840 3b04 	str.w	r3, [r0], #4
 80a0f0c:	2100      	movs	r1, #0
 80a0f0e:	f002 f9a8 	bl	80a3262 <memset>
{
    clear();
}
 80a0f12:	4620      	mov	r0, r4
 80a0f14:	bd10      	pop	{r4, pc}
 80a0f16:	bf00      	nop
 80a0f18:	080a3474 	.word	0x080a3474

080a0f1c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
 80a0f1c:	4603      	mov	r3, r0
 80a0f1e:	4a07      	ldr	r2, [pc, #28]	; (80a0f3c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a0f20:	b510      	push	{r4, lr}
 80a0f22:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
 80a0f26:	f101 0210 	add.w	r2, r1, #16
 80a0f2a:	f851 4b04 	ldr.w	r4, [r1], #4
 80a0f2e:	4291      	cmp	r1, r2
 80a0f30:	f843 4b04 	str.w	r4, [r3], #4
 80a0f34:	d1f9      	bne.n	80a0f2a <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a0f36:	780a      	ldrb	r2, [r1, #0]
 80a0f38:	701a      	strb	r2, [r3, #0]
}
 80a0f3a:	bd10      	pop	{r4, pc}
 80a0f3c:	080a3474 	.word	0x080a3474

080a0f40 <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a0f40:	4a02      	ldr	r2, [pc, #8]	; (80a0f4c <_ZN9IPAddressC1Em+0xc>)
    return *this;
}

IPAddress& IPAddress::operator=(uint32_t ipv4)
{
    address.ipv4 = ipv4;
 80a0f42:	6041      	str	r1, [r0, #4]
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
}

IPAddress::IPAddress(uint32_t address)
 80a0f44:	6002      	str	r2, [r0, #0]
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a0f46:	2204      	movs	r2, #4
 80a0f48:	7502      	strb	r2, [r0, #20]
{
    *this = address;
}
 80a0f4a:	4770      	bx	lr
 80a0f4c:	080a3474 	.word	0x080a3474

080a0f50 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a0f50:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a0f52:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a0f56:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a0f5a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a0f5e:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
 80a0f62:	2304      	movs	r3, #4
 80a0f64:	6041      	str	r1, [r0, #4]
 80a0f66:	7503      	strb	r3, [r0, #20]
 80a0f68:	bd10      	pop	{r4, pc}
	...

080a0f6c <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a0f6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0f6e:	4d04      	ldr	r5, [pc, #16]	; (80a0f80 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a0f70:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a0f72:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a0f76:	9500      	str	r5, [sp, #0]
 80a0f78:	f7ff ffea 	bl	80a0f50 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a0f7c:	b003      	add	sp, #12
 80a0f7e:	bd30      	pop	{r4, r5, pc}
 80a0f80:	080a3474 	.word	0x080a3474

080a0f84 <_ZN9IPAddressaSEPKh>:
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
    setVersion(4);
}

IPAddress& IPAddress::operator=(const uint8_t* address)
{
 80a0f84:	b537      	push	{r0, r1, r2, r4, r5, lr}
    set_ipv4(address[0], address[1], address[2], address[3]);
 80a0f86:	780d      	ldrb	r5, [r1, #0]
 80a0f88:	788b      	ldrb	r3, [r1, #2]
 80a0f8a:	784a      	ldrb	r2, [r1, #1]
 80a0f8c:	78c9      	ldrb	r1, [r1, #3]
 80a0f8e:	9100      	str	r1, [sp, #0]
 80a0f90:	4629      	mov	r1, r5
 80a0f92:	f7ff ffdd 	bl	80a0f50 <_ZN9IPAddress8set_ipv4Ehhhh>
    return *this;
}
 80a0f96:	b003      	add	sp, #12
 80a0f98:	bd30      	pop	{r4, r5, pc}
	...

080a0f9c <_ZN9IPAddressC1EPKh>:
IPAddress::IPAddress(uint32_t address)
{
    *this = address;
}

IPAddress::IPAddress(const uint8_t* address)
 80a0f9c:	b510      	push	{r4, lr}
 80a0f9e:	4604      	mov	r4, r0
 80a0fa0:	4b02      	ldr	r3, [pc, #8]	; (80a0fac <_ZN9IPAddressC1EPKh+0x10>)
 80a0fa2:	6003      	str	r3, [r0, #0]
{
    *this = address;
 80a0fa4:	f7ff ffee 	bl	80a0f84 <_ZN9IPAddressaSEPKh>
}
 80a0fa8:	4620      	mov	r0, r4
 80a0faa:	bd10      	pop	{r4, pc}
 80a0fac:	080a3474 	.word	0x080a3474

080a0fb0 <_ZN5spark16JSONBufferWriterD1Ev>:

private:
    Print &strm_;
};

class JSONBufferWriter: public JSONWriter {
 80a0fb0:	4770      	bx	lr

080a0fb2 <_ZN5spark16JSONBufferWriterD0Ev>:
 80a0fb2:	b510      	push	{r4, lr}
 80a0fb4:	4604      	mov	r4, r0
 80a0fb6:	2114      	movs	r1, #20
 80a0fb8:	f001 f877 	bl	80a20aa <_ZdlPvj>
 80a0fbc:	4620      	mov	r0, r4
 80a0fbe:	bd10      	pop	{r4, pc}

080a0fc0 <_ZN5spark16JSONBufferWriter5writeEPKcj>:
    }
    write('"');
}

// spark::JSONBufferWriter
void spark::JSONBufferWriter::write(const char *data, size_t size) {
 80a0fc0:	b538      	push	{r3, r4, r5, lr}
 80a0fc2:	4615      	mov	r5, r2
    if (n_ < bufSize_) {
 80a0fc4:	6903      	ldr	r3, [r0, #16]
 80a0fc6:	68c2      	ldr	r2, [r0, #12]
    }
    write('"');
}

// spark::JSONBufferWriter
void spark::JSONBufferWriter::write(const char *data, size_t size) {
 80a0fc8:	4604      	mov	r4, r0
    if (n_ < bufSize_) {
 80a0fca:	4293      	cmp	r3, r2
 80a0fcc:	d207      	bcs.n	80a0fde <_ZN5spark16JSONBufferWriter5writeEPKcj+0x1e>
        memcpy(buf_ + n_, data, std::min(size, bufSize_ - n_));
 80a0fce:	1ad2      	subs	r2, r2, r3
 80a0fd0:	6880      	ldr	r0, [r0, #8]
 80a0fd2:	42aa      	cmp	r2, r5
 80a0fd4:	bf28      	it	cs
 80a0fd6:	462a      	movcs	r2, r5
 80a0fd8:	4418      	add	r0, r3
 80a0fda:	f002 f937 	bl	80a324c <memcpy>
    }
    n_ += size;
 80a0fde:	6923      	ldr	r3, [r4, #16]
 80a0fe0:	441d      	add	r5, r3
 80a0fe2:	6125      	str	r5, [r4, #16]
 80a0fe4:	bd38      	pop	{r3, r4, r5, pc}

080a0fe6 <_ZN5spark16JSONBufferWriter6printfEPKcz>:
}

void spark::JSONBufferWriter::printf(const char *fmt, ...) {
 80a0fe6:	b40e      	push	{r1, r2, r3}
 80a0fe8:	b517      	push	{r0, r1, r2, r4, lr}
 80a0fea:	4604      	mov	r4, r0
 80a0fec:	ab05      	add	r3, sp, #20
 80a0fee:	f853 2b04 	ldr.w	r2, [r3], #4
    va_list args;
    va_start(args, fmt);
    const int n = vsnprintf(buf_ + n_, (n_ < bufSize_) ? bufSize_ - n_ : 0, fmt, args);
 80a0ff2:	6901      	ldr	r1, [r0, #16]
    n_ += size;
}

void spark::JSONBufferWriter::printf(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
 80a0ff4:	9301      	str	r3, [sp, #4]
    const int n = vsnprintf(buf_ + n_, (n_ < bufSize_) ? bufSize_ - n_ : 0, fmt, args);
 80a0ff6:	68e3      	ldr	r3, [r4, #12]
 80a0ff8:	6880      	ldr	r0, [r0, #8]
 80a0ffa:	4299      	cmp	r1, r3
 80a0ffc:	4408      	add	r0, r1
 80a0ffe:	bf34      	ite	cc
 80a1000:	1a59      	subcc	r1, r3, r1
 80a1002:	2100      	movcs	r1, #0
 80a1004:	9b01      	ldr	r3, [sp, #4]
 80a1006:	f7ff fec3 	bl	80a0d90 <vsnprintf>
    va_end(args);
    n_ += n;
 80a100a:	6923      	ldr	r3, [r4, #16]
 80a100c:	4418      	add	r0, r3
 80a100e:	6120      	str	r0, [r4, #16]
}
 80a1010:	b003      	add	sp, #12
 80a1012:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1016:	b003      	add	sp, #12
 80a1018:	4770      	bx	lr

080a101a <_ZN5spark10JSONWriter5writeEc>:

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a101a:	b513      	push	{r0, r1, r4, lr}
    write(&c, 1);
 80a101c:	6802      	ldr	r2, [r0, #0]

inline spark::JSONWriter& spark::JSONWriter::value(const String &val) {
    return value(val.c_str(), val.length());
}

inline void spark::JSONWriter::write(char c) {
 80a101e:	ab02      	add	r3, sp, #8
 80a1020:	f803 1d01 	strb.w	r1, [r3, #-1]!
    write(&c, 1);
 80a1024:	6894      	ldr	r4, [r2, #8]
 80a1026:	4619      	mov	r1, r3
 80a1028:	2201      	movs	r2, #1
 80a102a:	47a0      	blx	r4
}
 80a102c:	b002      	add	sp, #8
 80a102e:	bd10      	pop	{r4, pc}

080a1030 <_ZN5spark10JSONWriter9endObjectEv>:
    write('{');
    state_ = BEGIN;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::endObject() {
 80a1030:	b510      	push	{r4, lr}
 80a1032:	4604      	mov	r4, r0
    write('}');
 80a1034:	217d      	movs	r1, #125	; 0x7d
 80a1036:	f7ff fff0 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
    state_ = NEXT;
 80a103a:	2301      	movs	r3, #1
 80a103c:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a103e:	4620      	mov	r0, r4
 80a1040:	bd10      	pop	{r4, pc}

080a1042 <_ZN5spark10JSONWriter14writeSeparatorEv>:
    } else if (n > 0) {
        write(buf, n);
    }
}

void spark::JSONWriter::writeSeparator() {
 80a1042:	b508      	push	{r3, lr}
    switch (state_) {
 80a1044:	7903      	ldrb	r3, [r0, #4]
 80a1046:	2b01      	cmp	r3, #1
 80a1048:	d002      	beq.n	80a1050 <_ZN5spark10JSONWriter14writeSeparatorEv+0xe>
 80a104a:	2b02      	cmp	r3, #2
 80a104c:	d002      	beq.n	80a1054 <_ZN5spark10JSONWriter14writeSeparatorEv+0x12>
 80a104e:	bd08      	pop	{r3, pc}
    case NEXT:
        write(',');
 80a1050:	212c      	movs	r1, #44	; 0x2c
 80a1052:	e000      	b.n	80a1056 <_ZN5spark10JSONWriter14writeSeparatorEv+0x14>
        break;
    case VALUE:
        write(':');
 80a1054:	213a      	movs	r1, #58	; 0x3a
 80a1056:	f7ff ffe0 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
 80a105a:	bd08      	pop	{r3, pc}

080a105c <_ZN5spark10JSONWriter11beginObjectEv>:
    write(']');
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::beginObject() {
 80a105c:	b510      	push	{r4, lr}
 80a105e:	4604      	mov	r4, r0
    writeSeparator();
 80a1060:	f7ff ffef 	bl	80a1042 <_ZN5spark10JSONWriter14writeSeparatorEv>
    write('{');
 80a1064:	4620      	mov	r0, r4
 80a1066:	217b      	movs	r1, #123	; 0x7b
 80a1068:	f7ff ffd7 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
    state_ = BEGIN;
 80a106c:	2300      	movs	r3, #0
 80a106e:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1070:	4620      	mov	r0, r4
 80a1072:	bd10      	pop	{r4, pc}

080a1074 <_ZN5spark10JSONWriter5valueEd>:
    printf("%.*lf", precision, val);
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::value(double val) {
 80a1074:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1076:	4604      	mov	r4, r0
 80a1078:	461f      	mov	r7, r3
 80a107a:	4616      	mov	r6, r2
    writeSeparator();
 80a107c:	f7ff ffe1 	bl	80a1042 <_ZN5spark10JSONWriter14writeSeparatorEv>
    printf("%g", val);
 80a1080:	6823      	ldr	r3, [r4, #0]
 80a1082:	4620      	mov	r0, r4
 80a1084:	68dd      	ldr	r5, [r3, #12]
 80a1086:	4632      	mov	r2, r6
 80a1088:	463b      	mov	r3, r7
 80a108a:	4903      	ldr	r1, [pc, #12]	; (80a1098 <_ZN5spark10JSONWriter5valueEd+0x24>)
 80a108c:	47a8      	blx	r5
    state_ = NEXT;
 80a108e:	2301      	movs	r3, #1
 80a1090:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a1092:	4620      	mov	r0, r4
 80a1094:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a1096:	bf00      	nop
 80a1098:	080a34b0 	.word	0x080a34b0

080a109c <_ZN5spark10JSONWriter12writeEscapedEPKcj>:
    default:
        break;
    }
}

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a109c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a109e:	460d      	mov	r5, r1
 80a10a0:	4617      	mov	r7, r2
    write('"');
 80a10a2:	2122      	movs	r1, #34	; 0x22
    default:
        break;
    }
}

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
 80a10a4:	4604      	mov	r4, r0
    write('"');
 80a10a6:	f7ff ffb8 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
 80a10aa:	462a      	mov	r2, r5
    const char* const end = str + size;
 80a10ac:	4629      	mov	r1, r5
 80a10ae:	442f      	add	r7, r5
    const char *s = str;
    while (s != end) {
 80a10b0:	42ba      	cmp	r2, r7
 80a10b2:	d038      	beq.n	80a1126 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x8a>
        const char c = *s;
 80a10b4:	4616      	mov	r6, r2
 80a10b6:	f816 5b01 	ldrb.w	r5, [r6], #1
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
 80a10ba:	2d22      	cmp	r5, #34	; 0x22
 80a10bc:	d003      	beq.n	80a10c6 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2a>
 80a10be:	2d5c      	cmp	r5, #92	; 0x5c
 80a10c0:	d001      	beq.n	80a10c6 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x2a>
 80a10c2:	2d1f      	cmp	r5, #31
 80a10c4:	d82d      	bhi.n	80a1122 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x86>
            write(str, s - str); // Write preceeding characters
 80a10c6:	6823      	ldr	r3, [r4, #0]
 80a10c8:	1a52      	subs	r2, r2, r1
 80a10ca:	689b      	ldr	r3, [r3, #8]
 80a10cc:	4620      	mov	r0, r4
 80a10ce:	4798      	blx	r3
            write('\\');
 80a10d0:	215c      	movs	r1, #92	; 0x5c
 80a10d2:	4620      	mov	r0, r4
 80a10d4:	f7ff ffa1 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
            switch (c) {
 80a10d8:	2d0c      	cmp	r5, #12
 80a10da:	d019      	beq.n	80a1110 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x74>
 80a10dc:	d807      	bhi.n	80a10ee <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x52>
 80a10de:	2d09      	cmp	r5, #9
 80a10e0:	d00f      	beq.n	80a1102 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x66>
 80a10e2:	2d0a      	cmp	r5, #10
 80a10e4:	d012      	beq.n	80a110c <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x70>
 80a10e6:	2d08      	cmp	r5, #8
 80a10e8:	d114      	bne.n	80a1114 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x78>
            case '"':
            case '\\':
                write(c);
                break;
            case 0x08: // Backspace
                write('b');
 80a10ea:	2162      	movs	r1, #98	; 0x62
 80a10ec:	e00a      	b.n	80a1104 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
    while (s != end) {
        const char c = *s;
        if (c == '"' || c == '\\' || (c >= 0 && c <= 0x1f)) {
            write(str, s - str); // Write preceeding characters
            write('\\');
            switch (c) {
 80a10ee:	2d22      	cmp	r5, #34	; 0x22
 80a10f0:	d005      	beq.n	80a10fe <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a10f2:	2d5c      	cmp	r5, #92	; 0x5c
 80a10f4:	d003      	beq.n	80a10fe <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x62>
 80a10f6:	2d0d      	cmp	r5, #13
 80a10f8:	d10c      	bne.n	80a1114 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x78>
                break;
            case 0x0c: // Form feed
                write('f');
                break;
            case 0x0d: // Carriage return
                write('r');
 80a10fa:	2172      	movs	r1, #114	; 0x72
 80a10fc:	e002      	b.n	80a1104 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
            write(str, s - str); // Write preceeding characters
            write('\\');
            switch (c) {
            case '"':
            case '\\':
                write(c);
 80a10fe:	4629      	mov	r1, r5
 80a1100:	e000      	b.n	80a1104 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
                break;
            case 0x08: // Backspace
                write('b');
                break;
            case 0x09: // Tab
                write('t');
 80a1102:	2174      	movs	r1, #116	; 0x74
            case '"':
            case '\\':
                write(c);
                break;
            case 0x08: // Backspace
                write('b');
 80a1104:	4620      	mov	r0, r4
 80a1106:	f7ff ff88 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
                break;
 80a110a:	e009      	b.n	80a1120 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x84>
            case 0x09: // Tab
                write('t');
                break;
            case 0x0a: // Line feed
                write('n');
 80a110c:	216e      	movs	r1, #110	; 0x6e
 80a110e:	e7f9      	b.n	80a1104 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
                break;
            case 0x0c: // Form feed
                write('f');
 80a1110:	2166      	movs	r1, #102	; 0x66
 80a1112:	e7f7      	b.n	80a1104 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x68>
            case 0x0d: // Carriage return
                write('r');
                break;
            default:
                // All other control characters are written in hex, e.g. "\u001f"
                printf("u%04x", (unsigned)c);
 80a1114:	6823      	ldr	r3, [r4, #0]
 80a1116:	462a      	mov	r2, r5
 80a1118:	68db      	ldr	r3, [r3, #12]
 80a111a:	4909      	ldr	r1, [pc, #36]	; (80a1140 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0xa4>)
 80a111c:	4620      	mov	r0, r4
 80a111e:	4798      	blx	r3
                break;
            }
            str = s + 1;
 80a1120:	4631      	mov	r1, r6

void spark::JSONWriter::writeEscaped(const char *str, size_t size) {
    write('"');
    const char* const end = str + size;
    const char *s = str;
    while (s != end) {
 80a1122:	4632      	mov	r2, r6
 80a1124:	e7c4      	b.n	80a10b0 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x14>
            }
            str = s + 1;
        }
        ++s;
    }
    if (s != str) {
 80a1126:	4291      	cmp	r1, r2
 80a1128:	d004      	beq.n	80a1134 <_ZN5spark10JSONWriter12writeEscapedEPKcj+0x98>
        write(str, s - str); // Write remaining characters
 80a112a:	6823      	ldr	r3, [r4, #0]
 80a112c:	1a52      	subs	r2, r2, r1
 80a112e:	689d      	ldr	r5, [r3, #8]
 80a1130:	4620      	mov	r0, r4
 80a1132:	47a8      	blx	r5
    }
    write('"');
 80a1134:	2122      	movs	r1, #34	; 0x22
 80a1136:	4620      	mov	r0, r4
 80a1138:	f7ff ff6f 	bl	80a101a <_ZN5spark10JSONWriter5writeEc>
 80a113c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a113e:	bf00      	nop
 80a1140:	080a34b8 	.word	0x080a34b8

080a1144 <_ZN5spark10JSONWriter4nameEPKcj>:
    write('}');
    state_ = NEXT;
    return *this;
}

spark::JSONWriter& spark::JSONWriter::name(const char *name, size_t size) {
 80a1144:	b570      	push	{r4, r5, r6, lr}
 80a1146:	4604      	mov	r4, r0
 80a1148:	460d      	mov	r5, r1
 80a114a:	4616      	mov	r6, r2
    writeSeparator();
 80a114c:	f7ff ff79 	bl	80a1042 <_ZN5spark10JSONWriter14writeSeparatorEv>
    writeEscaped(name, size);
 80a1150:	4620      	mov	r0, r4
 80a1152:	4632      	mov	r2, r6
 80a1154:	4629      	mov	r1, r5
 80a1156:	f7ff ffa1 	bl	80a109c <_ZN5spark10JSONWriter12writeEscapedEPKcj>
    state_ = VALUE;
 80a115a:	2302      	movs	r3, #2
 80a115c:	7123      	strb	r3, [r4, #4]
    return *this;
}
 80a115e:	4620      	mov	r0, r4
 80a1160:	bd70      	pop	{r4, r5, r6, pc}
	...

080a1164 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a1164:	4a01      	ldr	r2, [pc, #4]	; (80a116c <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a1166:	4b02      	ldr	r3, [pc, #8]	; (80a1170 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a1168:	601a      	str	r2, [r3, #0]
 80a116a:	4770      	bx	lr
 80a116c:	080a3534 	.word	0x080a3534
 80a1170:	200000b8 	.word	0x200000b8

080a1174 <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a1174:	2300      	movs	r3, #0
 80a1176:	461a      	mov	r2, r3
 80a1178:	6840      	ldr	r0, [r0, #4]
 80a117a:	f7ff bd91 	b.w	80a0ca0 <network_connect>

080a117e <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a117e:	2200      	movs	r2, #0
 80a1180:	2102      	movs	r1, #2
 80a1182:	6840      	ldr	r0, [r0, #4]
 80a1184:	f7ff bd9c 	b.w	80a0cc0 <network_disconnect>

080a1188 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a1188:	2200      	movs	r2, #0
 80a118a:	4611      	mov	r1, r2
 80a118c:	6840      	ldr	r0, [r0, #4]
 80a118e:	f7ff bd8f 	b.w	80a0cb0 <network_connecting>

080a1192 <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a1192:	2200      	movs	r2, #0
 80a1194:	4611      	mov	r1, r2
 80a1196:	6840      	ldr	r0, [r0, #4]
 80a1198:	f7ff bd9a 	b.w	80a0cd0 <network_ready>

080a119c <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a119c:	2300      	movs	r3, #0
 80a119e:	461a      	mov	r2, r3
 80a11a0:	4619      	mov	r1, r3
 80a11a2:	6840      	ldr	r0, [r0, #4]
 80a11a4:	f7ff bd9c 	b.w	80a0ce0 <network_on>

080a11a8 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a11a8:	2300      	movs	r3, #0
 80a11aa:	461a      	mov	r2, r3
 80a11ac:	4619      	mov	r1, r3
 80a11ae:	6840      	ldr	r0, [r0, #4]
 80a11b0:	f7ff bd9e 	b.w	80a0cf0 <network_off>

080a11b4 <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a11b4:	2200      	movs	r2, #0
 80a11b6:	f081 0101 	eor.w	r1, r1, #1
 80a11ba:	6840      	ldr	r0, [r0, #4]
 80a11bc:	f7ff bda0 	b.w	80a0d00 <network_listen>

080a11c0 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a11c0:	2200      	movs	r2, #0
 80a11c2:	6840      	ldr	r0, [r0, #4]
 80a11c4:	f7ff bdb4 	b.w	80a0d30 <network_set_listen_timeout>

080a11c8 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a11c8:	2200      	movs	r2, #0
 80a11ca:	4611      	mov	r1, r2
 80a11cc:	6840      	ldr	r0, [r0, #4]
 80a11ce:	f7ff bdb7 	b.w	80a0d40 <network_get_listen_timeout>

080a11d2 <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a11d2:	2200      	movs	r2, #0
 80a11d4:	4611      	mov	r1, r2
 80a11d6:	6840      	ldr	r0, [r0, #4]
 80a11d8:	f7ff bd9a 	b.w	80a0d10 <network_listening>

080a11dc <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a11dc:	b570      	push	{r4, r5, r6, lr}
 80a11de:	4616      	mov	r6, r2
 80a11e0:	b08e      	sub	sp, #56	; 0x38
 80a11e2:	4604      	mov	r4, r0
    IPAddress addr;
 80a11e4:	a808      	add	r0, sp, #32
 80a11e6:	f7ff fe8b 	bl	80a0f00 <_ZN9IPAddressC1Ev>
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
    {
        HAL_IPAddress ip = {};
 80a11ea:	2211      	movs	r2, #17
 80a11ec:	2100      	movs	r1, #0
 80a11ee:	a803      	add	r0, sp, #12
 80a11f0:	f002 f837 	bl	80a3262 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a11f4:	4630      	mov	r0, r6
 80a11f6:	f002 f865 	bl	80a32c4 <strlen>
 80a11fa:	2500      	movs	r5, #0
 80a11fc:	4b0a      	ldr	r3, [pc, #40]	; (80a1228 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a11fe:	9500      	str	r5, [sp, #0]
 80a1200:	b281      	uxth	r1, r0
 80a1202:	685b      	ldr	r3, [r3, #4]
 80a1204:	aa03      	add	r2, sp, #12
 80a1206:	4630      	mov	r0, r6
 80a1208:	f7ff fd0e 	bl	80a0c28 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a120c:	b120      	cbz	r0, 80a1218 <_ZN5spark12NetworkClass7resolveEPKc+0x3c>
 80a120e:	4629      	mov	r1, r5
 80a1210:	4620      	mov	r0, r4
 80a1212:	f7ff fe95 	bl	80a0f40 <_ZN9IPAddressC1Em>
 80a1216:	e003      	b.n	80a1220 <_ZN5spark12NetworkClass7resolveEPKc+0x44>
 80a1218:	a903      	add	r1, sp, #12
 80a121a:	4620      	mov	r0, r4
 80a121c:	f7ff fe7e 	bl	80a0f1c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a1220:	4620      	mov	r0, r4
 80a1222:	b00e      	add	sp, #56	; 0x38
 80a1224:	bd70      	pop	{r4, r5, r6, pc}
 80a1226:	bf00      	nop
 80a1228:	20000540 	.word	0x20000540

080a122c <_ZN5spark12NetworkClass4fromEm>:
        return Cellular;
#endif
    default:
        return Network;
    }
}
 80a122c:	4b03      	ldr	r3, [pc, #12]	; (80a123c <_ZN5spark12NetworkClass4fromEm+0x10>)
 80a122e:	4a04      	ldr	r2, [pc, #16]	; (80a1240 <_ZN5spark12NetworkClass4fromEm+0x14>)
 80a1230:	2804      	cmp	r0, #4
 80a1232:	bf0c      	ite	eq
 80a1234:	4610      	moveq	r0, r2
 80a1236:	4618      	movne	r0, r3
 80a1238:	4770      	bx	lr
 80a123a:	bf00      	nop
 80a123c:	200000bc 	.word	0x200000bc
 80a1240:	20000540 	.word	0x20000540

080a1244 <_GLOBAL__sub_I__ZN5spark7NetworkE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a1244:	4b02      	ldr	r3, [pc, #8]	; (80a1250 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a1246:	4a03      	ldr	r2, [pc, #12]	; (80a1254 <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a1248:	601a      	str	r2, [r3, #0]
 80a124a:	2200      	movs	r2, #0
 80a124c:	605a      	str	r2, [r3, #4]
 80a124e:	4770      	bx	lr
 80a1250:	200000bc 	.word	0x200000bc
 80a1254:	080a35a4 	.word	0x080a35a4

080a1258 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a1258:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a125a:	4606      	mov	r6, r0
 80a125c:	460d      	mov	r5, r1
 80a125e:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a1260:	2400      	movs	r4, #0
  while (size--) {
 80a1262:	42bd      	cmp	r5, r7
 80a1264:	d00c      	beq.n	80a1280 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a1266:	6833      	ldr	r3, [r6, #0]
 80a1268:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a126c:	689b      	ldr	r3, [r3, #8]
 80a126e:	4630      	mov	r0, r6
 80a1270:	4798      	blx	r3
     if (chunk>=0)
 80a1272:	2800      	cmp	r0, #0
 80a1274:	db01      	blt.n	80a127a <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a1276:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a1278:	e7f3      	b.n	80a1262 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a127a:	2c00      	cmp	r4, #0
 80a127c:	bf08      	it	eq
 80a127e:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a1280:	4620      	mov	r0, r4
 80a1282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a1284 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a1284:	b570      	push	{r4, r5, r6, lr}
 80a1286:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a1288:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a128a:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a128c:	b149      	cbz	r1, 80a12a2 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a128e:	f002 f819 	bl	80a32c4 <strlen>
 80a1292:	682b      	ldr	r3, [r5, #0]
 80a1294:	4602      	mov	r2, r0
 80a1296:	4621      	mov	r1, r4
 80a1298:	4628      	mov	r0, r5
    }
 80a129a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a129e:	68db      	ldr	r3, [r3, #12]
 80a12a0:	4718      	bx	r3
    }
 80a12a2:	bd70      	pop	{r4, r5, r6, pc}

080a12a4 <_ZN5Print5printEPKc>:
 80a12a4:	b508      	push	{r3, lr}
 80a12a6:	f7ff ffed 	bl	80a1284 <_ZN5Print5writeEPKc>
 80a12aa:	bd08      	pop	{r3, pc}

080a12ac <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a12ac:	6803      	ldr	r3, [r0, #0]
 80a12ae:	689b      	ldr	r3, [r3, #8]
 80a12b0:	4718      	bx	r3

080a12b2 <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a12b2:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a12b4:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a12b6:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a12b8:	f7ff fff8 	bl	80a12ac <_ZN5Print5printEc>
  n += print('\n');
 80a12bc:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a12be:	4604      	mov	r4, r0
  n += print('\n');
 80a12c0:	4628      	mov	r0, r5
 80a12c2:	f7ff fff3 	bl	80a12ac <_ZN5Print5printEc>
  return n;
}
 80a12c6:	4420      	add	r0, r4
 80a12c8:	bd38      	pop	{r3, r4, r5, pc}

080a12ca <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a12ca:	b538      	push	{r3, r4, r5, lr}
 80a12cc:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a12ce:	f7ff ffd9 	bl	80a1284 <_ZN5Print5writeEPKc>
 80a12d2:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a12d4:	4628      	mov	r0, r5
 80a12d6:	f7ff ffec 	bl	80a12b2 <_ZN5Print7printlnEv>
  return n;
}
 80a12da:	4420      	add	r0, r4
 80a12dc:	bd38      	pop	{r3, r4, r5, pc}

080a12de <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a12de:	2a01      	cmp	r2, #1
 80a12e0:	bf98      	it	ls
 80a12e2:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a12e4:	b530      	push	{r4, r5, lr}
 80a12e6:	460b      	mov	r3, r1
 80a12e8:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a12ea:	2100      	movs	r1, #0
 80a12ec:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a12f0:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
   decltype(n) m = n;
   n /= base;
 80a12f4:	fbb3 f5f2 	udiv	r5, r3, r2
   char c = m - base * n;
 80a12f8:	fb05 3312 	mls	r3, r5, r2, r3
 80a12fc:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a12fe:	2b09      	cmp	r3, #9
 80a1300:	bf94      	ite	ls
 80a1302:	3330      	addls	r3, #48	; 0x30
 80a1304:	3337      	addhi	r3, #55	; 0x37
 80a1306:	b2db      	uxtb	r3, r3
 80a1308:	4621      	mov	r1, r4
 80a130a:	f804 3901 	strb.w	r3, [r4], #-1
 80a130e:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a1310:	2d00      	cmp	r5, #0
 80a1312:	d1ef      	bne.n	80a12f4 <_ZN5Print11printNumberEmh+0x16>
   n /= base;
   char c = m - base * n;
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a1314:	f7ff ffb6 	bl	80a1284 <_ZN5Print5writeEPKc>
}
 80a1318:	b00b      	add	sp, #44	; 0x2c
 80a131a:	bd30      	pop	{r4, r5, pc}

080a131c <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a131c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a1320:	4619      	mov	r1, r3

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a1322:	4680      	mov	r8, r0
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a1324:	4610      	mov	r0, r2

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a1326:	4617      	mov	r7, r2
 80a1328:	461e      	mov	r6, r3
 80a132a:	f89d 5020 	ldrb.w	r5, [sp, #32]
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a132e:	f001 fc73 	bl	80a2c18 <__aeabi_dcmpun>
 80a1332:	b108      	cbz	r0, 80a1338 <_ZN5Print10printFloatEdh+0x1c>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1334:	494d      	ldr	r1, [pc, #308]	; (80a146c <_ZN5Print10printFloatEdh+0x150>)
 80a1336:	e012      	b.n	80a135e <_ZN5Print10printFloatEdh+0x42>
size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
 80a1338:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
 80a133c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80a1340:	4b4b      	ldr	r3, [pc, #300]	; (80a1470 <_ZN5Print10printFloatEdh+0x154>)
 80a1342:	4638      	mov	r0, r7
 80a1344:	4621      	mov	r1, r4
 80a1346:	f001 fc67 	bl	80a2c18 <__aeabi_dcmpun>
 80a134a:	b968      	cbnz	r0, 80a1368 <_ZN5Print10printFloatEdh+0x4c>
 80a134c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80a1350:	4b47      	ldr	r3, [pc, #284]	; (80a1470 <_ZN5Print10printFloatEdh+0x154>)
 80a1352:	4638      	mov	r0, r7
 80a1354:	4621      	mov	r1, r4
 80a1356:	f001 fc41 	bl	80a2bdc <__aeabi_dcmple>
 80a135a:	b928      	cbnz	r0, 80a1368 <_ZN5Print10printFloatEdh+0x4c>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a135c:	4945      	ldr	r1, [pc, #276]	; (80a1474 <_ZN5Print10printFloatEdh+0x158>)
 80a135e:	4640      	mov	r0, r8
 80a1360:	f7ff ff90 	bl	80a1284 <_ZN5Print5writeEPKc>
size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
 80a1364:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
 80a1368:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80a136c:	4b42      	ldr	r3, [pc, #264]	; (80a1478 <_ZN5Print10printFloatEdh+0x15c>)
 80a136e:	4638      	mov	r0, r7
 80a1370:	4631      	mov	r1, r6
 80a1372:	f001 fc47 	bl	80a2c04 <__aeabi_dcmpgt>
 80a1376:	b108      	cbz	r0, 80a137c <_ZN5Print10printFloatEdh+0x60>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1378:	4940      	ldr	r1, [pc, #256]	; (80a147c <_ZN5Print10printFloatEdh+0x160>)
 80a137a:	e7f0      	b.n	80a135e <_ZN5Print10printFloatEdh+0x42>
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
 80a137c:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80a1380:	4b3f      	ldr	r3, [pc, #252]	; (80a1480 <_ZN5Print10printFloatEdh+0x164>)
 80a1382:	4638      	mov	r0, r7
 80a1384:	4631      	mov	r1, r6
 80a1386:	f001 fc1f 	bl	80a2bc8 <__aeabi_dcmplt>
 80a138a:	2800      	cmp	r0, #0
 80a138c:	d1f4      	bne.n	80a1378 <_ZN5Print10printFloatEdh+0x5c>

  // Handle negative numbers
  if (number < 0.0)
 80a138e:	2200      	movs	r2, #0
 80a1390:	2300      	movs	r3, #0
 80a1392:	4638      	mov	r0, r7
 80a1394:	4631      	mov	r1, r6
 80a1396:	f001 fc17 	bl	80a2bc8 <__aeabi_dcmplt>
 80a139a:	b138      	cbz	r0, 80a13ac <_ZN5Print10printFloatEdh+0x90>
  {
     n += print('-');
 80a139c:	212d      	movs	r1, #45	; 0x2d
 80a139e:	4640      	mov	r0, r8
 80a13a0:	f7ff ff84 	bl	80a12ac <_ZN5Print5printEc>
     number = -number;
 80a13a4:	f106 4600 	add.w	r6, r6, #2147483648	; 0x80000000
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically

  // Handle negative numbers
  if (number < 0.0)
  {
     n += print('-');
 80a13a8:	4604      	mov	r4, r0
 80a13aa:	e000      	b.n	80a13ae <_ZN5Print10printFloatEdh+0x92>
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;
 80a13ac:	4604      	mov	r4, r0
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
 80a13ae:	4935      	ldr	r1, [pc, #212]	; (80a1484 <_ZN5Print10printFloatEdh+0x168>)
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;
 80a13b0:	f04f 0900 	mov.w	r9, #0
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
 80a13b4:	2000      	movs	r0, #0
  for (uint8_t i=0; i<digits; ++i)
 80a13b6:	fa5f f389 	uxtb.w	r3, r9
 80a13ba:	429d      	cmp	r5, r3
 80a13bc:	d906      	bls.n	80a13cc <_ZN5Print10printFloatEdh+0xb0>
    rounding /= 10.0;
 80a13be:	2200      	movs	r2, #0
 80a13c0:	4b31      	ldr	r3, [pc, #196]	; (80a1488 <_ZN5Print10printFloatEdh+0x16c>)
 80a13c2:	f001 fab9 	bl	80a2938 <__aeabi_ddiv>
 80a13c6:	f109 0901 	add.w	r9, r9, #1
 80a13ca:	e7f4      	b.n	80a13b6 <_ZN5Print10printFloatEdh+0x9a>

  number += rounding;
 80a13cc:	463a      	mov	r2, r7
 80a13ce:	4633      	mov	r3, r6
 80a13d0:	f000 ffd6 	bl	80a2380 <__adddf3>
 80a13d4:	460f      	mov	r7, r1
 80a13d6:	4606      	mov	r6, r0

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
 80a13d8:	f001 fc5c 	bl	80a2c94 <__aeabi_d2uiz>
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
 80a13dc:	220a      	movs	r2, #10
 80a13de:	4601      	mov	r1, r0
 80a13e0:	4681      	mov	r9, r0
 80a13e2:	4640      	mov	r0, r8
 80a13e4:	f7ff ff7b 	bl	80a12de <_ZN5Print11printNumberEmh>
  double remainder = number - (double)int_part;
  n += print(int_part);
 80a13e8:	4404      	add	r4, r0

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
 80a13ea:	b3e5      	cbz	r5, 80a1466 <_ZN5Print10printFloatEdh+0x14a>

  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
 80a13ec:	4648      	mov	r0, r9
 80a13ee:	f001 f903 	bl	80a25f8 <__aeabi_ui2d>
 80a13f2:	4602      	mov	r2, r0
 80a13f4:	460b      	mov	r3, r1
 80a13f6:	4630      	mov	r0, r6
 80a13f8:	4639      	mov	r1, r7
 80a13fa:	f000 ffbf 	bl	80a237c <__aeabi_dsub>
 80a13fe:	4606      	mov	r6, r0
 80a1400:	460f      	mov	r7, r1
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1402:	4640      	mov	r0, r8
 80a1404:	4921      	ldr	r1, [pc, #132]	; (80a148c <_ZN5Print10printFloatEdh+0x170>)
 80a1406:	f7ff ff3d 	bl	80a1284 <_ZN5Print5writeEPKc>
  double remainder = number - (double)int_part;
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print(".");
 80a140a:	4404      	add	r4, r0
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
 80a140c:	2200      	movs	r2, #0
 80a140e:	4b1e      	ldr	r3, [pc, #120]	; (80a1488 <_ZN5Print10printFloatEdh+0x16c>)
 80a1410:	4630      	mov	r0, r6
 80a1412:	4639      	mov	r1, r7
 80a1414:	f001 f966 	bl	80a26e4 <__aeabi_dmul>
 80a1418:	4606      	mov	r6, r0
 80a141a:	460f      	mov	r7, r1
    int toPrint = int(remainder);
 80a141c:	f001 fc12 	bl	80a2c44 <__aeabi_d2iz>
        return write(n);
    } else {
        size_t t = 0;
        using PrintNumberType = typename PrintNumberTypeSelector<T>::type;
        PrintNumberType val;
        if (n < 0 && base == 10) {
 80a1420:	f1b0 0a00 	subs.w	sl, r0, #0
 80a1424:	da07      	bge.n	80a1436 <_ZN5Print10printFloatEdh+0x11a>
            t = print('-');
 80a1426:	212d      	movs	r1, #45	; 0x2d
 80a1428:	4640      	mov	r0, r8
 80a142a:	f7ff ff3f 	bl	80a12ac <_ZN5Print5printEc>
            val = -n;
 80a142e:	f1ca 0100 	rsb	r1, sl, #0
    } else {
        size_t t = 0;
        using PrintNumberType = typename PrintNumberTypeSelector<T>::type;
        PrintNumberType val;
        if (n < 0 && base == 10) {
            t = print('-');
 80a1432:	4681      	mov	r9, r0
 80a1434:	e002      	b.n	80a143c <_ZN5Print10printFloatEdh+0x120>
            val = -n;
        } else {
            val = n;
 80a1436:	4651      	mov	r1, sl
size_t Print::print(T n, int base)
{
    if (base == 0) {
        return write(n);
    } else {
        size_t t = 0;
 80a1438:	f04f 0900 	mov.w	r9, #0
            t = print('-');
            val = -n;
        } else {
            val = n;
        }
        return printNumber(val, base) + t;
 80a143c:	220a      	movs	r2, #10
 80a143e:	4640      	mov	r0, r8
 80a1440:	f7ff ff4d 	bl	80a12de <_ZN5Print11printNumberEmh>
    n += print(toPrint);
 80a1444:	4448      	add	r0, r9
 80a1446:	4404      	add	r4, r0
    remainder -= toPrint;
 80a1448:	4650      	mov	r0, sl
 80a144a:	f001 f8e5 	bl	80a2618 <__aeabi_i2d>
 80a144e:	4602      	mov	r2, r0
 80a1450:	460b      	mov	r3, r1
 80a1452:	4630      	mov	r0, r6
 80a1454:	4639      	mov	r1, r7
 80a1456:	f000 ff91 	bl	80a237c <__aeabi_dsub>
 80a145a:	3d01      	subs	r5, #1
  if (digits > 0) {
    n += print(".");
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
 80a145c:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
  {
    remainder *= 10.0;
    int toPrint = int(remainder);
    n += print(toPrint);
    remainder -= toPrint;
 80a1460:	4606      	mov	r6, r0
 80a1462:	460f      	mov	r7, r1
  if (digits > 0) {
    n += print(".");
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
 80a1464:	d1d2      	bne.n	80a140c <_ZN5Print10printFloatEdh+0xf0>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
 80a1466:	4620      	mov	r0, r4
 80a1468:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a146c:	080a35d0 	.word	0x080a35d0
 80a1470:	7fefffff 	.word	0x7fefffff
 80a1474:	080a35da 	.word	0x080a35da
 80a1478:	41efffff 	.word	0x41efffff
 80a147c:	080a35d4 	.word	0x080a35d4
 80a1480:	c1efffff 	.word	0xc1efffff
 80a1484:	3fe00000 	.word	0x3fe00000
 80a1488:	40240000 	.word	0x40240000
 80a148c:	080a35d8 	.word	0x080a35d8

080a1490 <_ZN5Print5printEfi>:
{
  return write(c);
}

size_t Print::print(float n, int digits)
{
 80a1490:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1492:	4605      	mov	r5, r0
 80a1494:	4614      	mov	r4, r2
  return printFloat((double)n, digits);
 80a1496:	4608      	mov	r0, r1
 80a1498:	f001 f8d0 	bl	80a263c <__aeabi_f2d>
 80a149c:	b2e4      	uxtb	r4, r4
 80a149e:	4602      	mov	r2, r0
 80a14a0:	9400      	str	r4, [sp, #0]
 80a14a2:	460b      	mov	r3, r1
 80a14a4:	4628      	mov	r0, r5
 80a14a6:	f7ff ff39 	bl	80a131c <_ZN5Print10printFloatEdh>
}
 80a14aa:	b003      	add	sp, #12
 80a14ac:	bd30      	pop	{r4, r5, pc}

080a14ae <_ZN5Print5printEdi>:

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
 80a14ae:	f89d 1000 	ldrb.w	r1, [sp]
 80a14b2:	9100      	str	r1, [sp, #0]
 80a14b4:	f7ff bf32 	b.w	80a131c <_ZN5Print10printFloatEdh>

080a14b8 <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a14b8:	b40c      	push	{r2, r3}
 80a14ba:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a14be:	b087      	sub	sp, #28
 80a14c0:	af00      	add	r7, sp, #0
 80a14c2:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a14c6:	f854 9b04 	ldr.w	r9, [r4], #4
 80a14ca:	4605      	mov	r5, r0
 80a14cc:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a14ce:	4623      	mov	r3, r4
 80a14d0:	464a      	mov	r2, r9
 80a14d2:	2114      	movs	r1, #20
 80a14d4:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a14d6:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a14d8:	f7ff fc5a 	bl	80a0d90 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a14dc:	2813      	cmp	r0, #19
 80a14de:	d805      	bhi.n	80a14ec <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a14e0:	1d39      	adds	r1, r7, #4
 80a14e2:	4628      	mov	r0, r5
 80a14e4:	f7ff fece 	bl	80a1284 <_ZN5Print5writeEPKc>
 80a14e8:	4604      	mov	r4, r0
 80a14ea:	e013      	b.n	80a1514 <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a14ec:	f100 0308 	add.w	r3, r0, #8
 80a14f0:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a14f4:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a14f6:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a14fa:	1c41      	adds	r1, r0, #1
 80a14fc:	4623      	mov	r3, r4
 80a14fe:	464a      	mov	r2, r9
 80a1500:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a1502:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a1504:	f7ff fc44 	bl	80a0d90 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a1508:	4669      	mov	r1, sp
 80a150a:	4628      	mov	r0, r5
 80a150c:	f7ff feba 	bl	80a1284 <_ZN5Print5writeEPKc>
 80a1510:	4604      	mov	r4, r0
 80a1512:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a1514:	b11e      	cbz	r6, 80a151e <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a1516:	4628      	mov	r0, r5
 80a1518:	f7ff fecb 	bl	80a12b2 <_ZN5Print7printlnEv>
 80a151c:	4404      	add	r4, r0
    return n;
}
 80a151e:	4620      	mov	r0, r4
 80a1520:	371c      	adds	r7, #28
 80a1522:	46bd      	mov	sp, r7
 80a1524:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1528:	b002      	add	sp, #8
 80a152a:	4770      	bx	lr

080a152c <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a152c:	b510      	push	{r4, lr}
 80a152e:	4604      	mov	r4, r0
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a1530:	f7ff fc39 	bl	80a0da6 <_ZNSt14_Function_baseD1Ev>
 80a1534:	4620      	mov	r0, r4
 80a1536:	bd10      	pop	{r4, pc}

080a1538 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a1538:	4803      	ldr	r0, [pc, #12]	; (80a1548 <_GLOBAL__sub_I_RGB+0x10>)
 80a153a:	2300      	movs	r3, #0
 80a153c:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a153e:	4a03      	ldr	r2, [pc, #12]	; (80a154c <_GLOBAL__sub_I_RGB+0x14>)
 80a1540:	4903      	ldr	r1, [pc, #12]	; (80a1550 <_GLOBAL__sub_I_RGB+0x18>)
 80a1542:	f000 bdad 	b.w	80a20a0 <__aeabi_atexit>
 80a1546:	bf00      	nop
 80a1548:	200000c4 	.word	0x200000c4
 80a154c:	20000070 	.word	0x20000070
 80a1550:	080a152d 	.word	0x080a152d

080a1554 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a1554:	b510      	push	{r4, lr}
 80a1556:	4604      	mov	r4, r0
{
	free(buffer);
 80a1558:	6800      	ldr	r0, [r0, #0]
 80a155a:	f7ff fc01 	bl	80a0d60 <free>
}
 80a155e:	4620      	mov	r0, r4
 80a1560:	bd10      	pop	{r4, pc}

080a1562 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a1562:	b510      	push	{r4, lr}
 80a1564:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a1566:	6800      	ldr	r0, [r0, #0]
 80a1568:	b108      	cbz	r0, 80a156e <_ZN6String10invalidateEv+0xc>
 80a156a:	f7ff fbf9 	bl	80a0d60 <free>
	buffer = NULL;
 80a156e:	2300      	movs	r3, #0
 80a1570:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a1572:	60a3      	str	r3, [r4, #8]
 80a1574:	6063      	str	r3, [r4, #4]
 80a1576:	bd10      	pop	{r4, pc}

080a1578 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a1578:	b538      	push	{r3, r4, r5, lr}
 80a157a:	4604      	mov	r4, r0
 80a157c:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a157e:	6800      	ldr	r0, [r0, #0]
 80a1580:	3101      	adds	r1, #1
 80a1582:	f7ff fbf5 	bl	80a0d70 <realloc>
	if (newbuffer) {
 80a1586:	b110      	cbz	r0, 80a158e <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a1588:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a158c:	2001      	movs	r0, #1
	}
	return 0;
}
 80a158e:	bd38      	pop	{r3, r4, r5, pc}

080a1590 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a1590:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a1592:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a1594:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a1596:	b113      	cbz	r3, 80a159e <_ZN6String7reserveEj+0xe>
 80a1598:	6843      	ldr	r3, [r0, #4]
 80a159a:	428b      	cmp	r3, r1
 80a159c:	d207      	bcs.n	80a15ae <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a159e:	4620      	mov	r0, r4
 80a15a0:	f7ff ffea 	bl	80a1578 <_ZN6String12changeBufferEj>
 80a15a4:	b120      	cbz	r0, 80a15b0 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a15a6:	68a3      	ldr	r3, [r4, #8]
 80a15a8:	b90b      	cbnz	r3, 80a15ae <_ZN6String7reserveEj+0x1e>
 80a15aa:	6822      	ldr	r2, [r4, #0]
 80a15ac:	7013      	strb	r3, [r2, #0]
 80a15ae:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a15b0:	bd10      	pop	{r4, pc}

080a15b2 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a15b2:	b570      	push	{r4, r5, r6, lr}
 80a15b4:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a15b6:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a15b8:	4604      	mov	r4, r0
 80a15ba:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a15bc:	f7ff ffe8 	bl	80a1590 <_ZN6String7reserveEj>
 80a15c0:	b918      	cbnz	r0, 80a15ca <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a15c2:	4620      	mov	r0, r4
 80a15c4:	f7ff ffcd 	bl	80a1562 <_ZN6String10invalidateEv>
		return *this;
 80a15c8:	e009      	b.n	80a15de <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a15ca:	462a      	mov	r2, r5
 80a15cc:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a15ce:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a15d0:	6820      	ldr	r0, [r4, #0]
 80a15d2:	f001 fe3b 	bl	80a324c <memcpy>
	buffer[len] = 0;
 80a15d6:	6822      	ldr	r2, [r4, #0]
 80a15d8:	68a3      	ldr	r3, [r4, #8]
 80a15da:	2100      	movs	r1, #0
 80a15dc:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a15de:	4620      	mov	r0, r4
 80a15e0:	bd70      	pop	{r4, r5, r6, pc}

080a15e2 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a15e2:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a15e4:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a15e6:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a15e8:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a15ea:	6043      	str	r3, [r0, #4]
	len = 0;
 80a15ec:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a15ee:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a15f0:	460d      	mov	r5, r1
 80a15f2:	b139      	cbz	r1, 80a1604 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a15f4:	4608      	mov	r0, r1
 80a15f6:	f001 fe65 	bl	80a32c4 <strlen>
 80a15fa:	4629      	mov	r1, r5
 80a15fc:	4602      	mov	r2, r0
 80a15fe:	4620      	mov	r0, r4
 80a1600:	f7ff ffd7 	bl	80a15b2 <_ZN6String4copyEPKcj>
}
 80a1604:	4620      	mov	r0, r4
 80a1606:	bd38      	pop	{r3, r4, r5, pc}

080a1608 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>:
    operator SleepResult() {
        return toSleepResult();
    }

private:
    void freeWakeupSourceMemory() {
 80a1608:	b510      	push	{r4, lr}
 80a160a:	4604      	mov	r4, r0
        if (wakeupSource_) {
 80a160c:	6800      	ldr	r0, [r0, #0]
 80a160e:	b118      	cbz	r0, 80a1618 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2+0x10>
            free(wakeupSource_);
 80a1610:	f7ff fba6 	bl	80a0d60 <free>
            wakeupSource_ = nullptr;
 80a1614:	2300      	movs	r3, #0
 80a1616:	6023      	str	r3, [r4, #0]
 80a1618:	bd10      	pop	{r4, pc}

080a161a <_ZN11SystemClassD1Ev>:
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a161a:	b510      	push	{r4, lr}
 80a161c:	4604      	mov	r4, r0
        }
        return *this;
    }

    ~SystemSleepResult() {
        freeWakeupSourceMemory();
 80a161e:	f7ff fff3 	bl	80a1608 <_ZN17SystemSleepResult22freeWakeupSourceMemoryEv.isra.2>
    system_error_t error_;
    SleepResult compatResult_;
};


class SystemClass {
 80a1622:	4620      	mov	r0, r4
 80a1624:	bd10      	pop	{r4, pc}
	...

080a1628 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
 80a1628:	f64f 73ff 	movw	r3, #65535	; 0xffff
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a162c:	b510      	push	{r4, lr}

class SystemSleepResult {
public:
    SystemSleepResult()
            : wakeupSource_(nullptr),
              error_(SYSTEM_ERROR_NONE) {
 80a162e:	4c08      	ldr	r4, [pc, #32]	; (80a1650 <_GLOBAL__sub_I_System+0x28>)
 80a1630:	2000      	movs	r0, #0
 80a1632:	6020      	str	r0, [r4, #0]
 80a1634:	80a0      	strh	r0, [r4, #4]
    WAKEUP_REASON_PIN_OR_RTC = 3,
    WAKEUP_REASON_UNKNOWN = 4
};

struct SleepResult {
    SleepResult() {}
 80a1636:	71a0      	strb	r0, [r4, #6]
 80a1638:	8120      	strh	r0, [r4, #8]
 80a163a:	8163      	strh	r3, [r4, #10]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a163c:	f7ff fb04 	bl	80a0c48 <set_system_mode>

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
 80a1640:	4620      	mov	r0, r4
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
 80a1642:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

#if Wiring_LogConfig
extern void(*log_process_ctrl_request_callback)(ctrl_request* req);
#endif

SystemClass System;
 80a1646:	4a03      	ldr	r2, [pc, #12]	; (80a1654 <_GLOBAL__sub_I_System+0x2c>)
 80a1648:	4903      	ldr	r1, [pc, #12]	; (80a1658 <_GLOBAL__sub_I_System+0x30>)
 80a164a:	f000 bd29 	b.w	80a20a0 <__aeabi_atexit>
 80a164e:	bf00      	nop
 80a1650:	200000d4 	.word	0x200000d4
 80a1654:	20000070 	.word	0x20000070
 80a1658:	080a161b 	.word	0x080a161b

080a165c <_ZN9TCPClient5writeEh>:
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a165c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a165e:	ac02      	add	r4, sp, #8
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a1660:	6803      	ldr	r3, [r0, #0]
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a1662:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a1666:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a1668:	2201      	movs	r2, #1
 80a166a:	f247 5330 	movw	r3, #30000	; 0x7530
 80a166e:	4621      	mov	r1, r4
 80a1670:	47a8      	blx	r5
}
 80a1672:	b003      	add	sp, #12
 80a1674:	bd30      	pop	{r4, r5, pc}

080a1676 <_ZN9TCPClient5writeEPKhj>:

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
 80a1676:	b410      	push	{r4}
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a1678:	6803      	ldr	r3, [r0, #0]
 80a167a:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80a167c:	f247 5330 	movw	r3, #30000	; 0x7530
 80a1680:	46a4      	mov	ip, r4
}
 80a1682:	bc10      	pop	{r4}
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a1684:	4760      	bx	ip

080a1686 <_ZN9TCPClient5writeEhm>:
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a1686:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1688:	ac02      	add	r4, sp, #8
    return write(&b, 1, timeout);
 80a168a:	6803      	ldr	r3, [r0, #0]
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a168c:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, timeout);
 80a1690:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a1692:	4621      	mov	r1, r4
 80a1694:	4613      	mov	r3, r2
 80a1696:	2201      	movs	r2, #1
 80a1698:	47a8      	blx	r5
}
 80a169a:	b003      	add	sp, #12
 80a169c:	bd30      	pop	{r4, r5, pc}

080a169e <_ZN9TCPClient5flushEv>:
  d_->offset = 0;
  d_->total = 0;
}

void TCPClient::flush()
{
 80a169e:	4770      	bx	lr

080a16a0 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a16a0:	4770      	bx	lr

080a16a2 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
 80a16a2:	2000      	movs	r0, #0
 80a16a4:	4770      	bx	lr

080a16a6 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a16a6:	b510      	push	{r4, lr}
 80a16a8:	4604      	mov	r4, r0
 80a16aa:	2114      	movs	r1, #20
 80a16ac:	f000 fcfd 	bl	80a20aa <_ZdlPvj>
 80a16b0:	4620      	mov	r0, r4
 80a16b2:	bd10      	pop	{r4, pc}

080a16b4 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 80a16b4:	f7fe bcf5 	b.w	80a00a2 <_ZdlPv>

080a16b8 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.28>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a16b8:	b510      	push	{r4, lr}
 80a16ba:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a16bc:	6803      	ldr	r3, [r0, #0]
 80a16be:	689b      	ldr	r3, [r3, #8]
 80a16c0:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a16c2:	68a3      	ldr	r3, [r4, #8]
 80a16c4:	3b01      	subs	r3, #1
 80a16c6:	60a3      	str	r3, [r4, #8]
 80a16c8:	b92b      	cbnz	r3, 80a16d6 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.28+0x1e>
            _M_destroy();
 80a16ca:	6823      	ldr	r3, [r4, #0]
 80a16cc:	4620      	mov	r0, r4
        }
    }
 80a16ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a16d2:	68db      	ldr	r3, [r3, #12]
 80a16d4:	4718      	bx	r3
 80a16d6:	bd10      	pop	{r4, pc}

080a16d8 <_ZN9TCPClient8remoteIPEv>:
{
   return (status()!=0);
}

IPAddress TCPClient::remoteIP()
{
 80a16d8:	b570      	push	{r4, r5, r6, lr}

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a16da:	4604      	mov	r4, r0
 80a16dc:	4606      	mov	r6, r0
 80a16de:	694d      	ldr	r5, [r1, #20]
 80a16e0:	4b04      	ldr	r3, [pc, #16]	; (80a16f4 <_ZN9TCPClient8remoteIPEv+0x1c>)
 80a16e2:	358c      	adds	r5, #140	; 0x8c
 80a16e4:	f844 3b04 	str.w	r3, [r4], #4
 80a16e8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a16ea:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a16ec:	682b      	ldr	r3, [r5, #0]
    return d_->remoteIP;
}
 80a16ee:	4630      	mov	r0, r6
 80a16f0:	7023      	strb	r3, [r4, #0]
 80a16f2:	bd70      	pop	{r4, r5, r6, pc}
 80a16f4:	080a3474 	.word	0x080a3474

080a16f8 <_ZN9TCPClient4peekEv>:
        }
        return read;
}

int TCPClient::peek()
{
 80a16f8:	b510      	push	{r4, lr}
 80a16fa:	6943      	ldr	r3, [r0, #20]
 80a16fc:	4604      	mov	r4, r0
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
 80a16fe:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a1702:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a1706:	429a      	cmp	r2, r3
 80a1708:	d005      	beq.n	80a1716 <_ZN9TCPClient4peekEv+0x1e>
 80a170a:	6962      	ldr	r2, [r4, #20]
 80a170c:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a1710:	4413      	add	r3, r2
 80a1712:	7918      	ldrb	r0, [r3, #4]
 80a1714:	bd10      	pop	{r4, pc}
 80a1716:	6803      	ldr	r3, [r0, #0]
 80a1718:	691b      	ldr	r3, [r3, #16]
 80a171a:	4798      	blx	r3
 80a171c:	2800      	cmp	r0, #0
 80a171e:	d1f4      	bne.n	80a170a <_ZN9TCPClient4peekEv+0x12>
 80a1720:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a1724:	bd10      	pop	{r4, pc}

080a1726 <_ZN9TCPClient4readEv>:
    avail = bufferCount();
    return avail;
}

int TCPClient::read()
{
 80a1726:	b510      	push	{r4, lr}
 80a1728:	6943      	ldr	r3, [r0, #20]
 80a172a:	4604      	mov	r4, r0
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
 80a172c:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a1730:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a1734:	429a      	cmp	r2, r3
 80a1736:	d008      	beq.n	80a174a <_ZN9TCPClient4readEv+0x24>
 80a1738:	6962      	ldr	r2, [r4, #20]
 80a173a:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a173e:	1c59      	adds	r1, r3, #1
 80a1740:	f8a2 1084 	strh.w	r1, [r2, #132]	; 0x84
 80a1744:	4413      	add	r3, r2
 80a1746:	7918      	ldrb	r0, [r3, #4]
 80a1748:	bd10      	pop	{r4, pc}
 80a174a:	6803      	ldr	r3, [r0, #0]
 80a174c:	691b      	ldr	r3, [r3, #16]
 80a174e:	4798      	blx	r3
 80a1750:	2800      	cmp	r0, #0
 80a1752:	d1f1      	bne.n	80a1738 <_ZN9TCPClient4readEv+0x12>
 80a1754:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a1758:	bd10      	pop	{r4, pc}

080a175a <_ZN9TCPClient4readEPhj>:

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a175a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a175c:	6943      	ldr	r3, [r0, #20]
 80a175e:	4617      	mov	r7, r2
        int read = -1;
        if (bufferCount() || available())
 80a1760:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a1764:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a1768:	4605      	mov	r5, r0
        int read = -1;
        if (bufferCount() || available())
 80a176a:	429a      	cmp	r2, r3
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a176c:	460e      	mov	r6, r1
        int read = -1;
        if (bufferCount() || available())
 80a176e:	d106      	bne.n	80a177e <_ZN9TCPClient4readEPhj+0x24>
 80a1770:	6803      	ldr	r3, [r0, #0]
 80a1772:	691b      	ldr	r3, [r3, #16]
 80a1774:	4798      	blx	r3
 80a1776:	b910      	cbnz	r0, 80a177e <_ZN9TCPClient4readEPhj+0x24>
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
 80a1778:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80a177c:	e014      	b.n	80a17a8 <_ZN9TCPClient4readEPhj+0x4e>
 80a177e:	6969      	ldr	r1, [r5, #20]
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a1780:	4630      	mov	r0, r6
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a1782:	f8b1 3084 	ldrh.w	r3, [r1, #132]	; 0x84
 80a1786:	f8b1 4086 	ldrh.w	r4, [r1, #134]	; 0x86
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a178a:	4419      	add	r1, r3
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a178c:	1ae4      	subs	r4, r4, r3
int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
 80a178e:	42bc      	cmp	r4, r7
 80a1790:	bf28      	it	cs
 80a1792:	463c      	movcs	r4, r7
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a1794:	3104      	adds	r1, #4
 80a1796:	4622      	mov	r2, r4
 80a1798:	f001 fd58 	bl	80a324c <memcpy>
 80a179c:	696a      	ldr	r2, [r5, #20]
          d_->offset += read;
 80a179e:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a17a2:	4423      	add	r3, r4
 80a17a4:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
        }
        return read;
}
 80a17a8:	4620      	mov	r0, r4
 80a17aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a17ac <_ZN9TCPClient12flush_bufferEv>:
{
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
}

void TCPClient::flush_buffer()
{
 80a17ac:	6942      	ldr	r2, [r0, #20]
  d_->offset = 0;
 80a17ae:	2300      	movs	r3, #0
 80a17b0:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
 80a17b4:	6942      	ldr	r2, [r0, #20]
  d_->total = 0;
 80a17b6:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
 80a17ba:	4770      	bx	lr

080a17bc <_ZN9TCPClient9availableEv>:
{
  return d_->total - d_->offset;
}

int TCPClient::available()
{
 80a17bc:	b538      	push	{r3, r4, r5, lr}
 80a17be:	6942      	ldr	r2, [r0, #20]
 80a17c0:	4604      	mov	r4, r0
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
 80a17c2:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a17c6:	b11b      	cbz	r3, 80a17d0 <_ZN9TCPClient9availableEv+0x14>
 80a17c8:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
 80a17cc:	429a      	cmp	r2, r3
 80a17ce:	d00c      	beq.n	80a17ea <_ZN9TCPClient9availableEv+0x2e>
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a17d0:	6920      	ldr	r0, [r4, #16]
 80a17d2:	f7ff fd2b 	bl	80a122c <_ZN5spark12NetworkClass4fromEm>
 80a17d6:	6803      	ldr	r3, [r0, #0]
 80a17d8:	68db      	ldr	r3, [r3, #12]
 80a17da:	4798      	blx	r3
 80a17dc:	b318      	cbz	r0, 80a1826 <_ZN9TCPClient9availableEv+0x6a>
 80a17de:	6963      	ldr	r3, [r4, #20]

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a17e0:	6818      	ldr	r0, [r3, #0]
 80a17e2:	f7ff f971 	bl	80a0ac8 <socket_handle_valid>
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a17e6:	b918      	cbnz	r0, 80a17f0 <_ZN9TCPClient9availableEv+0x34>
 80a17e8:	e01d      	b.n	80a1826 <_ZN9TCPClient9availableEv+0x6a>
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
 80a17ea:	f7ff ffdf 	bl	80a17ac <_ZN9TCPClient12flush_bufferEv>
 80a17ee:	e7ef      	b.n	80a17d0 <_ZN9TCPClient9availableEv+0x14>
 80a17f0:	6960      	ldr	r0, [r4, #20]
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
    {
        // Have room
        if ( d_->total < arraySize(d_->buffer))
 80a17f2:	f8b0 1086 	ldrh.w	r1, [r0, #134]	; 0x86
 80a17f6:	297f      	cmp	r1, #127	; 0x7f
 80a17f8:	d815      	bhi.n	80a1826 <_ZN9TCPClient9availableEv+0x6a>
        {
            int ret = socket_receive(d_->sock, d_->buffer + d_->total , arraySize(d_->buffer)-d_->total, 0);
 80a17fa:	1d05      	adds	r5, r0, #4
 80a17fc:	f1c1 0280 	rsb	r2, r1, #128	; 0x80
 80a1800:	2300      	movs	r3, #0
 80a1802:	4429      	add	r1, r5
 80a1804:	6800      	ldr	r0, [r0, #0]
 80a1806:	f7ff f977 	bl	80a0af8 <socket_receive>
            if (ret > 0)
 80a180a:	2800      	cmp	r0, #0
 80a180c:	dd0b      	ble.n	80a1826 <_ZN9TCPClient9availableEv+0x6a>
 80a180e:	6963      	ldr	r3, [r4, #20]
            {
                DEBUG("recv(=%d)",ret);
                if (d_->total == 0) d_->offset = 0;
 80a1810:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a1814:	b90a      	cbnz	r2, 80a181a <_ZN9TCPClient9availableEv+0x5e>
 80a1816:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
 80a181a:	6962      	ldr	r2, [r4, #20]
                d_->total += ret;
 80a181c:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a1820:	4418      	add	r0, r3
 80a1822:	f8a2 0086 	strh.w	r0, [r2, #134]	; 0x86
 80a1826:	6962      	ldr	r2, [r4, #20]
            }
        } // Have Space
    } // WiFi.ready() && isOpen(d_->sock)
    avail = bufferCount();
    return avail;
 80a1828:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a182c:	f8b2 0084 	ldrh.w	r0, [r2, #132]	; 0x84
 80a1830:	1a18      	subs	r0, r3, r0
}
 80a1832:	bd38      	pop	{r3, r4, r5, pc}

080a1834 <_ZN9TCPClient4stopEv>:
{
}


void TCPClient::stop()
{
 80a1834:	b538      	push	{r3, r4, r5, lr}
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a1836:	6943      	ldr	r3, [r0, #20]
{
}


void TCPClient::stop()
{
 80a1838:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a183a:	6818      	ldr	r0, [r3, #0]
 80a183c:	f7ff f944 	bl	80a0ac8 <socket_handle_valid>
void TCPClient::stop()
{
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a1840:	b118      	cbz	r0, 80a184a <_ZN9TCPClient4stopEv+0x16>
      socket_close(d_->sock);
 80a1842:	6963      	ldr	r3, [r4, #20]
 80a1844:	6818      	ldr	r0, [r3, #0]
 80a1846:	f7ff f95f 	bl	80a0b08 <socket_close>
 80a184a:	6965      	ldr	r5, [r4, #20]
  d_->sock = socket_handle_invalid();
 80a184c:	f7ff f964 	bl	80a0b18 <socket_handle_invalid>
 80a1850:	6028      	str	r0, [r5, #0]
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a1852:	6960      	ldr	r0, [r4, #20]
 80a1854:	2211      	movs	r2, #17
 80a1856:	2100      	movs	r1, #0
 80a1858:	308c      	adds	r0, #140	; 0x8c
 80a185a:	f001 fd02 	bl	80a3262 <memset>
  d_->remoteIP.clear();
  flush_buffer();
 80a185e:	4620      	mov	r0, r4
}
 80a1860:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  if (isOpen(d_->sock))
      socket_close(d_->sock);
  d_->sock = socket_handle_invalid();
  d_->remoteIP.clear();
  flush_buffer();
 80a1864:	f7ff bfa2 	b.w	80a17ac <_ZN9TCPClient12flush_bufferEv>

080a1868 <_ZN9TCPClient7connectE9IPAddresstm>:
    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a1868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a186c:	461f      	mov	r7, r3
    stop();
 80a186e:	6803      	ldr	r3, [r0, #0]
    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a1870:	b08a      	sub	sp, #40	; 0x28
    stop();
 80a1872:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    return 0; // error, could not connect
}

// return 0 on error, 1 on success
int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a1874:	4606      	mov	r6, r0
 80a1876:	460c      	mov	r4, r1
 80a1878:	4615      	mov	r5, r2
    stop();
 80a187a:	4798      	blx	r3
        int connected = 0;
        if(Network.from(nif).ready())
 80a187c:	4638      	mov	r0, r7
 80a187e:	f7ff fcd5 	bl	80a122c <_ZN5spark12NetworkClass4fromEm>
 80a1882:	6803      	ldr	r3, [r0, #0]
 80a1884:	68db      	ldr	r3, [r3, #12]
 80a1886:	4798      	blx	r3
 80a1888:	2800      	cmp	r0, #0
 80a188a:	d056      	beq.n	80a193a <_ZN9TCPClient7connectE9IPAddresstm+0xd2>
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a188c:	9700      	str	r7, [sp, #0]
 80a188e:	462b      	mov	r3, r5
 80a1890:	2206      	movs	r2, #6
 80a1892:	2101      	movs	r1, #1
 80a1894:	2002      	movs	r0, #2
 80a1896:	f8d6 8014 	ldr.w	r8, [r6, #20]
 80a189a:	f7ff f91d 	bl	80a0ad8 <socket_create>
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a189e:	2320      	movs	r3, #32
    stop();
        int connected = 0;
        if(Network.from(nif).ready())
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a18a0:	f8c8 0000 	str.w	r0, [r8]
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a18a4:	2700      	movs	r7, #0
 80a18a6:	9302      	str	r3, [sp, #8]
 80a18a8:	6973      	ldr	r3, [r6, #20]
 80a18aa:	9703      	str	r7, [sp, #12]
 80a18ac:	681b      	ldr	r3, [r3, #0]
 80a18ae:	2001      	movs	r0, #1
 80a18b0:	9301      	str	r3, [sp, #4]
 80a18b2:	4b23      	ldr	r3, [pc, #140]	; (80a1940 <_ZN9TCPClient7connectE9IPAddresstm+0xd8>)
 80a18b4:	aa02      	add	r2, sp, #8
 80a18b6:	9300      	str	r3, [sp, #0]
 80a18b8:	4922      	ldr	r1, [pc, #136]	; (80a1944 <_ZN9TCPClient7connectE9IPAddresstm+0xdc>)
 80a18ba:	463b      	mov	r3, r7
 80a18bc:	f7ff f9bc 	bl	80a0c38 <log_message>

          if (socket_handle_valid(d_->sock))
 80a18c0:	6973      	ldr	r3, [r6, #20]
 80a18c2:	6818      	ldr	r0, [r3, #0]
 80a18c4:	f7ff f900 	bl	80a0ac8 <socket_handle_valid>
 80a18c8:	2800      	cmp	r0, #0
 80a18ca:	d036      	beq.n	80a193a <_ZN9TCPClient7connectE9IPAddresstm+0xd2>
          {
            flush_buffer();
 80a18cc:	4630      	mov	r0, r6
 80a18ce:	f7ff ff6d 	bl	80a17ac <_ZN9TCPClient12flush_bufferEv>

            tSocketAddr.sa_family = AF_INET;
 80a18d2:	2302      	movs	r3, #2
 80a18d4:	f8ad 3008 	strh.w	r3, [sp, #8]

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a18d8:	0a2b      	lsrs	r3, r5, #8
 80a18da:	f88d 300a 	strb.w	r3, [sp, #10]
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a18de:	79e3      	ldrb	r3, [r4, #7]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a18e0:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a18e4:	f88d 300c 	strb.w	r3, [sp, #12]
            tSocketAddr.sa_data[3] = ip[1];
 80a18e8:	79a3      	ldrb	r3, [r4, #6]
            flush_buffer();

            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);
 80a18ea:	f88d 500b 	strb.w	r5, [sp, #11]

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
            tSocketAddr.sa_data[3] = ip[1];
 80a18ee:	f88d 300d 	strb.w	r3, [sp, #13]
            tSocketAddr.sa_data[4] = ip[2];
 80a18f2:	7963      	ldrb	r3, [r4, #5]
 80a18f4:	f88d 300e 	strb.w	r3, [sp, #14]
            tSocketAddr.sa_data[5] = ip[3];
 80a18f8:	f814 3f04 	ldrb.w	r3, [r4, #4]!
 80a18fc:	f88d 300f 	strb.w	r3, [sp, #15]


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a1900:	f7ff f98a 	bl	80a0c18 <HAL_NET_SetNetWatchDog>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a1904:	6973      	ldr	r3, [r6, #20]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a1906:	4605      	mov	r5, r0
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a1908:	2210      	movs	r2, #16
 80a190a:	a902      	add	r1, sp, #8
 80a190c:	6818      	ldr	r0, [r3, #0]
 80a190e:	f7ff f8eb 	bl	80a0ae8 <socket_connect>
 80a1912:	4680      	mov	r8, r0
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
 80a1914:	4628      	mov	r0, r5
 80a1916:	f7ff f97f 	bl	80a0c18 <HAL_NET_SetNetWatchDog>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a191a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a191c:	6975      	ldr	r5, [r6, #20]
 80a191e:	358c      	adds	r5, #140	; 0x8c
 80a1920:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a1922:	6823      	ldr	r3, [r4, #0]
 80a1924:	702b      	strb	r3, [r5, #0]
            d_->remoteIP = ip;
            if(!connected)
 80a1926:	f1b8 0f00 	cmp.w	r8, #0
 80a192a:	d005      	beq.n	80a1938 <_ZN9TCPClient7connectE9IPAddresstm+0xd0>
            {
                stop();
 80a192c:	6833      	ldr	r3, [r6, #0]
 80a192e:	4630      	mov	r0, r6
 80a1930:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a1932:	4798      	blx	r3
 80a1934:	4638      	mov	r0, r7
 80a1936:	e000      	b.n	80a193a <_ZN9TCPClient7connectE9IPAddresstm+0xd2>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
            d_->remoteIP = ip;
            if(!connected)
 80a1938:	2001      	movs	r0, #1
                stop();
            }
          }
        }
        return connected;
}
 80a193a:	b00a      	add	sp, #40	; 0x28
 80a193c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a1940:	080a364f 	.word	0x080a364f
 80a1944:	080a3648 	.word	0x080a3648

080a1948 <_ZN9TCPClient6statusEv>:
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a1948:	b510      	push	{r4, lr}
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a194a:	6943      	ldr	r3, [r0, #20]
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a194c:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a194e:	6818      	ldr	r0, [r3, #0]
 80a1950:	f7ff f8ba 	bl	80a0ac8 <socket_handle_valid>
  return rv;
}

uint8_t TCPClient::status()
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a1954:	b908      	cbnz	r0, 80a195a <_ZN9TCPClient6statusEv+0x12>
 80a1956:	2000      	movs	r0, #0
 80a1958:	bd10      	pop	{r4, pc}
 80a195a:	6920      	ldr	r0, [r4, #16]
 80a195c:	f7ff fc66 	bl	80a122c <_ZN5spark12NetworkClass4fromEm>
 80a1960:	6803      	ldr	r3, [r0, #0]
 80a1962:	68db      	ldr	r3, [r3, #12]
 80a1964:	4798      	blx	r3
 80a1966:	2800      	cmp	r0, #0
 80a1968:	d0f5      	beq.n	80a1956 <_ZN9TCPClient6statusEv+0xe>
 80a196a:	6963      	ldr	r3, [r4, #20]
 80a196c:	6818      	ldr	r0, [r3, #0]
 80a196e:	f7ff f8a3 	bl	80a0ab8 <socket_active_status>
 80a1972:	fab0 f080 	clz	r0, r0
 80a1976:	0940      	lsrs	r0, r0, #5
}
 80a1978:	bd10      	pop	{r4, pc}

080a197a <_ZN9TCPClient5writeEPKhjm>:
{
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
 80a197a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}

    size_t printNumber(unsigned long, uint8_t);
    size_t printNumber(unsigned long long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
 80a197e:	2500      	movs	r5, #0
 80a1980:	6045      	str	r5, [r0, #4]
 80a1982:	4604      	mov	r4, r0
 80a1984:	460e      	mov	r6, r1
 80a1986:	4617      	mov	r7, r2
 80a1988:	4698      	mov	r8, r3
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a198a:	f7ff ffdd 	bl	80a1948 <_ZN9TCPClient6statusEv>
 80a198e:	b160      	cbz	r0, 80a19aa <_ZN9TCPClient5writeEPKhjm+0x30>
 80a1990:	6960      	ldr	r0, [r4, #20]
 80a1992:	9501      	str	r5, [sp, #4]
 80a1994:	f8cd 8000 	str.w	r8, [sp]
 80a1998:	462b      	mov	r3, r5
 80a199a:	463a      	mov	r2, r7
 80a199c:	4631      	mov	r1, r6
 80a199e:	6800      	ldr	r0, [r0, #0]
 80a19a0:	f7ff f8c2 	bl	80a0b28 <socket_send_ex>
    if (ret < 0) {
 80a19a4:	2800      	cmp	r0, #0
 80a19a6:	da03      	bge.n	80a19b0 <_ZN9TCPClient5writeEPKhjm+0x36>
 80a19a8:	e001      	b.n	80a19ae <_ZN9TCPClient5writeEPKhjm+0x34>
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a19aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a19ae:	6060      	str	r0, [r4, #4]

    /*
     * FIXME: We should not be returning negative numbers here
     */
    return ret;
}
 80a19b0:	b002      	add	sp, #8
 80a19b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a19b6 <_ZN9TCPClient9connectedEv>:
  d_->remoteIP.clear();
  flush_buffer();
}

uint8_t TCPClient::connected()
{
 80a19b6:	b538      	push	{r3, r4, r5, lr}
 80a19b8:	4604      	mov	r4, r0
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a19ba:	f7ff ffc5 	bl	80a1948 <_ZN9TCPClient6statusEv>
 80a19be:	bb00      	cbnz	r0, 80a1a02 <_ZN9TCPClient9connectedEv+0x4c>
 80a19c0:	6963      	ldr	r3, [r4, #20]
 80a19c2:	f8b3 1086 	ldrh.w	r1, [r3, #134]	; 0x86
 80a19c6:	f8b3 2084 	ldrh.w	r2, [r3, #132]	; 0x84
 80a19ca:	4291      	cmp	r1, r2
 80a19cc:	d119      	bne.n	80a1a02 <_ZN9TCPClient9connectedEv+0x4c>

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a19ce:	6818      	ldr	r0, [r3, #0]
 80a19d0:	f7ff f87a 	bl	80a0ac8 <socket_handle_valid>
uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
 80a19d4:	b128      	cbz	r0, 80a19e2 <_ZN9TCPClient9connectedEv+0x2c>
 80a19d6:	6963      	ldr	r3, [r4, #20]
 80a19d8:	6818      	ldr	r0, [r3, #0]
 80a19da:	f7ff f86d 	bl	80a0ab8 <socket_active_status>
 80a19de:	2801      	cmp	r0, #1
 80a19e0:	d001      	beq.n	80a19e6 <_ZN9TCPClient9connectedEv+0x30>
}

uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a19e2:	2500      	movs	r5, #0
 80a19e4:	e00e      	b.n	80a1a04 <_ZN9TCPClient9connectedEv+0x4e>
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
    {
      rv = available(); // Try CC3000
 80a19e6:	6823      	ldr	r3, [r4, #0]
 80a19e8:	4620      	mov	r0, r4
 80a19ea:	691b      	ldr	r3, [r3, #16]
 80a19ec:	4798      	blx	r3
 80a19ee:	2800      	cmp	r0, #0
 80a19f0:	bf14      	ite	ne
 80a19f2:	2501      	movne	r5, #1
 80a19f4:	2500      	moveq	r5, #0
      if (!rv) {        // No more Data and CLOSE_WAIT
 80a19f6:	d105      	bne.n	80a1a04 <_ZN9TCPClient9connectedEv+0x4e>
          DEBUG("calling .stop(), no more data, in CLOSE_WAIT");
          stop();       // Close our side
 80a19f8:	6823      	ldr	r3, [r4, #0]
 80a19fa:	4620      	mov	r0, r4
 80a19fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a19fe:	4798      	blx	r3
 80a1a00:	e000      	b.n	80a1a04 <_ZN9TCPClient9connectedEv+0x4e>
 80a1a02:	2501      	movs	r5, #1
      }
  }
  return rv;
}
 80a1a04:	4628      	mov	r0, r5
 80a1a06:	bd38      	pop	{r3, r4, r5, pc}

080a1a08 <_ZN9TCPClientcvbEv>:
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
}

TCPClient::operator bool()
{
 80a1a08:	b508      	push	{r3, lr}
   return (status()!=0);
 80a1a0a:	f7ff ff9d 	bl	80a1948 <_ZN9TCPClient6statusEv>
}
 80a1a0e:	3000      	adds	r0, #0
 80a1a10:	bf18      	it	ne
 80a1a12:	2001      	movne	r0, #1
 80a1a14:	bd08      	pop	{r3, pc}

080a1a16 <_ZN9TCPClient4DataC1Em>:
IPAddress TCPClient::remoteIP()
{
    return d_->remoteIP;
}

TCPClient::Data::Data(sock_handle_t sock)
 80a1a16:	b510      	push	{r4, lr}
 80a1a18:	4604      	mov	r4, r0
        : sock(sock),
          offset(0),
          total(0) {
 80a1a1a:	2300      	movs	r3, #0
 80a1a1c:	6001      	str	r1, [r0, #0]
 80a1a1e:	f8a0 3084 	strh.w	r3, [r0, #132]	; 0x84
 80a1a22:	f8a0 3086 	strh.w	r3, [r0, #134]	; 0x86
 80a1a26:	3088      	adds	r0, #136	; 0x88
 80a1a28:	f7ff fa6a 	bl	80a0f00 <_ZN9IPAddressC1Ev>
}
 80a1a2c:	4620      	mov	r0, r4
 80a1a2e:	bd10      	pop	{r4, pc}

080a1a30 <_ZN9TCPClientC1Em>:
 80a1a30:	f44f 727a 	mov.w	r2, #1000	; 0x3e8

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a1a34:	b570      	push	{r4, r5, r6, lr}
 80a1a36:	6082      	str	r2, [r0, #8]
        d_(std::make_shared<Data>(sock))
 80a1a38:	4a14      	ldr	r2, [pc, #80]	; (80a1a8c <_ZN9TCPClientC1Em+0x5c>)
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a1a3a:	2300      	movs	r3, #0
 80a1a3c:	6043      	str	r3, [r0, #4]
 80a1a3e:	6002      	str	r2, [r0, #0]
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
 80a1a40:	6143      	str	r3, [r0, #20]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a1a42:	6183      	str	r3, [r0, #24]

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a1a44:	4604      	mov	r4, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a1a46:	20a0      	movs	r0, #160	; 0xa0
 80a1a48:	460e      	mov	r6, r1
 80a1a4a:	f7fe fb28 	bl	80a009e <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 80a1a4e:	4605      	mov	r5, r0
 80a1a50:	b110      	cbz	r0, 80a1a58 <_ZN9TCPClientC1Em+0x28>
 80a1a52:	4631      	mov	r1, r6
 80a1a54:	f7ff ffdf 	bl	80a1a16 <_ZN9TCPClient4DataC1Em>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a1a58:	2014      	movs	r0, #20
 80a1a5a:	f7fe fb20 	bl	80a009e <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 80a1a5e:	4603      	mov	r3, r0
 80a1a60:	b128      	cbz	r0, 80a1a6e <_ZN9TCPClientC1Em+0x3e>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a1a62:	2201      	movs	r2, #1
 80a1a64:	6042      	str	r2, [r0, #4]
 80a1a66:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a1a68:	4a09      	ldr	r2, [pc, #36]	; (80a1a90 <_ZN9TCPClientC1Em+0x60>)
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
 80a1a6a:	6105      	str	r5, [r0, #16]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a1a6c:	6002      	str	r2, [r0, #0]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a1a6e:	69a0      	ldr	r0, [r4, #24]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
 80a1a70:	6165      	str	r5, [r4, #20]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a1a72:	61a3      	str	r3, [r4, #24]
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a1a74:	b128      	cbz	r0, 80a1a82 <_ZN9TCPClientC1Em+0x52>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a1a76:	6843      	ldr	r3, [r0, #4]
 80a1a78:	3b01      	subs	r3, #1
 80a1a7a:	6043      	str	r3, [r0, #4]
 80a1a7c:	b90b      	cbnz	r3, 80a1a82 <_ZN9TCPClientC1Em+0x52>
 80a1a7e:	f7ff fe1b 	bl	80a16b8 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.28>
        d_(std::make_shared<Data>(sock))
{
  flush_buffer();
 80a1a82:	4620      	mov	r0, r4
 80a1a84:	f7ff fe92 	bl	80a17ac <_ZN9TCPClient12flush_bufferEv>
}
 80a1a88:	4620      	mov	r0, r4
 80a1a8a:	bd70      	pop	{r4, r5, r6, pc}
 80a1a8c:	080a3604 	.word	0x080a3604
 80a1a90:	080a35e8 	.word	0x080a35e8

080a1a94 <_ZN9TCPClientC1Ev>:
static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
}

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
 80a1a94:	b510      	push	{r4, lr}
 80a1a96:	4604      	mov	r4, r0
 80a1a98:	f7ff f83e 	bl	80a0b18 <socket_handle_invalid>
 80a1a9c:	4601      	mov	r1, r0
 80a1a9e:	4620      	mov	r0, r4
 80a1aa0:	f7ff ffc6 	bl	80a1a30 <_ZN9TCPClientC1Em>
{
}
 80a1aa4:	4620      	mov	r0, r4
 80a1aa6:	bd10      	pop	{r4, pc}

080a1aa8 <_ZN9TCPClient4DataD1Ev>:
        : sock(sock),
          offset(0),
          total(0) {
}

TCPClient::Data::~Data() {
 80a1aa8:	b510      	push	{r4, lr}
 80a1aaa:	4604      	mov	r4, r0
    if (socket_handle_valid(sock)) {
 80a1aac:	6800      	ldr	r0, [r0, #0]
 80a1aae:	f7ff f80b 	bl	80a0ac8 <socket_handle_valid>
 80a1ab2:	b110      	cbz	r0, 80a1aba <_ZN9TCPClient4DataD1Ev+0x12>
        socket_close(sock);
 80a1ab4:	6820      	ldr	r0, [r4, #0]
 80a1ab6:	f7ff f827 	bl	80a0b08 <socket_close>
    }
}
 80a1aba:	4620      	mov	r0, r4
 80a1abc:	bd10      	pop	{r4, pc}

080a1abe <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
 80a1abe:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
 80a1ac0:	6904      	ldr	r4, [r0, #16]
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void 
        destroy(_Up* __p) { __p->~_Up(); }
 80a1ac2:	4620      	mov	r0, r4
 80a1ac4:	f7ff fff0 	bl	80a1aa8 <_ZN9TCPClient4DataD1Ev>
      { __gd._M_ptr = nullptr; }

      /// Deallocate the owned pointer
      ~__allocated_ptr()
      {
	if (_M_ptr != nullptr)
 80a1ac8:	b124      	cbz	r4, 80a1ad4 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv+0x16>
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 80a1aca:	4620      	mov	r0, r4
 80a1acc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a1ad0:	f7fe bae7 	b.w	80a00a2 <_ZdlPv>
 80a1ad4:	bd10      	pop	{r4, pc}
	...

080a1ad8 <_ZN9TCPClient7connectEPKctm>:
  flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a1ad8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1adc:	461f      	mov	r7, r3
    stop();
 80a1ade:	6803      	ldr	r3, [r0, #0]
  flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a1ae0:	b08f      	sub	sp, #60	; 0x3c
    stop();
 80a1ae2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  flush_buffer();
}

// return 0 on error, 1 on success
int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a1ae4:	4606      	mov	r6, r0
 80a1ae6:	460d      	mov	r5, r1
 80a1ae8:	4690      	mov	r8, r2
    stop();
 80a1aea:	4798      	blx	r3
    if (Network.ready())
 80a1aec:	4813      	ldr	r0, [pc, #76]	; (80a1b3c <_ZN9TCPClient7connectEPKctm+0x64>)
 80a1aee:	f7ff fb50 	bl	80a1192 <_ZN5spark12NetworkClass5readyEv>
 80a1af2:	b300      	cbz	r0, 80a1b36 <_ZN9TCPClient7connectEPKctm+0x5e>
    {
        IPAddress ip_addr;
 80a1af4:	a802      	add	r0, sp, #8
 80a1af6:	f7ff fa03 	bl	80a0f00 <_ZN9IPAddressC1Ev>
        if (inet_gethostbyname(host, strlen(host), ip_addr, nif, NULL) == 0) {
 80a1afa:	4628      	mov	r0, r5
 80a1afc:	f001 fbe2 	bl	80a32c4 <strlen>
 80a1b00:	2400      	movs	r4, #0
 80a1b02:	b281      	uxth	r1, r0
 80a1b04:	9400      	str	r4, [sp, #0]
 80a1b06:	463b      	mov	r3, r7
 80a1b08:	aa03      	add	r2, sp, #12
 80a1b0a:	4628      	mov	r0, r5
 80a1b0c:	f7ff f88c 	bl	80a0c28 <inet_gethostbyname>
 80a1b10:	b980      	cbnz	r0, 80a1b34 <_ZN9TCPClient7connectEPKctm+0x5c>
            return connect(ip_addr, port, nif);
 80a1b12:	6833      	ldr	r3, [r6, #0]
 80a1b14:	ad09      	add	r5, sp, #36	; 0x24
 80a1b16:	f8d3 9020 	ldr.w	r9, [r3, #32]
 80a1b1a:	4b09      	ldr	r3, [pc, #36]	; (80a1b40 <_ZN9TCPClient7connectEPKctm+0x68>)
 80a1b1c:	ac03      	add	r4, sp, #12
 80a1b1e:	9308      	str	r3, [sp, #32]
 80a1b20:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a1b22:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a1b24:	6823      	ldr	r3, [r4, #0]
 80a1b26:	4642      	mov	r2, r8
 80a1b28:	702b      	strb	r3, [r5, #0]
 80a1b2a:	a908      	add	r1, sp, #32
 80a1b2c:	463b      	mov	r3, r7
 80a1b2e:	4630      	mov	r0, r6
 80a1b30:	47c8      	blx	r9
 80a1b32:	e000      	b.n	80a1b36 <_ZN9TCPClient7connectEPKctm+0x5e>
        } else {
            DEBUG("unable to get IP for hostname");
        }
    }

    return 0; // error, could not connect
 80a1b34:	4620      	mov	r0, r4
}
 80a1b36:	b00f      	add	sp, #60	; 0x3c
 80a1b38:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a1b3c:	200000bc 	.word	0x200000bc
 80a1b40:	080a3474 	.word	0x080a3474

080a1b44 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a1b44:	4b02      	ldr	r3, [pc, #8]	; (80a1b50 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a1b46:	681a      	ldr	r2, [r3, #0]
 80a1b48:	4b02      	ldr	r3, [pc, #8]	; (80a1b54 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a1b4a:	601a      	str	r2, [r3, #0]
 80a1b4c:	4770      	bx	lr
 80a1b4e:	bf00      	nop
 80a1b50:	20000008 	.word	0x20000008
 80a1b54:	200000e0 	.word	0x200000e0

080a1b58 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a1b58:	4770      	bx	lr

080a1b5a <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a1b5a:	7441      	strb	r1, [r0, #17]
 80a1b5c:	4770      	bx	lr

080a1b5e <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
 80a1b5e:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data_For_Write(_serial));
 80a1b60:	7c00      	ldrb	r0, [r0, #16]
 80a1b62:	f7ff f819 	bl	80a0b98 <HAL_USART_Available_Data_For_Write>
}
 80a1b66:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1b6a:	bd08      	pop	{r3, pc}

080a1b6c <_ZN11USARTSerial9availableEv>:

int USARTSerial::available(void)
{
 80a1b6c:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USART_Available_Data(_serial));
 80a1b6e:	7c00      	ldrb	r0, [r0, #16]
 80a1b70:	f7fe fff2 	bl	80a0b58 <HAL_USART_Available_Data>
}
 80a1b74:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1b78:	bd08      	pop	{r3, pc}

080a1b7a <_ZN11USARTSerial4peekEv>:

int USARTSerial::peek(void)
{
 80a1b7a:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Peek_Data(_serial));
 80a1b7c:	7c00      	ldrb	r0, [r0, #16]
 80a1b7e:	f7fe fffb 	bl	80a0b78 <HAL_USART_Peek_Data>
}
 80a1b82:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1b86:	bf28      	it	cs
 80a1b88:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1b8c:	bd08      	pop	{r3, pc}

080a1b8e <_ZN11USARTSerial4readEv>:

int USARTSerial::read(void)
{
 80a1b8e:	b508      	push	{r3, lr}
  return std::max(-1, (int)HAL_USART_Read_Data(_serial));
 80a1b90:	7c00      	ldrb	r0, [r0, #16]
 80a1b92:	f7fe ffe9 	bl	80a0b68 <HAL_USART_Read_Data>
}
 80a1b96:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1b9a:	bf28      	it	cs
 80a1b9c:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1ba0:	bd08      	pop	{r3, pc}

080a1ba2 <_ZN11USARTSerial5flushEv>:

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a1ba2:	7c00      	ldrb	r0, [r0, #16]
 80a1ba4:	f7fe bff0 	b.w	80a0b88 <HAL_USART_Flush_Data>

080a1ba8 <_ZN11USARTSerialD0Ev>:
 80a1ba8:	b510      	push	{r4, lr}
 80a1baa:	4604      	mov	r4, r0
 80a1bac:	2114      	movs	r1, #20
 80a1bae:	f000 fa7c 	bl	80a20aa <_ZdlPvj>
 80a1bb2:	4620      	mov	r0, r4
 80a1bb4:	bd10      	pop	{r4, pc}

080a1bb6 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a1bb6:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a1bb8:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a1bba:	4604      	mov	r4, r0
 80a1bbc:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a1bbe:	b925      	cbnz	r5, 80a1bca <_ZN11USARTSerial5writeEh+0x14>
 80a1bc0:	7c00      	ldrb	r0, [r0, #16]
 80a1bc2:	f7fe ffe9 	bl	80a0b98 <HAL_USART_Available_Data_For_Write>
 80a1bc6:	2800      	cmp	r0, #0
 80a1bc8:	dd05      	ble.n	80a1bd6 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a1bca:	4631      	mov	r1, r6
 80a1bcc:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a1bce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a1bd2:	f7fe bfb9 	b.w	80a0b48 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a1bd6:	4628      	mov	r0, r5
 80a1bd8:	bd70      	pop	{r4, r5, r6, pc}
	...

080a1bdc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a1bdc:	b510      	push	{r4, lr}
 80a1bde:	4604      	mov	r4, r0
 80a1be0:	4608      	mov	r0, r1
 80a1be2:	4611      	mov	r1, r2
 80a1be4:	2200      	movs	r2, #0
 80a1be6:	6062      	str	r2, [r4, #4]
 80a1be8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a1bec:	60a2      	str	r2, [r4, #8]
 80a1bee:	4a05      	ldr	r2, [pc, #20]	; (80a1c04 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a1bf0:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a1bf2:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a1bf4:	2201      	movs	r2, #1
 80a1bf6:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a1bf8:	461a      	mov	r2, r3
 80a1bfa:	f7fe ff9d 	bl	80a0b38 <HAL_USART_Init>
}
 80a1bfe:	4620      	mov	r0, r4
 80a1c00:	bd10      	pop	{r4, pc}
 80a1c02:	bf00      	nop
 80a1c04:	080a3694 	.word	0x080a3694

080a1c08 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a1c08:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a1c0a:	4d0c      	ldr	r5, [pc, #48]	; (80a1c3c <_Z22__fetch_global_Serial1v+0x34>)
 80a1c0c:	6829      	ldr	r1, [r5, #0]
 80a1c0e:	f011 0401 	ands.w	r4, r1, #1
 80a1c12:	d111      	bne.n	80a1c38 <_Z22__fetch_global_Serial1v+0x30>
 80a1c14:	4628      	mov	r0, r5
 80a1c16:	f7fe fa46 	bl	80a00a6 <__cxa_guard_acquire>
 80a1c1a:	b168      	cbz	r0, 80a1c38 <_Z22__fetch_global_Serial1v+0x30>
 80a1c1c:	4a08      	ldr	r2, [pc, #32]	; (80a1c40 <_Z22__fetch_global_Serial1v+0x38>)
 80a1c1e:	4621      	mov	r1, r4
 80a1c20:	4b08      	ldr	r3, [pc, #32]	; (80a1c44 <_Z22__fetch_global_Serial1v+0x3c>)
 80a1c22:	4809      	ldr	r0, [pc, #36]	; (80a1c48 <_Z22__fetch_global_Serial1v+0x40>)
 80a1c24:	f7ff ffda 	bl	80a1bdc <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a1c28:	4628      	mov	r0, r5
 80a1c2a:	f7fe fa41 	bl	80a00b0 <__cxa_guard_release>
 80a1c2e:	4a07      	ldr	r2, [pc, #28]	; (80a1c4c <_Z22__fetch_global_Serial1v+0x44>)
 80a1c30:	4907      	ldr	r1, [pc, #28]	; (80a1c50 <_Z22__fetch_global_Serial1v+0x48>)
 80a1c32:	4805      	ldr	r0, [pc, #20]	; (80a1c48 <_Z22__fetch_global_Serial1v+0x40>)
 80a1c34:	f000 fa34 	bl	80a20a0 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a1c38:	4803      	ldr	r0, [pc, #12]	; (80a1c48 <_Z22__fetch_global_Serial1v+0x40>)
 80a1c3a:	bd38      	pop	{r3, r4, r5, pc}
 80a1c3c:	2000017c 	.word	0x2000017c
 80a1c40:	20000180 	.word	0x20000180
 80a1c44:	200000f8 	.word	0x200000f8
 80a1c48:	200000e4 	.word	0x200000e4
 80a1c4c:	20000070 	.word	0x20000070
 80a1c50:	080a1b59 	.word	0x080a1b59

080a1c54 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a1c54:	7441      	strb	r1, [r0, #17]
 80a1c56:	4770      	bx	lr

080a1c58 <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a1c58:	4770      	bx	lr

080a1c5a <_ZN9USBSerial4readEv>:
}


// Read data from buffer
int USBSerial::read()
{
 80a1c5a:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a1c5c:	2100      	movs	r1, #0
 80a1c5e:	7c00      	ldrb	r0, [r0, #16]
 80a1c60:	f7fe ffc2 	bl	80a0be8 <HAL_USB_USART_Receive_Data>
}
 80a1c64:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1c68:	bf28      	it	cs
 80a1c6a:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1c6e:	bd08      	pop	{r3, pc}

080a1c70 <_ZN9USBSerial4peekEv>:
{
  _blocking = block;
}

int USBSerial::peek()
{
 80a1c70:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a1c72:	2101      	movs	r1, #1
 80a1c74:	7c00      	ldrb	r0, [r0, #16]
 80a1c76:	f7fe ffb7 	bl	80a0be8 <HAL_USB_USART_Receive_Data>
}
 80a1c7a:	ea30 0020 	bics.w	r0, r0, r0, asr #32
 80a1c7e:	bf28      	it	cs
 80a1c80:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
 80a1c84:	bd08      	pop	{r3, pc}

080a1c86 <_ZN9USBSerial17availableForWriteEv>:
{
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
}

int USBSerial::availableForWrite()
{
 80a1c86:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a1c88:	7c00      	ldrb	r0, [r0, #16]
 80a1c8a:	f7fe ffa5 	bl	80a0bd8 <HAL_USB_USART_Available_Data_For_Write>
}
 80a1c8e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1c92:	bd08      	pop	{r3, pc}

080a1c94 <_ZN9USBSerial9availableEv>:

int USBSerial::available()
{
 80a1c94:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a1c96:	7c00      	ldrb	r0, [r0, #16]
 80a1c98:	f7fe ff96 	bl	80a0bc8 <HAL_USB_USART_Available_Data>
}
 80a1c9c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a1ca0:	bd08      	pop	{r3, pc}

080a1ca2 <_ZN9USBSerial5flushEv>:
  return 0;
}

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a1ca2:	7c00      	ldrb	r0, [r0, #16]
 80a1ca4:	f7fe bfb0 	b.w	80a0c08 <HAL_USB_USART_Flush_Data>

080a1ca8 <_ZN9USBSerialD0Ev>:
 80a1ca8:	b510      	push	{r4, lr}
 80a1caa:	4604      	mov	r4, r0
 80a1cac:	2114      	movs	r1, #20
 80a1cae:	f000 f9fc 	bl	80a20aa <_ZdlPvj>
 80a1cb2:	4620      	mov	r0, r4
 80a1cb4:	bd10      	pop	{r4, pc}

080a1cb6 <_ZN9USBSerial5writeEh>:
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a1cb6:	b538      	push	{r3, r4, r5, lr}
 80a1cb8:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a1cba:	7c00      	ldrb	r0, [r0, #16]
{
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
}

size_t USBSerial::write(uint8_t byte)
{
 80a1cbc:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a1cbe:	f7fe ff8b 	bl	80a0bd8 <HAL_USB_USART_Available_Data_For_Write>
 80a1cc2:	2800      	cmp	r0, #0
 80a1cc4:	dc01      	bgt.n	80a1cca <_ZN9USBSerial5writeEh+0x14>
 80a1cc6:	7c60      	ldrb	r0, [r4, #17]
 80a1cc8:	b128      	cbz	r0, 80a1cd6 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a1cca:	4629      	mov	r1, r5
 80a1ccc:	7c20      	ldrb	r0, [r4, #16]
 80a1cce:	f7fe ff93 	bl	80a0bf8 <HAL_USB_USART_Send_Data>
 80a1cd2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  }
  return 0;
}
 80a1cd6:	bd38      	pop	{r3, r4, r5, pc}

080a1cd8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a1cd8:	b510      	push	{r4, lr}
 80a1cda:	4604      	mov	r4, r0
 80a1cdc:	2300      	movs	r3, #0
 80a1cde:	6063      	str	r3, [r4, #4]
 80a1ce0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a1ce4:	60a3      	str	r3, [r4, #8]
 80a1ce6:	4b05      	ldr	r3, [pc, #20]	; (80a1cfc <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a1ce8:	4608      	mov	r0, r1
 80a1cea:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a1cec:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a1cee:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a1cf0:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a1cf2:	4611      	mov	r1, r2
 80a1cf4:	f7fe ff58 	bl	80a0ba8 <HAL_USB_USART_Init>
}
 80a1cf8:	4620      	mov	r0, r4
 80a1cfa:	bd10      	pop	{r4, pc}
 80a1cfc:	080a36c4 	.word	0x080a36c4

080a1d00 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a1d00:	2200      	movs	r2, #0
 80a1d02:	7c00      	ldrb	r0, [r0, #16]
 80a1d04:	f7fe bf58 	b.w	80a0bb8 <HAL_USB_USART_Begin>

080a1d08 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a1d08:	b510      	push	{r4, lr}
 80a1d0a:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1d0c:	2214      	movs	r2, #20
 80a1d0e:	2100      	movs	r1, #0
 80a1d10:	f001 faa7 	bl	80a3262 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1d14:	4b05      	ldr	r3, [pc, #20]	; (80a1d2c <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1d16:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1d18:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a1d1a:	4b05      	ldr	r3, [pc, #20]	; (80a1d30 <_Z19acquireSerialBufferv+0x28>)
 80a1d1c:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a1d1e:	f240 1301 	movw	r3, #257	; 0x101
 80a1d22:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1d24:	2381      	movs	r3, #129	; 0x81
 80a1d26:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1d28:	bd10      	pop	{r4, pc}
 80a1d2a:	bf00      	nop
 80a1d2c:	20000289 	.word	0x20000289
 80a1d30:	20000208 	.word	0x20000208

080a1d34 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a1d34:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a1d36:	4d0e      	ldr	r5, [pc, #56]	; (80a1d70 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a1d38:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a1d3a:	a801      	add	r0, sp, #4
 80a1d3c:	f7ff ffe4 	bl	80a1d08 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a1d40:	6829      	ldr	r1, [r5, #0]
 80a1d42:	f011 0401 	ands.w	r4, r1, #1
 80a1d46:	d110      	bne.n	80a1d6a <_Z16_fetch_usbserialv+0x36>
 80a1d48:	4628      	mov	r0, r5
 80a1d4a:	f7fe f9ac 	bl	80a00a6 <__cxa_guard_acquire>
 80a1d4e:	b160      	cbz	r0, 80a1d6a <_Z16_fetch_usbserialv+0x36>
 80a1d50:	aa01      	add	r2, sp, #4
 80a1d52:	4621      	mov	r1, r4
 80a1d54:	4807      	ldr	r0, [pc, #28]	; (80a1d74 <_Z16_fetch_usbserialv+0x40>)
 80a1d56:	f7ff ffbf 	bl	80a1cd8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a1d5a:	4628      	mov	r0, r5
 80a1d5c:	f7fe f9a8 	bl	80a00b0 <__cxa_guard_release>
 80a1d60:	4a05      	ldr	r2, [pc, #20]	; (80a1d78 <_Z16_fetch_usbserialv+0x44>)
 80a1d62:	4906      	ldr	r1, [pc, #24]	; (80a1d7c <_Z16_fetch_usbserialv+0x48>)
 80a1d64:	4803      	ldr	r0, [pc, #12]	; (80a1d74 <_Z16_fetch_usbserialv+0x40>)
 80a1d66:	f000 f99b 	bl	80a20a0 <__aeabi_atexit>
	return _usbserial;
}
 80a1d6a:	4802      	ldr	r0, [pc, #8]	; (80a1d74 <_Z16_fetch_usbserialv+0x40>)
 80a1d6c:	b007      	add	sp, #28
 80a1d6e:	bd30      	pop	{r4, r5, pc}
 80a1d70:	20000204 	.word	0x20000204
 80a1d74:	2000038c 	.word	0x2000038c
 80a1d78:	20000070 	.word	0x20000070
 80a1d7c:	080a1c59 	.word	0x080a1c59

080a1d80 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a1d80:	b510      	push	{r4, lr}
 80a1d82:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1d84:	2214      	movs	r2, #20
 80a1d86:	2100      	movs	r1, #0
 80a1d88:	f001 fa6b 	bl	80a3262 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a1d8c:	4b05      	ldr	r3, [pc, #20]	; (80a1da4 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1d8e:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a1d90:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a1d92:	4b05      	ldr	r3, [pc, #20]	; (80a1da8 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a1d94:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a1d96:	f240 1301 	movw	r3, #257	; 0x101
 80a1d9a:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1d9c:	2381      	movs	r3, #129	; 0x81
 80a1d9e:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1da0:	bd10      	pop	{r4, pc}
 80a1da2:	bf00      	nop
 80a1da4:	2000043c 	.word	0x2000043c
 80a1da8:	200003a4 	.word	0x200003a4

080a1dac <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a1dac:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1dae:	4c0e      	ldr	r4, [pc, #56]	; (80a1de8 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a1db0:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a1db2:	a801      	add	r0, sp, #4
 80a1db4:	f7ff ffe4 	bl	80a1d80 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1db8:	6823      	ldr	r3, [r4, #0]
 80a1dba:	07db      	lsls	r3, r3, #31
 80a1dbc:	d410      	bmi.n	80a1de0 <_Z17_fetch_usbserial1v+0x34>
 80a1dbe:	4620      	mov	r0, r4
 80a1dc0:	f7fe f971 	bl	80a00a6 <__cxa_guard_acquire>
 80a1dc4:	b160      	cbz	r0, 80a1de0 <_Z17_fetch_usbserial1v+0x34>
 80a1dc6:	aa01      	add	r2, sp, #4
 80a1dc8:	2101      	movs	r1, #1
 80a1dca:	4808      	ldr	r0, [pc, #32]	; (80a1dec <_Z17_fetch_usbserial1v+0x40>)
 80a1dcc:	f7ff ff84 	bl	80a1cd8 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a1dd0:	4620      	mov	r0, r4
 80a1dd2:	f7fe f96d 	bl	80a00b0 <__cxa_guard_release>
 80a1dd6:	4a06      	ldr	r2, [pc, #24]	; (80a1df0 <_Z17_fetch_usbserial1v+0x44>)
 80a1dd8:	4906      	ldr	r1, [pc, #24]	; (80a1df4 <_Z17_fetch_usbserial1v+0x48>)
 80a1dda:	4804      	ldr	r0, [pc, #16]	; (80a1dec <_Z17_fetch_usbserial1v+0x40>)
 80a1ddc:	f000 f960 	bl	80a20a0 <__aeabi_atexit>
  return _usbserial1;
}
 80a1de0:	4802      	ldr	r0, [pc, #8]	; (80a1dec <_Z17_fetch_usbserial1v+0x40>)
 80a1de2:	b006      	add	sp, #24
 80a1de4:	bd10      	pop	{r4, pc}
 80a1de6:	bf00      	nop
 80a1de8:	200003a0 	.word	0x200003a0
 80a1dec:	20000428 	.word	0x20000428
 80a1df0:	20000070 	.word	0x20000070
 80a1df4:	080a1c59 	.word	0x080a1c59

080a1df8 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a1df8:	2200      	movs	r2, #0
 80a1dfa:	4611      	mov	r1, r2
 80a1dfc:	6840      	ldr	r0, [r0, #4]
 80a1dfe:	f7fe bf67 	b.w	80a0cd0 <network_ready>

080a1e02 <_ZN5spark9WiFiClass7resolveEPKc>:
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a1e02:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1e04:	4616      	mov	r6, r2
 80a1e06:	b089      	sub	sp, #36	; 0x24
    {
        HAL_IPAddress ip = {};
 80a1e08:	2211      	movs	r2, #17
    WLanSelectAntenna_TypeDef getAntenna() {
        return wlan_get_antenna(nullptr);
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
 80a1e0a:	460f      	mov	r7, r1
 80a1e0c:	4604      	mov	r4, r0
    {
        HAL_IPAddress ip = {};
 80a1e0e:	2100      	movs	r1, #0
 80a1e10:	a803      	add	r0, sp, #12
 80a1e12:	f001 fa26 	bl	80a3262 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a1e16:	4630      	mov	r0, r6
 80a1e18:	f001 fa54 	bl	80a32c4 <strlen>
 80a1e1c:	2500      	movs	r5, #0
 80a1e1e:	9500      	str	r5, [sp, #0]
 80a1e20:	b281      	uxth	r1, r0
 80a1e22:	687b      	ldr	r3, [r7, #4]
 80a1e24:	aa03      	add	r2, sp, #12
 80a1e26:	4630      	mov	r0, r6
 80a1e28:	f7fe fefe 	bl	80a0c28 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a1e2c:	b120      	cbz	r0, 80a1e38 <_ZN5spark9WiFiClass7resolveEPKc+0x36>
 80a1e2e:	4629      	mov	r1, r5
 80a1e30:	4620      	mov	r0, r4
 80a1e32:	f7ff f885 	bl	80a0f40 <_ZN9IPAddressC1Em>
 80a1e36:	e003      	b.n	80a1e40 <_ZN5spark9WiFiClass7resolveEPKc+0x3e>
 80a1e38:	a903      	add	r1, sp, #12
 80a1e3a:	4620      	mov	r0, r4
 80a1e3c:	f7ff f86e 	bl	80a0f1c <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    }
 80a1e40:	4620      	mov	r0, r4
 80a1e42:	b009      	add	sp, #36	; 0x24
 80a1e44:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a1e46 <_ZN5spark9WiFiClass9listeningEv>:
    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
    }

    bool listening(void) {
        return network_listening(*this, 0, NULL);
 80a1e46:	2200      	movs	r2, #0
 80a1e48:	4611      	mov	r1, r2
 80a1e4a:	6840      	ldr	r0, [r0, #4]
 80a1e4c:	f7fe bf60 	b.w	80a0d10 <network_listening>

080a1e50 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        network_set_listen_timeout(*this, timeout, NULL);
    }
    inline void setListenTimeout(std::chrono::seconds s) { setListenTimeout(s.count()); }

    uint16_t getListenTimeout(void) {
        return network_get_listen_timeout(*this, 0, NULL);
 80a1e50:	2200      	movs	r2, #0
 80a1e52:	4611      	mov	r1, r2
 80a1e54:	6840      	ldr	r0, [r0, #4]
 80a1e56:	f7fe bf73 	b.w	80a0d40 <network_get_listen_timeout>

080a1e5a <_ZN5spark9WiFiClass16setListenTimeoutEt>:
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
    }

    void setListenTimeout(uint16_t timeout) {
        network_set_listen_timeout(*this, timeout, NULL);
 80a1e5a:	2200      	movs	r2, #0
 80a1e5c:	6840      	ldr	r0, [r0, #4]
 80a1e5e:	f7fe bf67 	b.w	80a0d30 <network_set_listen_timeout>

080a1e62 <_ZN5spark9WiFiClass6listenEb>:
    void off(void) {
        network_off(*this, 0, 0, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
 80a1e62:	2200      	movs	r2, #0
 80a1e64:	f081 0101 	eor.w	r1, r1, #1
 80a1e68:	6840      	ldr	r0, [r0, #4]
 80a1e6a:	f7fe bf49 	b.w	80a0d00 <network_listen>

080a1e6e <_ZN5spark9WiFiClass3offEv>:
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
 80a1e6e:	2300      	movs	r3, #0
 80a1e70:	461a      	mov	r2, r3
 80a1e72:	4619      	mov	r1, r3
 80a1e74:	6840      	ldr	r0, [r0, #4]
 80a1e76:	f7fe bf3b 	b.w	80a0cf0 <network_off>

080a1e7a <_ZN5spark9WiFiClass2onEv>:
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a1e7a:	2300      	movs	r3, #0
 80a1e7c:	461a      	mov	r2, r3
 80a1e7e:	4619      	mov	r1, r3
 80a1e80:	6840      	ldr	r0, [r0, #4]
 80a1e82:	f7fe bf2d 	b.w	80a0ce0 <network_on>

080a1e86 <_ZN5spark9WiFiClass10connectingEv>:
    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
    }

    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
 80a1e86:	2200      	movs	r2, #0
 80a1e88:	4611      	mov	r1, r2
 80a1e8a:	6840      	ldr	r0, [r0, #4]
 80a1e8c:	f7fe bf10 	b.w	80a0cb0 <network_connecting>

080a1e90 <_ZN5spark9WiFiClass10disconnectEv>:
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a1e90:	2200      	movs	r2, #0
 80a1e92:	2102      	movs	r1, #2
 80a1e94:	6840      	ldr	r0, [r0, #4]
 80a1e96:	f7fe bf13 	b.w	80a0cc0 <network_disconnect>

080a1e9a <_ZN5spark9WiFiClass7connectEj>:
    uint32_t ping(IPAddress remoteIP, uint8_t nTries) {
        return inet_ping(&remoteIP.raw(), *this, nTries, NULL);
    }

    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
 80a1e9a:	2300      	movs	r3, #0
 80a1e9c:	461a      	mov	r2, r3
 80a1e9e:	6840      	ldr	r0, [r0, #4]
 80a1ea0:	f7fe befe 	b.w	80a0ca0 <network_connect>

080a1ea4 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
 80a1ea4:	4b02      	ldr	r3, [pc, #8]	; (80a1eb0 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a1ea6:	2204      	movs	r2, #4
 80a1ea8:	605a      	str	r2, [r3, #4]
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() :
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a1eaa:	4a02      	ldr	r2, [pc, #8]	; (80a1eb4 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a1eac:	601a      	str	r2, [r3, #0]
 80a1eae:	4770      	bx	lr
 80a1eb0:	20000540 	.word	0x20000540
 80a1eb4:	080a36f4 	.word	0x080a36f4

080a1eb8 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a1eb8:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1eba:	4b14      	ldr	r3, [pc, #80]	; (80a1f0c <serialEventRun+0x54>)
 80a1ebc:	b133      	cbz	r3, 80a1ecc <serialEventRun+0x14>
 80a1ebe:	f7ff ff39 	bl	80a1d34 <_Z16_fetch_usbserialv>
 80a1ec2:	6803      	ldr	r3, [r0, #0]
 80a1ec4:	691b      	ldr	r3, [r3, #16]
 80a1ec6:	4798      	blx	r3
 80a1ec8:	2800      	cmp	r0, #0
 80a1eca:	dc16      	bgt.n	80a1efa <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1ecc:	4b10      	ldr	r3, [pc, #64]	; (80a1f10 <serialEventRun+0x58>)
 80a1ece:	b133      	cbz	r3, 80a1ede <serialEventRun+0x26>
 80a1ed0:	f7ff fe9a 	bl	80a1c08 <_Z22__fetch_global_Serial1v>
 80a1ed4:	6803      	ldr	r3, [r0, #0]
 80a1ed6:	691b      	ldr	r3, [r3, #16]
 80a1ed8:	4798      	blx	r3
 80a1eda:	2800      	cmp	r0, #0
 80a1edc:	dc10      	bgt.n	80a1f00 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1ede:	4b0d      	ldr	r3, [pc, #52]	; (80a1f14 <serialEventRun+0x5c>)
 80a1ee0:	b10b      	cbz	r3, 80a1ee6 <serialEventRun+0x2e>
 80a1ee2:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a1ee6:	4b0c      	ldr	r3, [pc, #48]	; (80a1f18 <serialEventRun+0x60>)
 80a1ee8:	b17b      	cbz	r3, 80a1f0a <serialEventRun+0x52>
 80a1eea:	f7ff ff5f 	bl	80a1dac <_Z17_fetch_usbserial1v>
 80a1eee:	6803      	ldr	r3, [r0, #0]
 80a1ef0:	691b      	ldr	r3, [r3, #16]
 80a1ef2:	4798      	blx	r3
 80a1ef4:	2800      	cmp	r0, #0
 80a1ef6:	dc06      	bgt.n	80a1f06 <serialEventRun+0x4e>
 80a1ef8:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a1efa:	f3af 8000 	nop.w
 80a1efe:	e7e5      	b.n	80a1ecc <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a1f00:	f3af 8000 	nop.w
 80a1f04:	e7eb      	b.n	80a1ede <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a1f06:	f3af 8000 	nop.w
 80a1f0a:	bd08      	pop	{r3, pc}
	...

080a1f1c <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a1f1c:	b508      	push	{r3, lr}
	serialEventRun();
 80a1f1e:	f7ff ffcb 	bl	80a1eb8 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a1f22:	f7fe fd65 	bl	80a09f0 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a1f26:	4b01      	ldr	r3, [pc, #4]	; (80a1f2c <_post_loop+0x10>)
 80a1f28:	6018      	str	r0, [r3, #0]
 80a1f2a:	bd08      	pop	{r3, pc}
 80a1f2c:	20000550 	.word	0x20000550

080a1f30 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a1f30:	4802      	ldr	r0, [pc, #8]	; (80a1f3c <_Z33system_initialize_user_backup_ramv+0xc>)
 80a1f32:	4a03      	ldr	r2, [pc, #12]	; (80a1f40 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a1f34:	4903      	ldr	r1, [pc, #12]	; (80a1f44 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a1f36:	1a12      	subs	r2, r2, r0
 80a1f38:	f001 b988 	b.w	80a324c <memcpy>
 80a1f3c:	40024000 	.word	0x40024000
 80a1f40:	40024004 	.word	0x40024004
 80a1f44:	080a37c0 	.word	0x080a37c0

080a1f48 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a1f48:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1f4a:	2300      	movs	r3, #0
 80a1f4c:	9300      	str	r3, [sp, #0]
 80a1f4e:	461a      	mov	r2, r3
 80a1f50:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1f54:	f7fe fe92 	bl	80a0c7c <system_ctrl_set_result>
}
 80a1f58:	b003      	add	sp, #12
 80a1f5a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a1f60 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a1f60:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a1f62:	8843      	ldrh	r3, [r0, #2]
 80a1f64:	2b0a      	cmp	r3, #10
 80a1f66:	d008      	beq.n	80a1f7a <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a1f68:	2b50      	cmp	r3, #80	; 0x50
 80a1f6a:	d109      	bne.n	80a1f80 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a1f6c:	4b09      	ldr	r3, [pc, #36]	; (80a1f94 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a1f6e:	681b      	ldr	r3, [r3, #0]
 80a1f70:	b13b      	cbz	r3, 80a1f82 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a1f72:	b003      	add	sp, #12
 80a1f74:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a1f78:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a1f7a:	f7ff ffe5 	bl	80a1f48 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a1f7e:	e006      	b.n	80a1f8e <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a1f80:	2300      	movs	r3, #0
 80a1f82:	9300      	str	r3, [sp, #0]
 80a1f84:	461a      	mov	r2, r3
 80a1f86:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a1f8a:	f7fe fe77 	bl	80a0c7c <system_ctrl_set_result>
        break;
    }
}
 80a1f8e:	b003      	add	sp, #12
 80a1f90:	f85d fb04 	ldr.w	pc, [sp], #4
 80a1f94:	20000548 	.word	0x20000548

080a1f98 <module_user_init_hook>:

void module_user_init_hook()
{
 80a1f98:	b538      	push	{r3, r4, r5, lr}
#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a1f9a:	4c10      	ldr	r4, [pc, #64]	; (80a1fdc <module_user_init_hook+0x44>)
 80a1f9c:	4d10      	ldr	r5, [pc, #64]	; (80a1fe0 <module_user_init_hook+0x48>)
 80a1f9e:	6823      	ldr	r3, [r4, #0]
 80a1fa0:	42ab      	cmp	r3, r5
 80a1fa2:	4b10      	ldr	r3, [pc, #64]	; (80a1fe4 <module_user_init_hook+0x4c>)
 80a1fa4:	bf0c      	ite	eq
 80a1fa6:	2201      	moveq	r2, #1
 80a1fa8:	2200      	movne	r2, #0
 80a1faa:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a1fac:	d002      	beq.n	80a1fb4 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a1fae:	f7ff ffbf 	bl	80a1f30 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a1fb2:	6025      	str	r5, [r4, #0]
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a1fb4:	f7fe fd14 	bl	80a09e0 <HAL_RNG_GetRandomNumber>
 80a1fb8:	4604      	mov	r4, r0
    srand(seed);
 80a1fba:	f001 f95b 	bl	80a3274 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a1fbe:	4b0a      	ldr	r3, [pc, #40]	; (80a1fe8 <module_user_init_hook+0x50>)
 80a1fc0:	b113      	cbz	r3, 80a1fc8 <module_user_init_hook+0x30>
        random_seed_from_cloud(seed);
 80a1fc2:	4620      	mov	r0, r4
 80a1fc4:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a1fc8:	2100      	movs	r1, #0
 80a1fca:	4807      	ldr	r0, [pc, #28]	; (80a1fe8 <module_user_init_hook+0x50>)
 80a1fcc:	f7fe fe60 	bl	80a0c90 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a1fd0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a1fd4:	2100      	movs	r1, #0
 80a1fd6:	4805      	ldr	r0, [pc, #20]	; (80a1fec <module_user_init_hook+0x54>)
 80a1fd8:	f7fe be46 	b.w	80a0c68 <system_ctrl_set_app_request_handler>
 80a1fdc:	40024000 	.word	0x40024000
 80a1fe0:	9a271c1e 	.word	0x9a271c1e
 80a1fe4:	2000054c 	.word	0x2000054c
 80a1fe8:	00000000 	.word	0x00000000
 80a1fec:	080a1f61 	.word	0x080a1f61

080a1ff0 <_Z17acquireWireBufferv>:
}

} // anonymous

HAL_I2C_Config __attribute__((weak)) acquireWireBuffer()
{
 80a1ff0:	b570      	push	{r4, r5, r6, lr}
 80a1ff2:	4604      	mov	r4, r0
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a1ff4:	2514      	movs	r5, #20
 80a1ff6:	462a      	mov	r2, r5

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a1ff8:	4e09      	ldr	r6, [pc, #36]	; (80a2020 <_Z17acquireWireBufferv+0x30>)
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a1ffa:	2100      	movs	r1, #0
 80a1ffc:	f001 f931 	bl	80a3262 <memset>
 80a2000:	8025      	strh	r5, [r4, #0]
 80a2002:	2520      	movs	r5, #32

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2004:	4631      	mov	r1, r6
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a2006:	60a5      	str	r5, [r4, #8]
 80a2008:	6125      	str	r5, [r4, #16]

HAL_I2C_Config defaultWireConfig() {
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a200a:	4628      	mov	r0, r5
 80a200c:	f000 f867 	bl	80a20de <_ZnajRKSt9nothrow_t>
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2010:	4631      	mov	r1, r6
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a2012:	6060      	str	r0, [r4, #4]
	HAL_I2C_Config config = {
		.size = sizeof(HAL_I2C_Config),
		.version = HAL_I2C_CONFIG_VERSION_1,
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
		.rx_buffer_size = I2C_BUFFER_LENGTH,
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a2014:	4628      	mov	r0, r5
 80a2016:	f000 f862 	bl	80a20de <_ZnajRKSt9nothrow_t>
		.tx_buffer_size = I2C_BUFFER_LENGTH
	};
 80a201a:	60e0      	str	r0, [r4, #12]
} // anonymous

HAL_I2C_Config __attribute__((weak)) acquireWireBuffer()
{
	return defaultWireConfig();
}
 80a201c:	4620      	mov	r0, r4
 80a201e:	bd70      	pop	{r4, r5, r6, pc}
 80a2020:	080a3720 	.word	0x080a3720

080a2024 <_Z19__fetch_global_Wirev>:
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a2024:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a2026:	4d0e      	ldr	r5, [pc, #56]	; (80a2060 <_Z19__fetch_global_Wirev+0x3c>)
	return defaultWireConfig();
}
#endif

TwoWire& __fetch_global_Wire()
{
 80a2028:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a202a:	6829      	ldr	r1, [r5, #0]
 80a202c:	f011 0401 	ands.w	r4, r1, #1
 80a2030:	d113      	bne.n	80a205a <_Z19__fetch_global_Wirev+0x36>
 80a2032:	4628      	mov	r0, r5
 80a2034:	f7fe f837 	bl	80a00a6 <__cxa_guard_acquire>
 80a2038:	b178      	cbz	r0, 80a205a <_Z19__fetch_global_Wirev+0x36>
 80a203a:	a801      	add	r0, sp, #4
 80a203c:	f7ff ffd8 	bl	80a1ff0 <_Z17acquireWireBufferv>
 80a2040:	aa01      	add	r2, sp, #4
 80a2042:	4621      	mov	r1, r4
 80a2044:	4807      	ldr	r0, [pc, #28]	; (80a2064 <_Z19__fetch_global_Wirev+0x40>)
 80a2046:	f7fe fee3 	bl	80a0e10 <_ZN7TwoWireC1E17HAL_I2C_InterfaceRK14HAL_I2C_Config>
 80a204a:	4628      	mov	r0, r5
 80a204c:	f7fe f830 	bl	80a00b0 <__cxa_guard_release>
 80a2050:	4a05      	ldr	r2, [pc, #20]	; (80a2068 <_Z19__fetch_global_Wirev+0x44>)
 80a2052:	4906      	ldr	r1, [pc, #24]	; (80a206c <_Z19__fetch_global_Wirev+0x48>)
 80a2054:	4803      	ldr	r0, [pc, #12]	; (80a2064 <_Z19__fetch_global_Wirev+0x40>)
 80a2056:	f000 f823 	bl	80a20a0 <__aeabi_atexit>
	return wire;
}
 80a205a:	4802      	ldr	r0, [pc, #8]	; (80a2064 <_Z19__fetch_global_Wirev+0x40>)
 80a205c:	b007      	add	sp, #28
 80a205e:	bd30      	pop	{r4, r5, pc}
 80a2060:	20000554 	.word	0x20000554
 80a2064:	20000558 	.word	0x20000558
 80a2068:	20000070 	.word	0x20000070
 80a206c:	080a0db9 	.word	0x080a0db9

080a2070 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a2070:	b513      	push	{r0, r1, r4, lr}
 80a2072:	4c08      	ldr	r4, [pc, #32]	; (80a2094 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a2074:	2300      	movs	r3, #0
 80a2076:	461a      	mov	r2, r3
 80a2078:	4619      	mov	r1, r3
 80a207a:	9300      	str	r3, [sp, #0]
 80a207c:	4620      	mov	r0, r4
 80a207e:	f7fe ff75 	bl	80a0f6c <_ZN9IPAddressC1Ehhhh>
 80a2082:	4620      	mov	r0, r4
 80a2084:	4a04      	ldr	r2, [pc, #16]	; (80a2098 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a2086:	4905      	ldr	r1, [pc, #20]	; (80a209c <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a2088:	b002      	add	sp, #8
 80a208a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a208e:	f000 b807 	b.w	80a20a0 <__aeabi_atexit>
 80a2092:	bf00      	nop
 80a2094:	2000056c 	.word	0x2000056c
 80a2098:	20000070 	.word	0x20000070
 80a209c:	080a0ebf 	.word	0x080a0ebf

080a20a0 <__aeabi_atexit>:
 80a20a0:	460b      	mov	r3, r1
 80a20a2:	4601      	mov	r1, r0
 80a20a4:	4618      	mov	r0, r3
 80a20a6:	f001 b8c3 	b.w	80a3230 <__cxa_atexit>

080a20aa <_ZdlPvj>:
 80a20aa:	f7fd bffa 	b.w	80a00a2 <_ZdlPv>
	...

080a20b0 <_ZSt15get_new_handlerv>:
 80a20b0:	4b02      	ldr	r3, [pc, #8]	; (80a20bc <_ZSt15get_new_handlerv+0xc>)
 80a20b2:	6818      	ldr	r0, [r3, #0]
 80a20b4:	f3bf 8f5f 	dmb	sy
 80a20b8:	4770      	bx	lr
 80a20ba:	bf00      	nop
 80a20bc:	20000584 	.word	0x20000584

080a20c0 <_ZnwjRKSt9nothrow_t>:
 80a20c0:	b510      	push	{r4, lr}
 80a20c2:	2800      	cmp	r0, #0
 80a20c4:	bf14      	ite	ne
 80a20c6:	4604      	movne	r4, r0
 80a20c8:	2401      	moveq	r4, #1
 80a20ca:	4620      	mov	r0, r4
 80a20cc:	f7fe fe40 	bl	80a0d50 <malloc>
 80a20d0:	b920      	cbnz	r0, 80a20dc <_ZnwjRKSt9nothrow_t+0x1c>
 80a20d2:	f7ff ffed 	bl	80a20b0 <_ZSt15get_new_handlerv>
 80a20d6:	b108      	cbz	r0, 80a20dc <_ZnwjRKSt9nothrow_t+0x1c>
 80a20d8:	4780      	blx	r0
 80a20da:	e7f6      	b.n	80a20ca <_ZnwjRKSt9nothrow_t+0xa>
 80a20dc:	bd10      	pop	{r4, pc}

080a20de <_ZnajRKSt9nothrow_t>:
 80a20de:	f7ff bfef 	b.w	80a20c0 <_ZnwjRKSt9nothrow_t>
	...

080a20e4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a20e4:	4b24      	ldr	r3, [pc, #144]	; (80a2178 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a20e6:	681a      	ldr	r2, [r3, #0]
 80a20e8:	07d0      	lsls	r0, r2, #31
 80a20ea:	bf5c      	itt	pl
 80a20ec:	2201      	movpl	r2, #1
 80a20ee:	601a      	strpl	r2, [r3, #0]
 80a20f0:	4b22      	ldr	r3, [pc, #136]	; (80a217c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a20f2:	681a      	ldr	r2, [r3, #0]
 80a20f4:	07d1      	lsls	r1, r2, #31
 80a20f6:	bf5c      	itt	pl
 80a20f8:	2201      	movpl	r2, #1
 80a20fa:	601a      	strpl	r2, [r3, #0]
 80a20fc:	4b20      	ldr	r3, [pc, #128]	; (80a2180 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a20fe:	681a      	ldr	r2, [r3, #0]
 80a2100:	07d2      	lsls	r2, r2, #31
 80a2102:	bf5c      	itt	pl
 80a2104:	2201      	movpl	r2, #1
 80a2106:	601a      	strpl	r2, [r3, #0]
 80a2108:	4b1e      	ldr	r3, [pc, #120]	; (80a2184 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a210a:	681a      	ldr	r2, [r3, #0]
 80a210c:	07d0      	lsls	r0, r2, #31
 80a210e:	bf5c      	itt	pl
 80a2110:	2201      	movpl	r2, #1
 80a2112:	601a      	strpl	r2, [r3, #0]
 80a2114:	4b1c      	ldr	r3, [pc, #112]	; (80a2188 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a2116:	681a      	ldr	r2, [r3, #0]
 80a2118:	07d1      	lsls	r1, r2, #31
 80a211a:	bf5c      	itt	pl
 80a211c:	2201      	movpl	r2, #1
 80a211e:	601a      	strpl	r2, [r3, #0]
 80a2120:	4b1a      	ldr	r3, [pc, #104]	; (80a218c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a2122:	681a      	ldr	r2, [r3, #0]
 80a2124:	07d2      	lsls	r2, r2, #31
 80a2126:	bf5c      	itt	pl
 80a2128:	2201      	movpl	r2, #1
 80a212a:	601a      	strpl	r2, [r3, #0]
 80a212c:	4b18      	ldr	r3, [pc, #96]	; (80a2190 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a212e:	681a      	ldr	r2, [r3, #0]
 80a2130:	07d0      	lsls	r0, r2, #31
 80a2132:	bf5c      	itt	pl
 80a2134:	2201      	movpl	r2, #1
 80a2136:	601a      	strpl	r2, [r3, #0]
 80a2138:	4b16      	ldr	r3, [pc, #88]	; (80a2194 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a213a:	681a      	ldr	r2, [r3, #0]
 80a213c:	07d1      	lsls	r1, r2, #31
 80a213e:	bf5c      	itt	pl
 80a2140:	2201      	movpl	r2, #1
 80a2142:	601a      	strpl	r2, [r3, #0]
 80a2144:	4b14      	ldr	r3, [pc, #80]	; (80a2198 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a2146:	681a      	ldr	r2, [r3, #0]
 80a2148:	07d2      	lsls	r2, r2, #31
 80a214a:	bf5c      	itt	pl
 80a214c:	2201      	movpl	r2, #1
 80a214e:	601a      	strpl	r2, [r3, #0]
 80a2150:	4b12      	ldr	r3, [pc, #72]	; (80a219c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a2152:	681a      	ldr	r2, [r3, #0]
 80a2154:	07d0      	lsls	r0, r2, #31
 80a2156:	bf5c      	itt	pl
 80a2158:	2201      	movpl	r2, #1
 80a215a:	601a      	strpl	r2, [r3, #0]
 80a215c:	4b10      	ldr	r3, [pc, #64]	; (80a21a0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a215e:	681a      	ldr	r2, [r3, #0]
 80a2160:	07d1      	lsls	r1, r2, #31
 80a2162:	bf5c      	itt	pl
 80a2164:	2201      	movpl	r2, #1
 80a2166:	601a      	strpl	r2, [r3, #0]
 80a2168:	4b0e      	ldr	r3, [pc, #56]	; (80a21a4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a216a:	681a      	ldr	r2, [r3, #0]
 80a216c:	07d2      	lsls	r2, r2, #31
 80a216e:	bf5c      	itt	pl
 80a2170:	2201      	movpl	r2, #1
 80a2172:	601a      	strpl	r2, [r3, #0]
 80a2174:	4770      	bx	lr
 80a2176:	bf00      	nop
 80a2178:	200005b4 	.word	0x200005b4
 80a217c:	200005b0 	.word	0x200005b0
 80a2180:	200005ac 	.word	0x200005ac
 80a2184:	200005a8 	.word	0x200005a8
 80a2188:	200005a4 	.word	0x200005a4
 80a218c:	200005a0 	.word	0x200005a0
 80a2190:	2000059c 	.word	0x2000059c
 80a2194:	20000598 	.word	0x20000598
 80a2198:	20000594 	.word	0x20000594
 80a219c:	20000590 	.word	0x20000590
 80a21a0:	2000058c 	.word	0x2000058c
 80a21a4:	20000588 	.word	0x20000588

080a21a8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a21a8:	4b18      	ldr	r3, [pc, #96]	; (80a220c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a21aa:	681a      	ldr	r2, [r3, #0]
 80a21ac:	07d1      	lsls	r1, r2, #31
 80a21ae:	bf5c      	itt	pl
 80a21b0:	2201      	movpl	r2, #1
 80a21b2:	601a      	strpl	r2, [r3, #0]
 80a21b4:	4b16      	ldr	r3, [pc, #88]	; (80a2210 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a21b6:	681a      	ldr	r2, [r3, #0]
 80a21b8:	07d2      	lsls	r2, r2, #31
 80a21ba:	bf5c      	itt	pl
 80a21bc:	2201      	movpl	r2, #1
 80a21be:	601a      	strpl	r2, [r3, #0]
 80a21c0:	4b14      	ldr	r3, [pc, #80]	; (80a2214 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a21c2:	681a      	ldr	r2, [r3, #0]
 80a21c4:	07d0      	lsls	r0, r2, #31
 80a21c6:	bf5c      	itt	pl
 80a21c8:	2201      	movpl	r2, #1
 80a21ca:	601a      	strpl	r2, [r3, #0]
 80a21cc:	4b12      	ldr	r3, [pc, #72]	; (80a2218 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a21ce:	681a      	ldr	r2, [r3, #0]
 80a21d0:	07d1      	lsls	r1, r2, #31
 80a21d2:	bf5c      	itt	pl
 80a21d4:	2201      	movpl	r2, #1
 80a21d6:	601a      	strpl	r2, [r3, #0]
 80a21d8:	4b10      	ldr	r3, [pc, #64]	; (80a221c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a21da:	681a      	ldr	r2, [r3, #0]
 80a21dc:	07d2      	lsls	r2, r2, #31
 80a21de:	bf5c      	itt	pl
 80a21e0:	2201      	movpl	r2, #1
 80a21e2:	601a      	strpl	r2, [r3, #0]
 80a21e4:	4b0e      	ldr	r3, [pc, #56]	; (80a2220 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a21e6:	681a      	ldr	r2, [r3, #0]
 80a21e8:	07d0      	lsls	r0, r2, #31
 80a21ea:	bf5c      	itt	pl
 80a21ec:	2201      	movpl	r2, #1
 80a21ee:	601a      	strpl	r2, [r3, #0]
 80a21f0:	4b0c      	ldr	r3, [pc, #48]	; (80a2224 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a21f2:	681a      	ldr	r2, [r3, #0]
 80a21f4:	07d1      	lsls	r1, r2, #31
 80a21f6:	bf5c      	itt	pl
 80a21f8:	2201      	movpl	r2, #1
 80a21fa:	601a      	strpl	r2, [r3, #0]
 80a21fc:	4b0a      	ldr	r3, [pc, #40]	; (80a2228 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a21fe:	681a      	ldr	r2, [r3, #0]
 80a2200:	07d2      	lsls	r2, r2, #31
 80a2202:	bf5c      	itt	pl
 80a2204:	2201      	movpl	r2, #1
 80a2206:	601a      	strpl	r2, [r3, #0]
 80a2208:	4770      	bx	lr
 80a220a:	bf00      	nop
 80a220c:	200005d4 	.word	0x200005d4
 80a2210:	200005d0 	.word	0x200005d0
 80a2214:	200005cc 	.word	0x200005cc
 80a2218:	200005c8 	.word	0x200005c8
 80a221c:	200005c4 	.word	0x200005c4
 80a2220:	200005c0 	.word	0x200005c0
 80a2224:	200005bc 	.word	0x200005bc
 80a2228:	200005b8 	.word	0x200005b8

080a222c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a222c:	4b18      	ldr	r3, [pc, #96]	; (80a2290 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a222e:	681a      	ldr	r2, [r3, #0]
 80a2230:	07d1      	lsls	r1, r2, #31
 80a2232:	bf5c      	itt	pl
 80a2234:	2201      	movpl	r2, #1
 80a2236:	601a      	strpl	r2, [r3, #0]
 80a2238:	4b16      	ldr	r3, [pc, #88]	; (80a2294 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a223a:	681a      	ldr	r2, [r3, #0]
 80a223c:	07d2      	lsls	r2, r2, #31
 80a223e:	bf5c      	itt	pl
 80a2240:	2201      	movpl	r2, #1
 80a2242:	601a      	strpl	r2, [r3, #0]
 80a2244:	4b14      	ldr	r3, [pc, #80]	; (80a2298 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a2246:	681a      	ldr	r2, [r3, #0]
 80a2248:	07d0      	lsls	r0, r2, #31
 80a224a:	bf5c      	itt	pl
 80a224c:	2201      	movpl	r2, #1
 80a224e:	601a      	strpl	r2, [r3, #0]
 80a2250:	4b12      	ldr	r3, [pc, #72]	; (80a229c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a2252:	681a      	ldr	r2, [r3, #0]
 80a2254:	07d1      	lsls	r1, r2, #31
 80a2256:	bf5c      	itt	pl
 80a2258:	2201      	movpl	r2, #1
 80a225a:	601a      	strpl	r2, [r3, #0]
 80a225c:	4b10      	ldr	r3, [pc, #64]	; (80a22a0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a225e:	681a      	ldr	r2, [r3, #0]
 80a2260:	07d2      	lsls	r2, r2, #31
 80a2262:	bf5c      	itt	pl
 80a2264:	2201      	movpl	r2, #1
 80a2266:	601a      	strpl	r2, [r3, #0]
 80a2268:	4b0e      	ldr	r3, [pc, #56]	; (80a22a4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a226a:	681a      	ldr	r2, [r3, #0]
 80a226c:	07d0      	lsls	r0, r2, #31
 80a226e:	bf5c      	itt	pl
 80a2270:	2201      	movpl	r2, #1
 80a2272:	601a      	strpl	r2, [r3, #0]
 80a2274:	4b0c      	ldr	r3, [pc, #48]	; (80a22a8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a2276:	681a      	ldr	r2, [r3, #0]
 80a2278:	07d1      	lsls	r1, r2, #31
 80a227a:	bf5c      	itt	pl
 80a227c:	2201      	movpl	r2, #1
 80a227e:	601a      	strpl	r2, [r3, #0]
 80a2280:	4b0a      	ldr	r3, [pc, #40]	; (80a22ac <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a2282:	681a      	ldr	r2, [r3, #0]
 80a2284:	07d2      	lsls	r2, r2, #31
 80a2286:	bf5c      	itt	pl
 80a2288:	2201      	movpl	r2, #1
 80a228a:	601a      	strpl	r2, [r3, #0]
 80a228c:	4770      	bx	lr
 80a228e:	bf00      	nop
 80a2290:	200005f4 	.word	0x200005f4
 80a2294:	200005f0 	.word	0x200005f0
 80a2298:	200005ec 	.word	0x200005ec
 80a229c:	200005e8 	.word	0x200005e8
 80a22a0:	200005e4 	.word	0x200005e4
 80a22a4:	200005e0 	.word	0x200005e0
 80a22a8:	200005dc 	.word	0x200005dc
 80a22ac:	200005d8 	.word	0x200005d8

080a22b0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a22b0:	4b24      	ldr	r3, [pc, #144]	; (80a2344 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a22b2:	681a      	ldr	r2, [r3, #0]
 80a22b4:	07d0      	lsls	r0, r2, #31
 80a22b6:	bf5c      	itt	pl
 80a22b8:	2201      	movpl	r2, #1
 80a22ba:	601a      	strpl	r2, [r3, #0]
 80a22bc:	4b22      	ldr	r3, [pc, #136]	; (80a2348 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a22be:	681a      	ldr	r2, [r3, #0]
 80a22c0:	07d1      	lsls	r1, r2, #31
 80a22c2:	bf5c      	itt	pl
 80a22c4:	2201      	movpl	r2, #1
 80a22c6:	601a      	strpl	r2, [r3, #0]
 80a22c8:	4b20      	ldr	r3, [pc, #128]	; (80a234c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a22ca:	681a      	ldr	r2, [r3, #0]
 80a22cc:	07d2      	lsls	r2, r2, #31
 80a22ce:	bf5c      	itt	pl
 80a22d0:	2201      	movpl	r2, #1
 80a22d2:	601a      	strpl	r2, [r3, #0]
 80a22d4:	4b1e      	ldr	r3, [pc, #120]	; (80a2350 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a22d6:	681a      	ldr	r2, [r3, #0]
 80a22d8:	07d0      	lsls	r0, r2, #31
 80a22da:	bf5c      	itt	pl
 80a22dc:	2201      	movpl	r2, #1
 80a22de:	601a      	strpl	r2, [r3, #0]
 80a22e0:	4b1c      	ldr	r3, [pc, #112]	; (80a2354 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a22e2:	681a      	ldr	r2, [r3, #0]
 80a22e4:	07d1      	lsls	r1, r2, #31
 80a22e6:	bf5c      	itt	pl
 80a22e8:	2201      	movpl	r2, #1
 80a22ea:	601a      	strpl	r2, [r3, #0]
 80a22ec:	4b1a      	ldr	r3, [pc, #104]	; (80a2358 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a22ee:	681a      	ldr	r2, [r3, #0]
 80a22f0:	07d2      	lsls	r2, r2, #31
 80a22f2:	bf5c      	itt	pl
 80a22f4:	2201      	movpl	r2, #1
 80a22f6:	601a      	strpl	r2, [r3, #0]
 80a22f8:	4b18      	ldr	r3, [pc, #96]	; (80a235c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a22fa:	681a      	ldr	r2, [r3, #0]
 80a22fc:	07d0      	lsls	r0, r2, #31
 80a22fe:	bf5c      	itt	pl
 80a2300:	2201      	movpl	r2, #1
 80a2302:	601a      	strpl	r2, [r3, #0]
 80a2304:	4b16      	ldr	r3, [pc, #88]	; (80a2360 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a2306:	681a      	ldr	r2, [r3, #0]
 80a2308:	07d1      	lsls	r1, r2, #31
 80a230a:	bf5c      	itt	pl
 80a230c:	2201      	movpl	r2, #1
 80a230e:	601a      	strpl	r2, [r3, #0]
 80a2310:	4b14      	ldr	r3, [pc, #80]	; (80a2364 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a2312:	681a      	ldr	r2, [r3, #0]
 80a2314:	07d2      	lsls	r2, r2, #31
 80a2316:	bf5c      	itt	pl
 80a2318:	2201      	movpl	r2, #1
 80a231a:	601a      	strpl	r2, [r3, #0]
 80a231c:	4b12      	ldr	r3, [pc, #72]	; (80a2368 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a231e:	681a      	ldr	r2, [r3, #0]
 80a2320:	07d0      	lsls	r0, r2, #31
 80a2322:	bf5c      	itt	pl
 80a2324:	2201      	movpl	r2, #1
 80a2326:	601a      	strpl	r2, [r3, #0]
 80a2328:	4b10      	ldr	r3, [pc, #64]	; (80a236c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a232a:	681a      	ldr	r2, [r3, #0]
 80a232c:	07d1      	lsls	r1, r2, #31
 80a232e:	bf5c      	itt	pl
 80a2330:	2201      	movpl	r2, #1
 80a2332:	601a      	strpl	r2, [r3, #0]
 80a2334:	4b0e      	ldr	r3, [pc, #56]	; (80a2370 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a2336:	681a      	ldr	r2, [r3, #0]
 80a2338:	07d2      	lsls	r2, r2, #31
 80a233a:	bf5c      	itt	pl
 80a233c:	2201      	movpl	r2, #1
 80a233e:	601a      	strpl	r2, [r3, #0]
 80a2340:	4770      	bx	lr
 80a2342:	bf00      	nop
 80a2344:	20000624 	.word	0x20000624
 80a2348:	20000620 	.word	0x20000620
 80a234c:	2000061c 	.word	0x2000061c
 80a2350:	20000618 	.word	0x20000618
 80a2354:	20000614 	.word	0x20000614
 80a2358:	20000610 	.word	0x20000610
 80a235c:	2000060c 	.word	0x2000060c
 80a2360:	20000608 	.word	0x20000608
 80a2364:	20000604 	.word	0x20000604
 80a2368:	20000600 	.word	0x20000600
 80a236c:	200005fc 	.word	0x200005fc
 80a2370:	200005f8 	.word	0x200005f8

080a2374 <__aeabi_drsub>:
 80a2374:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a2378:	e002      	b.n	80a2380 <__adddf3>
 80a237a:	bf00      	nop

080a237c <__aeabi_dsub>:
 80a237c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a2380 <__adddf3>:
 80a2380:	b530      	push	{r4, r5, lr}
 80a2382:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a2386:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a238a:	ea94 0f05 	teq	r4, r5
 80a238e:	bf08      	it	eq
 80a2390:	ea90 0f02 	teqeq	r0, r2
 80a2394:	bf1f      	itttt	ne
 80a2396:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a239a:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a239e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a23a2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a23a6:	f000 80e2 	beq.w	80a256e <__adddf3+0x1ee>
 80a23aa:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a23ae:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a23b2:	bfb8      	it	lt
 80a23b4:	426d      	neglt	r5, r5
 80a23b6:	dd0c      	ble.n	80a23d2 <__adddf3+0x52>
 80a23b8:	442c      	add	r4, r5
 80a23ba:	ea80 0202 	eor.w	r2, r0, r2
 80a23be:	ea81 0303 	eor.w	r3, r1, r3
 80a23c2:	ea82 0000 	eor.w	r0, r2, r0
 80a23c6:	ea83 0101 	eor.w	r1, r3, r1
 80a23ca:	ea80 0202 	eor.w	r2, r0, r2
 80a23ce:	ea81 0303 	eor.w	r3, r1, r3
 80a23d2:	2d36      	cmp	r5, #54	; 0x36
 80a23d4:	bf88      	it	hi
 80a23d6:	bd30      	pophi	{r4, r5, pc}
 80a23d8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a23dc:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a23e0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a23e4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a23e8:	d002      	beq.n	80a23f0 <__adddf3+0x70>
 80a23ea:	4240      	negs	r0, r0
 80a23ec:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a23f0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a23f4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a23f8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a23fc:	d002      	beq.n	80a2404 <__adddf3+0x84>
 80a23fe:	4252      	negs	r2, r2
 80a2400:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a2404:	ea94 0f05 	teq	r4, r5
 80a2408:	f000 80a7 	beq.w	80a255a <__adddf3+0x1da>
 80a240c:	f1a4 0401 	sub.w	r4, r4, #1
 80a2410:	f1d5 0e20 	rsbs	lr, r5, #32
 80a2414:	db0d      	blt.n	80a2432 <__adddf3+0xb2>
 80a2416:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a241a:	fa22 f205 	lsr.w	r2, r2, r5
 80a241e:	1880      	adds	r0, r0, r2
 80a2420:	f141 0100 	adc.w	r1, r1, #0
 80a2424:	fa03 f20e 	lsl.w	r2, r3, lr
 80a2428:	1880      	adds	r0, r0, r2
 80a242a:	fa43 f305 	asr.w	r3, r3, r5
 80a242e:	4159      	adcs	r1, r3
 80a2430:	e00e      	b.n	80a2450 <__adddf3+0xd0>
 80a2432:	f1a5 0520 	sub.w	r5, r5, #32
 80a2436:	f10e 0e20 	add.w	lr, lr, #32
 80a243a:	2a01      	cmp	r2, #1
 80a243c:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a2440:	bf28      	it	cs
 80a2442:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a2446:	fa43 f305 	asr.w	r3, r3, r5
 80a244a:	18c0      	adds	r0, r0, r3
 80a244c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a2450:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a2454:	d507      	bpl.n	80a2466 <__adddf3+0xe6>
 80a2456:	f04f 0e00 	mov.w	lr, #0
 80a245a:	f1dc 0c00 	rsbs	ip, ip, #0
 80a245e:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a2462:	eb6e 0101 	sbc.w	r1, lr, r1
 80a2466:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a246a:	d31b      	bcc.n	80a24a4 <__adddf3+0x124>
 80a246c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a2470:	d30c      	bcc.n	80a248c <__adddf3+0x10c>
 80a2472:	0849      	lsrs	r1, r1, #1
 80a2474:	ea5f 0030 	movs.w	r0, r0, rrx
 80a2478:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a247c:	f104 0401 	add.w	r4, r4, #1
 80a2480:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a2484:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a2488:	f080 809a 	bcs.w	80a25c0 <__adddf3+0x240>
 80a248c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a2490:	bf08      	it	eq
 80a2492:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a2496:	f150 0000 	adcs.w	r0, r0, #0
 80a249a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a249e:	ea41 0105 	orr.w	r1, r1, r5
 80a24a2:	bd30      	pop	{r4, r5, pc}
 80a24a4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a24a8:	4140      	adcs	r0, r0
 80a24aa:	eb41 0101 	adc.w	r1, r1, r1
 80a24ae:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a24b2:	f1a4 0401 	sub.w	r4, r4, #1
 80a24b6:	d1e9      	bne.n	80a248c <__adddf3+0x10c>
 80a24b8:	f091 0f00 	teq	r1, #0
 80a24bc:	bf04      	itt	eq
 80a24be:	4601      	moveq	r1, r0
 80a24c0:	2000      	moveq	r0, #0
 80a24c2:	fab1 f381 	clz	r3, r1
 80a24c6:	bf08      	it	eq
 80a24c8:	3320      	addeq	r3, #32
 80a24ca:	f1a3 030b 	sub.w	r3, r3, #11
 80a24ce:	f1b3 0220 	subs.w	r2, r3, #32
 80a24d2:	da0c      	bge.n	80a24ee <__adddf3+0x16e>
 80a24d4:	320c      	adds	r2, #12
 80a24d6:	dd08      	ble.n	80a24ea <__adddf3+0x16a>
 80a24d8:	f102 0c14 	add.w	ip, r2, #20
 80a24dc:	f1c2 020c 	rsb	r2, r2, #12
 80a24e0:	fa01 f00c 	lsl.w	r0, r1, ip
 80a24e4:	fa21 f102 	lsr.w	r1, r1, r2
 80a24e8:	e00c      	b.n	80a2504 <__adddf3+0x184>
 80a24ea:	f102 0214 	add.w	r2, r2, #20
 80a24ee:	bfd8      	it	le
 80a24f0:	f1c2 0c20 	rsble	ip, r2, #32
 80a24f4:	fa01 f102 	lsl.w	r1, r1, r2
 80a24f8:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a24fc:	bfdc      	itt	le
 80a24fe:	ea41 010c 	orrle.w	r1, r1, ip
 80a2502:	4090      	lslle	r0, r2
 80a2504:	1ae4      	subs	r4, r4, r3
 80a2506:	bfa2      	ittt	ge
 80a2508:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a250c:	4329      	orrge	r1, r5
 80a250e:	bd30      	popge	{r4, r5, pc}
 80a2510:	ea6f 0404 	mvn.w	r4, r4
 80a2514:	3c1f      	subs	r4, #31
 80a2516:	da1c      	bge.n	80a2552 <__adddf3+0x1d2>
 80a2518:	340c      	adds	r4, #12
 80a251a:	dc0e      	bgt.n	80a253a <__adddf3+0x1ba>
 80a251c:	f104 0414 	add.w	r4, r4, #20
 80a2520:	f1c4 0220 	rsb	r2, r4, #32
 80a2524:	fa20 f004 	lsr.w	r0, r0, r4
 80a2528:	fa01 f302 	lsl.w	r3, r1, r2
 80a252c:	ea40 0003 	orr.w	r0, r0, r3
 80a2530:	fa21 f304 	lsr.w	r3, r1, r4
 80a2534:	ea45 0103 	orr.w	r1, r5, r3
 80a2538:	bd30      	pop	{r4, r5, pc}
 80a253a:	f1c4 040c 	rsb	r4, r4, #12
 80a253e:	f1c4 0220 	rsb	r2, r4, #32
 80a2542:	fa20 f002 	lsr.w	r0, r0, r2
 80a2546:	fa01 f304 	lsl.w	r3, r1, r4
 80a254a:	ea40 0003 	orr.w	r0, r0, r3
 80a254e:	4629      	mov	r1, r5
 80a2550:	bd30      	pop	{r4, r5, pc}
 80a2552:	fa21 f004 	lsr.w	r0, r1, r4
 80a2556:	4629      	mov	r1, r5
 80a2558:	bd30      	pop	{r4, r5, pc}
 80a255a:	f094 0f00 	teq	r4, #0
 80a255e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a2562:	bf06      	itte	eq
 80a2564:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a2568:	3401      	addeq	r4, #1
 80a256a:	3d01      	subne	r5, #1
 80a256c:	e74e      	b.n	80a240c <__adddf3+0x8c>
 80a256e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a2572:	bf18      	it	ne
 80a2574:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a2578:	d029      	beq.n	80a25ce <__adddf3+0x24e>
 80a257a:	ea94 0f05 	teq	r4, r5
 80a257e:	bf08      	it	eq
 80a2580:	ea90 0f02 	teqeq	r0, r2
 80a2584:	d005      	beq.n	80a2592 <__adddf3+0x212>
 80a2586:	ea54 0c00 	orrs.w	ip, r4, r0
 80a258a:	bf04      	itt	eq
 80a258c:	4619      	moveq	r1, r3
 80a258e:	4610      	moveq	r0, r2
 80a2590:	bd30      	pop	{r4, r5, pc}
 80a2592:	ea91 0f03 	teq	r1, r3
 80a2596:	bf1e      	ittt	ne
 80a2598:	2100      	movne	r1, #0
 80a259a:	2000      	movne	r0, #0
 80a259c:	bd30      	popne	{r4, r5, pc}
 80a259e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a25a2:	d105      	bne.n	80a25b0 <__adddf3+0x230>
 80a25a4:	0040      	lsls	r0, r0, #1
 80a25a6:	4149      	adcs	r1, r1
 80a25a8:	bf28      	it	cs
 80a25aa:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a25ae:	bd30      	pop	{r4, r5, pc}
 80a25b0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a25b4:	bf3c      	itt	cc
 80a25b6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a25ba:	bd30      	popcc	{r4, r5, pc}
 80a25bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a25c0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a25c4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a25c8:	f04f 0000 	mov.w	r0, #0
 80a25cc:	bd30      	pop	{r4, r5, pc}
 80a25ce:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a25d2:	bf1a      	itte	ne
 80a25d4:	4619      	movne	r1, r3
 80a25d6:	4610      	movne	r0, r2
 80a25d8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a25dc:	bf1c      	itt	ne
 80a25de:	460b      	movne	r3, r1
 80a25e0:	4602      	movne	r2, r0
 80a25e2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a25e6:	bf06      	itte	eq
 80a25e8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a25ec:	ea91 0f03 	teqeq	r1, r3
 80a25f0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a25f4:	bd30      	pop	{r4, r5, pc}
 80a25f6:	bf00      	nop

080a25f8 <__aeabi_ui2d>:
 80a25f8:	f090 0f00 	teq	r0, #0
 80a25fc:	bf04      	itt	eq
 80a25fe:	2100      	moveq	r1, #0
 80a2600:	4770      	bxeq	lr
 80a2602:	b530      	push	{r4, r5, lr}
 80a2604:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a2608:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a260c:	f04f 0500 	mov.w	r5, #0
 80a2610:	f04f 0100 	mov.w	r1, #0
 80a2614:	e750      	b.n	80a24b8 <__adddf3+0x138>
 80a2616:	bf00      	nop

080a2618 <__aeabi_i2d>:
 80a2618:	f090 0f00 	teq	r0, #0
 80a261c:	bf04      	itt	eq
 80a261e:	2100      	moveq	r1, #0
 80a2620:	4770      	bxeq	lr
 80a2622:	b530      	push	{r4, r5, lr}
 80a2624:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a2628:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a262c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a2630:	bf48      	it	mi
 80a2632:	4240      	negmi	r0, r0
 80a2634:	f04f 0100 	mov.w	r1, #0
 80a2638:	e73e      	b.n	80a24b8 <__adddf3+0x138>
 80a263a:	bf00      	nop

080a263c <__aeabi_f2d>:
 80a263c:	0042      	lsls	r2, r0, #1
 80a263e:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a2642:	ea4f 0131 	mov.w	r1, r1, rrx
 80a2646:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a264a:	bf1f      	itttt	ne
 80a264c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a2650:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a2654:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a2658:	4770      	bxne	lr
 80a265a:	f092 0f00 	teq	r2, #0
 80a265e:	bf14      	ite	ne
 80a2660:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a2664:	4770      	bxeq	lr
 80a2666:	b530      	push	{r4, r5, lr}
 80a2668:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a266c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a2670:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a2674:	e720      	b.n	80a24b8 <__adddf3+0x138>
 80a2676:	bf00      	nop

080a2678 <__aeabi_ul2d>:
 80a2678:	ea50 0201 	orrs.w	r2, r0, r1
 80a267c:	bf08      	it	eq
 80a267e:	4770      	bxeq	lr
 80a2680:	b530      	push	{r4, r5, lr}
 80a2682:	f04f 0500 	mov.w	r5, #0
 80a2686:	e00a      	b.n	80a269e <__aeabi_l2d+0x16>

080a2688 <__aeabi_l2d>:
 80a2688:	ea50 0201 	orrs.w	r2, r0, r1
 80a268c:	bf08      	it	eq
 80a268e:	4770      	bxeq	lr
 80a2690:	b530      	push	{r4, r5, lr}
 80a2692:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a2696:	d502      	bpl.n	80a269e <__aeabi_l2d+0x16>
 80a2698:	4240      	negs	r0, r0
 80a269a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a269e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a26a2:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a26a6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a26aa:	f43f aedc 	beq.w	80a2466 <__adddf3+0xe6>
 80a26ae:	f04f 0203 	mov.w	r2, #3
 80a26b2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a26b6:	bf18      	it	ne
 80a26b8:	3203      	addne	r2, #3
 80a26ba:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a26be:	bf18      	it	ne
 80a26c0:	3203      	addne	r2, #3
 80a26c2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a26c6:	f1c2 0320 	rsb	r3, r2, #32
 80a26ca:	fa00 fc03 	lsl.w	ip, r0, r3
 80a26ce:	fa20 f002 	lsr.w	r0, r0, r2
 80a26d2:	fa01 fe03 	lsl.w	lr, r1, r3
 80a26d6:	ea40 000e 	orr.w	r0, r0, lr
 80a26da:	fa21 f102 	lsr.w	r1, r1, r2
 80a26de:	4414      	add	r4, r2
 80a26e0:	e6c1      	b.n	80a2466 <__adddf3+0xe6>
 80a26e2:	bf00      	nop

080a26e4 <__aeabi_dmul>:
 80a26e4:	b570      	push	{r4, r5, r6, lr}
 80a26e6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a26ea:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a26ee:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a26f2:	bf1d      	ittte	ne
 80a26f4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a26f8:	ea94 0f0c 	teqne	r4, ip
 80a26fc:	ea95 0f0c 	teqne	r5, ip
 80a2700:	f000 f8de 	bleq	80a28c0 <__aeabi_dmul+0x1dc>
 80a2704:	442c      	add	r4, r5
 80a2706:	ea81 0603 	eor.w	r6, r1, r3
 80a270a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a270e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a2712:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a2716:	bf18      	it	ne
 80a2718:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a271c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a2720:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a2724:	d038      	beq.n	80a2798 <__aeabi_dmul+0xb4>
 80a2726:	fba0 ce02 	umull	ip, lr, r0, r2
 80a272a:	f04f 0500 	mov.w	r5, #0
 80a272e:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a2732:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a2736:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a273a:	f04f 0600 	mov.w	r6, #0
 80a273e:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a2742:	f09c 0f00 	teq	ip, #0
 80a2746:	bf18      	it	ne
 80a2748:	f04e 0e01 	orrne.w	lr, lr, #1
 80a274c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a2750:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a2754:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a2758:	d204      	bcs.n	80a2764 <__aeabi_dmul+0x80>
 80a275a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a275e:	416d      	adcs	r5, r5
 80a2760:	eb46 0606 	adc.w	r6, r6, r6
 80a2764:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a2768:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a276c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a2770:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a2774:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a2778:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a277c:	bf88      	it	hi
 80a277e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a2782:	d81e      	bhi.n	80a27c2 <__aeabi_dmul+0xde>
 80a2784:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a2788:	bf08      	it	eq
 80a278a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a278e:	f150 0000 	adcs.w	r0, r0, #0
 80a2792:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a2796:	bd70      	pop	{r4, r5, r6, pc}
 80a2798:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a279c:	ea46 0101 	orr.w	r1, r6, r1
 80a27a0:	ea40 0002 	orr.w	r0, r0, r2
 80a27a4:	ea81 0103 	eor.w	r1, r1, r3
 80a27a8:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a27ac:	bfc2      	ittt	gt
 80a27ae:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a27b2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a27b6:	bd70      	popgt	{r4, r5, r6, pc}
 80a27b8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a27bc:	f04f 0e00 	mov.w	lr, #0
 80a27c0:	3c01      	subs	r4, #1
 80a27c2:	f300 80ab 	bgt.w	80a291c <__aeabi_dmul+0x238>
 80a27c6:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a27ca:	bfde      	ittt	le
 80a27cc:	2000      	movle	r0, #0
 80a27ce:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a27d2:	bd70      	pople	{r4, r5, r6, pc}
 80a27d4:	f1c4 0400 	rsb	r4, r4, #0
 80a27d8:	3c20      	subs	r4, #32
 80a27da:	da35      	bge.n	80a2848 <__aeabi_dmul+0x164>
 80a27dc:	340c      	adds	r4, #12
 80a27de:	dc1b      	bgt.n	80a2818 <__aeabi_dmul+0x134>
 80a27e0:	f104 0414 	add.w	r4, r4, #20
 80a27e4:	f1c4 0520 	rsb	r5, r4, #32
 80a27e8:	fa00 f305 	lsl.w	r3, r0, r5
 80a27ec:	fa20 f004 	lsr.w	r0, r0, r4
 80a27f0:	fa01 f205 	lsl.w	r2, r1, r5
 80a27f4:	ea40 0002 	orr.w	r0, r0, r2
 80a27f8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a27fc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a2800:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a2804:	fa21 f604 	lsr.w	r6, r1, r4
 80a2808:	eb42 0106 	adc.w	r1, r2, r6
 80a280c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a2810:	bf08      	it	eq
 80a2812:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a2816:	bd70      	pop	{r4, r5, r6, pc}
 80a2818:	f1c4 040c 	rsb	r4, r4, #12
 80a281c:	f1c4 0520 	rsb	r5, r4, #32
 80a2820:	fa00 f304 	lsl.w	r3, r0, r4
 80a2824:	fa20 f005 	lsr.w	r0, r0, r5
 80a2828:	fa01 f204 	lsl.w	r2, r1, r4
 80a282c:	ea40 0002 	orr.w	r0, r0, r2
 80a2830:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a2834:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a2838:	f141 0100 	adc.w	r1, r1, #0
 80a283c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a2840:	bf08      	it	eq
 80a2842:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a2846:	bd70      	pop	{r4, r5, r6, pc}
 80a2848:	f1c4 0520 	rsb	r5, r4, #32
 80a284c:	fa00 f205 	lsl.w	r2, r0, r5
 80a2850:	ea4e 0e02 	orr.w	lr, lr, r2
 80a2854:	fa20 f304 	lsr.w	r3, r0, r4
 80a2858:	fa01 f205 	lsl.w	r2, r1, r5
 80a285c:	ea43 0302 	orr.w	r3, r3, r2
 80a2860:	fa21 f004 	lsr.w	r0, r1, r4
 80a2864:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a2868:	fa21 f204 	lsr.w	r2, r1, r4
 80a286c:	ea20 0002 	bic.w	r0, r0, r2
 80a2870:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a2874:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a2878:	bf08      	it	eq
 80a287a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a287e:	bd70      	pop	{r4, r5, r6, pc}
 80a2880:	f094 0f00 	teq	r4, #0
 80a2884:	d10f      	bne.n	80a28a6 <__aeabi_dmul+0x1c2>
 80a2886:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a288a:	0040      	lsls	r0, r0, #1
 80a288c:	eb41 0101 	adc.w	r1, r1, r1
 80a2890:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a2894:	bf08      	it	eq
 80a2896:	3c01      	subeq	r4, #1
 80a2898:	d0f7      	beq.n	80a288a <__aeabi_dmul+0x1a6>
 80a289a:	ea41 0106 	orr.w	r1, r1, r6
 80a289e:	f095 0f00 	teq	r5, #0
 80a28a2:	bf18      	it	ne
 80a28a4:	4770      	bxne	lr
 80a28a6:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a28aa:	0052      	lsls	r2, r2, #1
 80a28ac:	eb43 0303 	adc.w	r3, r3, r3
 80a28b0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a28b4:	bf08      	it	eq
 80a28b6:	3d01      	subeq	r5, #1
 80a28b8:	d0f7      	beq.n	80a28aa <__aeabi_dmul+0x1c6>
 80a28ba:	ea43 0306 	orr.w	r3, r3, r6
 80a28be:	4770      	bx	lr
 80a28c0:	ea94 0f0c 	teq	r4, ip
 80a28c4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a28c8:	bf18      	it	ne
 80a28ca:	ea95 0f0c 	teqne	r5, ip
 80a28ce:	d00c      	beq.n	80a28ea <__aeabi_dmul+0x206>
 80a28d0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a28d4:	bf18      	it	ne
 80a28d6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a28da:	d1d1      	bne.n	80a2880 <__aeabi_dmul+0x19c>
 80a28dc:	ea81 0103 	eor.w	r1, r1, r3
 80a28e0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a28e4:	f04f 0000 	mov.w	r0, #0
 80a28e8:	bd70      	pop	{r4, r5, r6, pc}
 80a28ea:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a28ee:	bf06      	itte	eq
 80a28f0:	4610      	moveq	r0, r2
 80a28f2:	4619      	moveq	r1, r3
 80a28f4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a28f8:	d019      	beq.n	80a292e <__aeabi_dmul+0x24a>
 80a28fa:	ea94 0f0c 	teq	r4, ip
 80a28fe:	d102      	bne.n	80a2906 <__aeabi_dmul+0x222>
 80a2900:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a2904:	d113      	bne.n	80a292e <__aeabi_dmul+0x24a>
 80a2906:	ea95 0f0c 	teq	r5, ip
 80a290a:	d105      	bne.n	80a2918 <__aeabi_dmul+0x234>
 80a290c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a2910:	bf1c      	itt	ne
 80a2912:	4610      	movne	r0, r2
 80a2914:	4619      	movne	r1, r3
 80a2916:	d10a      	bne.n	80a292e <__aeabi_dmul+0x24a>
 80a2918:	ea81 0103 	eor.w	r1, r1, r3
 80a291c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a2920:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a2924:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a2928:	f04f 0000 	mov.w	r0, #0
 80a292c:	bd70      	pop	{r4, r5, r6, pc}
 80a292e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a2932:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a2936:	bd70      	pop	{r4, r5, r6, pc}

080a2938 <__aeabi_ddiv>:
 80a2938:	b570      	push	{r4, r5, r6, lr}
 80a293a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a293e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a2942:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a2946:	bf1d      	ittte	ne
 80a2948:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a294c:	ea94 0f0c 	teqne	r4, ip
 80a2950:	ea95 0f0c 	teqne	r5, ip
 80a2954:	f000 f8a7 	bleq	80a2aa6 <__aeabi_ddiv+0x16e>
 80a2958:	eba4 0405 	sub.w	r4, r4, r5
 80a295c:	ea81 0e03 	eor.w	lr, r1, r3
 80a2960:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a2964:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a2968:	f000 8088 	beq.w	80a2a7c <__aeabi_ddiv+0x144>
 80a296c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a2970:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a2974:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a2978:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a297c:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a2980:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a2984:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a2988:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a298c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a2990:	429d      	cmp	r5, r3
 80a2992:	bf08      	it	eq
 80a2994:	4296      	cmpeq	r6, r2
 80a2996:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a299a:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a299e:	d202      	bcs.n	80a29a6 <__aeabi_ddiv+0x6e>
 80a29a0:	085b      	lsrs	r3, r3, #1
 80a29a2:	ea4f 0232 	mov.w	r2, r2, rrx
 80a29a6:	1ab6      	subs	r6, r6, r2
 80a29a8:	eb65 0503 	sbc.w	r5, r5, r3
 80a29ac:	085b      	lsrs	r3, r3, #1
 80a29ae:	ea4f 0232 	mov.w	r2, r2, rrx
 80a29b2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a29b6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a29ba:	ebb6 0e02 	subs.w	lr, r6, r2
 80a29be:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a29c2:	bf22      	ittt	cs
 80a29c4:	1ab6      	subcs	r6, r6, r2
 80a29c6:	4675      	movcs	r5, lr
 80a29c8:	ea40 000c 	orrcs.w	r0, r0, ip
 80a29cc:	085b      	lsrs	r3, r3, #1
 80a29ce:	ea4f 0232 	mov.w	r2, r2, rrx
 80a29d2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a29d6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a29da:	bf22      	ittt	cs
 80a29dc:	1ab6      	subcs	r6, r6, r2
 80a29de:	4675      	movcs	r5, lr
 80a29e0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a29e4:	085b      	lsrs	r3, r3, #1
 80a29e6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a29ea:	ebb6 0e02 	subs.w	lr, r6, r2
 80a29ee:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a29f2:	bf22      	ittt	cs
 80a29f4:	1ab6      	subcs	r6, r6, r2
 80a29f6:	4675      	movcs	r5, lr
 80a29f8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a29fc:	085b      	lsrs	r3, r3, #1
 80a29fe:	ea4f 0232 	mov.w	r2, r2, rrx
 80a2a02:	ebb6 0e02 	subs.w	lr, r6, r2
 80a2a06:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a2a0a:	bf22      	ittt	cs
 80a2a0c:	1ab6      	subcs	r6, r6, r2
 80a2a0e:	4675      	movcs	r5, lr
 80a2a10:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a2a14:	ea55 0e06 	orrs.w	lr, r5, r6
 80a2a18:	d018      	beq.n	80a2a4c <__aeabi_ddiv+0x114>
 80a2a1a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a2a1e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a2a22:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a2a26:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a2a2a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a2a2e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a2a32:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a2a36:	d1c0      	bne.n	80a29ba <__aeabi_ddiv+0x82>
 80a2a38:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a2a3c:	d10b      	bne.n	80a2a56 <__aeabi_ddiv+0x11e>
 80a2a3e:	ea41 0100 	orr.w	r1, r1, r0
 80a2a42:	f04f 0000 	mov.w	r0, #0
 80a2a46:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a2a4a:	e7b6      	b.n	80a29ba <__aeabi_ddiv+0x82>
 80a2a4c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a2a50:	bf04      	itt	eq
 80a2a52:	4301      	orreq	r1, r0
 80a2a54:	2000      	moveq	r0, #0
 80a2a56:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a2a5a:	bf88      	it	hi
 80a2a5c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a2a60:	f63f aeaf 	bhi.w	80a27c2 <__aeabi_dmul+0xde>
 80a2a64:	ebb5 0c03 	subs.w	ip, r5, r3
 80a2a68:	bf04      	itt	eq
 80a2a6a:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a2a6e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a2a72:	f150 0000 	adcs.w	r0, r0, #0
 80a2a76:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a2a7a:	bd70      	pop	{r4, r5, r6, pc}
 80a2a7c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a2a80:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a2a84:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a2a88:	bfc2      	ittt	gt
 80a2a8a:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a2a8e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a2a92:	bd70      	popgt	{r4, r5, r6, pc}
 80a2a94:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a2a98:	f04f 0e00 	mov.w	lr, #0
 80a2a9c:	3c01      	subs	r4, #1
 80a2a9e:	e690      	b.n	80a27c2 <__aeabi_dmul+0xde>
 80a2aa0:	ea45 0e06 	orr.w	lr, r5, r6
 80a2aa4:	e68d      	b.n	80a27c2 <__aeabi_dmul+0xde>
 80a2aa6:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a2aaa:	ea94 0f0c 	teq	r4, ip
 80a2aae:	bf08      	it	eq
 80a2ab0:	ea95 0f0c 	teqeq	r5, ip
 80a2ab4:	f43f af3b 	beq.w	80a292e <__aeabi_dmul+0x24a>
 80a2ab8:	ea94 0f0c 	teq	r4, ip
 80a2abc:	d10a      	bne.n	80a2ad4 <__aeabi_ddiv+0x19c>
 80a2abe:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a2ac2:	f47f af34 	bne.w	80a292e <__aeabi_dmul+0x24a>
 80a2ac6:	ea95 0f0c 	teq	r5, ip
 80a2aca:	f47f af25 	bne.w	80a2918 <__aeabi_dmul+0x234>
 80a2ace:	4610      	mov	r0, r2
 80a2ad0:	4619      	mov	r1, r3
 80a2ad2:	e72c      	b.n	80a292e <__aeabi_dmul+0x24a>
 80a2ad4:	ea95 0f0c 	teq	r5, ip
 80a2ad8:	d106      	bne.n	80a2ae8 <__aeabi_ddiv+0x1b0>
 80a2ada:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a2ade:	f43f aefd 	beq.w	80a28dc <__aeabi_dmul+0x1f8>
 80a2ae2:	4610      	mov	r0, r2
 80a2ae4:	4619      	mov	r1, r3
 80a2ae6:	e722      	b.n	80a292e <__aeabi_dmul+0x24a>
 80a2ae8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a2aec:	bf18      	it	ne
 80a2aee:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a2af2:	f47f aec5 	bne.w	80a2880 <__aeabi_dmul+0x19c>
 80a2af6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a2afa:	f47f af0d 	bne.w	80a2918 <__aeabi_dmul+0x234>
 80a2afe:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a2b02:	f47f aeeb 	bne.w	80a28dc <__aeabi_dmul+0x1f8>
 80a2b06:	e712      	b.n	80a292e <__aeabi_dmul+0x24a>

080a2b08 <__gedf2>:
 80a2b08:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 80a2b0c:	e006      	b.n	80a2b1c <__cmpdf2+0x4>
 80a2b0e:	bf00      	nop

080a2b10 <__ledf2>:
 80a2b10:	f04f 0c01 	mov.w	ip, #1
 80a2b14:	e002      	b.n	80a2b1c <__cmpdf2+0x4>
 80a2b16:	bf00      	nop

080a2b18 <__cmpdf2>:
 80a2b18:	f04f 0c01 	mov.w	ip, #1
 80a2b1c:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a2b20:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a2b24:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a2b28:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a2b2c:	bf18      	it	ne
 80a2b2e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80a2b32:	d01b      	beq.n	80a2b6c <__cmpdf2+0x54>
 80a2b34:	b001      	add	sp, #4
 80a2b36:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80a2b3a:	bf0c      	ite	eq
 80a2b3c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80a2b40:	ea91 0f03 	teqne	r1, r3
 80a2b44:	bf02      	ittt	eq
 80a2b46:	ea90 0f02 	teqeq	r0, r2
 80a2b4a:	2000      	moveq	r0, #0
 80a2b4c:	4770      	bxeq	lr
 80a2b4e:	f110 0f00 	cmn.w	r0, #0
 80a2b52:	ea91 0f03 	teq	r1, r3
 80a2b56:	bf58      	it	pl
 80a2b58:	4299      	cmppl	r1, r3
 80a2b5a:	bf08      	it	eq
 80a2b5c:	4290      	cmpeq	r0, r2
 80a2b5e:	bf2c      	ite	cs
 80a2b60:	17d8      	asrcs	r0, r3, #31
 80a2b62:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80a2b66:	f040 0001 	orr.w	r0, r0, #1
 80a2b6a:	4770      	bx	lr
 80a2b6c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a2b70:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a2b74:	d102      	bne.n	80a2b7c <__cmpdf2+0x64>
 80a2b76:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a2b7a:	d107      	bne.n	80a2b8c <__cmpdf2+0x74>
 80a2b7c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a2b80:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a2b84:	d1d6      	bne.n	80a2b34 <__cmpdf2+0x1c>
 80a2b86:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a2b8a:	d0d3      	beq.n	80a2b34 <__cmpdf2+0x1c>
 80a2b8c:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a2b90:	4770      	bx	lr
 80a2b92:	bf00      	nop

080a2b94 <__aeabi_cdrcmple>:
 80a2b94:	4684      	mov	ip, r0
 80a2b96:	4610      	mov	r0, r2
 80a2b98:	4662      	mov	r2, ip
 80a2b9a:	468c      	mov	ip, r1
 80a2b9c:	4619      	mov	r1, r3
 80a2b9e:	4663      	mov	r3, ip
 80a2ba0:	e000      	b.n	80a2ba4 <__aeabi_cdcmpeq>
 80a2ba2:	bf00      	nop

080a2ba4 <__aeabi_cdcmpeq>:
 80a2ba4:	b501      	push	{r0, lr}
 80a2ba6:	f7ff ffb7 	bl	80a2b18 <__cmpdf2>
 80a2baa:	2800      	cmp	r0, #0
 80a2bac:	bf48      	it	mi
 80a2bae:	f110 0f00 	cmnmi.w	r0, #0
 80a2bb2:	bd01      	pop	{r0, pc}

080a2bb4 <__aeabi_dcmpeq>:
 80a2bb4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a2bb8:	f7ff fff4 	bl	80a2ba4 <__aeabi_cdcmpeq>
 80a2bbc:	bf0c      	ite	eq
 80a2bbe:	2001      	moveq	r0, #1
 80a2bc0:	2000      	movne	r0, #0
 80a2bc2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a2bc6:	bf00      	nop

080a2bc8 <__aeabi_dcmplt>:
 80a2bc8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a2bcc:	f7ff ffea 	bl	80a2ba4 <__aeabi_cdcmpeq>
 80a2bd0:	bf34      	ite	cc
 80a2bd2:	2001      	movcc	r0, #1
 80a2bd4:	2000      	movcs	r0, #0
 80a2bd6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a2bda:	bf00      	nop

080a2bdc <__aeabi_dcmple>:
 80a2bdc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a2be0:	f7ff ffe0 	bl	80a2ba4 <__aeabi_cdcmpeq>
 80a2be4:	bf94      	ite	ls
 80a2be6:	2001      	movls	r0, #1
 80a2be8:	2000      	movhi	r0, #0
 80a2bea:	f85d fb08 	ldr.w	pc, [sp], #8
 80a2bee:	bf00      	nop

080a2bf0 <__aeabi_dcmpge>:
 80a2bf0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a2bf4:	f7ff ffce 	bl	80a2b94 <__aeabi_cdrcmple>
 80a2bf8:	bf94      	ite	ls
 80a2bfa:	2001      	movls	r0, #1
 80a2bfc:	2000      	movhi	r0, #0
 80a2bfe:	f85d fb08 	ldr.w	pc, [sp], #8
 80a2c02:	bf00      	nop

080a2c04 <__aeabi_dcmpgt>:
 80a2c04:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a2c08:	f7ff ffc4 	bl	80a2b94 <__aeabi_cdrcmple>
 80a2c0c:	bf34      	ite	cc
 80a2c0e:	2001      	movcc	r0, #1
 80a2c10:	2000      	movcs	r0, #0
 80a2c12:	f85d fb08 	ldr.w	pc, [sp], #8
 80a2c16:	bf00      	nop

080a2c18 <__aeabi_dcmpun>:
 80a2c18:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a2c1c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a2c20:	d102      	bne.n	80a2c28 <__aeabi_dcmpun+0x10>
 80a2c22:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a2c26:	d10a      	bne.n	80a2c3e <__aeabi_dcmpun+0x26>
 80a2c28:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a2c2c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a2c30:	d102      	bne.n	80a2c38 <__aeabi_dcmpun+0x20>
 80a2c32:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a2c36:	d102      	bne.n	80a2c3e <__aeabi_dcmpun+0x26>
 80a2c38:	f04f 0000 	mov.w	r0, #0
 80a2c3c:	4770      	bx	lr
 80a2c3e:	f04f 0001 	mov.w	r0, #1
 80a2c42:	4770      	bx	lr

080a2c44 <__aeabi_d2iz>:
 80a2c44:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a2c48:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a2c4c:	d215      	bcs.n	80a2c7a <__aeabi_d2iz+0x36>
 80a2c4e:	d511      	bpl.n	80a2c74 <__aeabi_d2iz+0x30>
 80a2c50:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a2c54:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a2c58:	d912      	bls.n	80a2c80 <__aeabi_d2iz+0x3c>
 80a2c5a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a2c5e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a2c62:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a2c66:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a2c6a:	fa23 f002 	lsr.w	r0, r3, r2
 80a2c6e:	bf18      	it	ne
 80a2c70:	4240      	negne	r0, r0
 80a2c72:	4770      	bx	lr
 80a2c74:	f04f 0000 	mov.w	r0, #0
 80a2c78:	4770      	bx	lr
 80a2c7a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a2c7e:	d105      	bne.n	80a2c8c <__aeabi_d2iz+0x48>
 80a2c80:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80a2c84:	bf08      	it	eq
 80a2c86:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a2c8a:	4770      	bx	lr
 80a2c8c:	f04f 0000 	mov.w	r0, #0
 80a2c90:	4770      	bx	lr
 80a2c92:	bf00      	nop

080a2c94 <__aeabi_d2uiz>:
 80a2c94:	004a      	lsls	r2, r1, #1
 80a2c96:	d211      	bcs.n	80a2cbc <__aeabi_d2uiz+0x28>
 80a2c98:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a2c9c:	d211      	bcs.n	80a2cc2 <__aeabi_d2uiz+0x2e>
 80a2c9e:	d50d      	bpl.n	80a2cbc <__aeabi_d2uiz+0x28>
 80a2ca0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a2ca4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a2ca8:	d40e      	bmi.n	80a2cc8 <__aeabi_d2uiz+0x34>
 80a2caa:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a2cae:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a2cb2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a2cb6:	fa23 f002 	lsr.w	r0, r3, r2
 80a2cba:	4770      	bx	lr
 80a2cbc:	f04f 0000 	mov.w	r0, #0
 80a2cc0:	4770      	bx	lr
 80a2cc2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a2cc6:	d102      	bne.n	80a2cce <__aeabi_d2uiz+0x3a>
 80a2cc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a2ccc:	4770      	bx	lr
 80a2cce:	f04f 0000 	mov.w	r0, #0
 80a2cd2:	4770      	bx	lr

080a2cd4 <__aeabi_d2f>:
 80a2cd4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a2cd8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80a2cdc:	bf24      	itt	cs
 80a2cde:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80a2ce2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80a2ce6:	d90d      	bls.n	80a2d04 <__aeabi_d2f+0x30>
 80a2ce8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a2cec:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80a2cf0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80a2cf4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80a2cf8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80a2cfc:	bf08      	it	eq
 80a2cfe:	f020 0001 	biceq.w	r0, r0, #1
 80a2d02:	4770      	bx	lr
 80a2d04:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80a2d08:	d121      	bne.n	80a2d4e <__aeabi_d2f+0x7a>
 80a2d0a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80a2d0e:	bfbc      	itt	lt
 80a2d10:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80a2d14:	4770      	bxlt	lr
 80a2d16:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a2d1a:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80a2d1e:	f1c2 0218 	rsb	r2, r2, #24
 80a2d22:	f1c2 0c20 	rsb	ip, r2, #32
 80a2d26:	fa10 f30c 	lsls.w	r3, r0, ip
 80a2d2a:	fa20 f002 	lsr.w	r0, r0, r2
 80a2d2e:	bf18      	it	ne
 80a2d30:	f040 0001 	orrne.w	r0, r0, #1
 80a2d34:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a2d38:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80a2d3c:	fa03 fc0c 	lsl.w	ip, r3, ip
 80a2d40:	ea40 000c 	orr.w	r0, r0, ip
 80a2d44:	fa23 f302 	lsr.w	r3, r3, r2
 80a2d48:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80a2d4c:	e7cc      	b.n	80a2ce8 <__aeabi_d2f+0x14>
 80a2d4e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80a2d52:	d107      	bne.n	80a2d64 <__aeabi_d2f+0x90>
 80a2d54:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80a2d58:	bf1e      	ittt	ne
 80a2d5a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 80a2d5e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 80a2d62:	4770      	bxne	lr
 80a2d64:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 80a2d68:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a2d6c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a2d70:	4770      	bx	lr
 80a2d72:	bf00      	nop

080a2d74 <__aeabi_frsub>:
 80a2d74:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a2d78:	e002      	b.n	80a2d80 <__addsf3>
 80a2d7a:	bf00      	nop

080a2d7c <__aeabi_fsub>:
 80a2d7c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a2d80 <__addsf3>:
 80a2d80:	0042      	lsls	r2, r0, #1
 80a2d82:	bf1f      	itttt	ne
 80a2d84:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a2d88:	ea92 0f03 	teqne	r2, r3
 80a2d8c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a2d90:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a2d94:	d06a      	beq.n	80a2e6c <__addsf3+0xec>
 80a2d96:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a2d9a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a2d9e:	bfc1      	itttt	gt
 80a2da0:	18d2      	addgt	r2, r2, r3
 80a2da2:	4041      	eorgt	r1, r0
 80a2da4:	4048      	eorgt	r0, r1
 80a2da6:	4041      	eorgt	r1, r0
 80a2da8:	bfb8      	it	lt
 80a2daa:	425b      	neglt	r3, r3
 80a2dac:	2b19      	cmp	r3, #25
 80a2dae:	bf88      	it	hi
 80a2db0:	4770      	bxhi	lr
 80a2db2:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a2db6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a2dba:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a2dbe:	bf18      	it	ne
 80a2dc0:	4240      	negne	r0, r0
 80a2dc2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a2dc6:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a2dca:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a2dce:	bf18      	it	ne
 80a2dd0:	4249      	negne	r1, r1
 80a2dd2:	ea92 0f03 	teq	r2, r3
 80a2dd6:	d03f      	beq.n	80a2e58 <__addsf3+0xd8>
 80a2dd8:	f1a2 0201 	sub.w	r2, r2, #1
 80a2ddc:	fa41 fc03 	asr.w	ip, r1, r3
 80a2de0:	eb10 000c 	adds.w	r0, r0, ip
 80a2de4:	f1c3 0320 	rsb	r3, r3, #32
 80a2de8:	fa01 f103 	lsl.w	r1, r1, r3
 80a2dec:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a2df0:	d502      	bpl.n	80a2df8 <__addsf3+0x78>
 80a2df2:	4249      	negs	r1, r1
 80a2df4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a2df8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a2dfc:	d313      	bcc.n	80a2e26 <__addsf3+0xa6>
 80a2dfe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a2e02:	d306      	bcc.n	80a2e12 <__addsf3+0x92>
 80a2e04:	0840      	lsrs	r0, r0, #1
 80a2e06:	ea4f 0131 	mov.w	r1, r1, rrx
 80a2e0a:	f102 0201 	add.w	r2, r2, #1
 80a2e0e:	2afe      	cmp	r2, #254	; 0xfe
 80a2e10:	d251      	bcs.n	80a2eb6 <__addsf3+0x136>
 80a2e12:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a2e16:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a2e1a:	bf08      	it	eq
 80a2e1c:	f020 0001 	biceq.w	r0, r0, #1
 80a2e20:	ea40 0003 	orr.w	r0, r0, r3
 80a2e24:	4770      	bx	lr
 80a2e26:	0049      	lsls	r1, r1, #1
 80a2e28:	eb40 0000 	adc.w	r0, r0, r0
 80a2e2c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80a2e30:	f1a2 0201 	sub.w	r2, r2, #1
 80a2e34:	d1ed      	bne.n	80a2e12 <__addsf3+0x92>
 80a2e36:	fab0 fc80 	clz	ip, r0
 80a2e3a:	f1ac 0c08 	sub.w	ip, ip, #8
 80a2e3e:	ebb2 020c 	subs.w	r2, r2, ip
 80a2e42:	fa00 f00c 	lsl.w	r0, r0, ip
 80a2e46:	bfaa      	itet	ge
 80a2e48:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a2e4c:	4252      	neglt	r2, r2
 80a2e4e:	4318      	orrge	r0, r3
 80a2e50:	bfbc      	itt	lt
 80a2e52:	40d0      	lsrlt	r0, r2
 80a2e54:	4318      	orrlt	r0, r3
 80a2e56:	4770      	bx	lr
 80a2e58:	f092 0f00 	teq	r2, #0
 80a2e5c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a2e60:	bf06      	itte	eq
 80a2e62:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a2e66:	3201      	addeq	r2, #1
 80a2e68:	3b01      	subne	r3, #1
 80a2e6a:	e7b5      	b.n	80a2dd8 <__addsf3+0x58>
 80a2e6c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a2e70:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a2e74:	bf18      	it	ne
 80a2e76:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a2e7a:	d021      	beq.n	80a2ec0 <__addsf3+0x140>
 80a2e7c:	ea92 0f03 	teq	r2, r3
 80a2e80:	d004      	beq.n	80a2e8c <__addsf3+0x10c>
 80a2e82:	f092 0f00 	teq	r2, #0
 80a2e86:	bf08      	it	eq
 80a2e88:	4608      	moveq	r0, r1
 80a2e8a:	4770      	bx	lr
 80a2e8c:	ea90 0f01 	teq	r0, r1
 80a2e90:	bf1c      	itt	ne
 80a2e92:	2000      	movne	r0, #0
 80a2e94:	4770      	bxne	lr
 80a2e96:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a2e9a:	d104      	bne.n	80a2ea6 <__addsf3+0x126>
 80a2e9c:	0040      	lsls	r0, r0, #1
 80a2e9e:	bf28      	it	cs
 80a2ea0:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a2ea4:	4770      	bx	lr
 80a2ea6:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a2eaa:	bf3c      	itt	cc
 80a2eac:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a2eb0:	4770      	bxcc	lr
 80a2eb2:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a2eb6:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a2eba:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a2ebe:	4770      	bx	lr
 80a2ec0:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a2ec4:	bf16      	itet	ne
 80a2ec6:	4608      	movne	r0, r1
 80a2ec8:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a2ecc:	4601      	movne	r1, r0
 80a2ece:	0242      	lsls	r2, r0, #9
 80a2ed0:	bf06      	itte	eq
 80a2ed2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a2ed6:	ea90 0f01 	teqeq	r0, r1
 80a2eda:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a2ede:	4770      	bx	lr

080a2ee0 <__aeabi_ui2f>:
 80a2ee0:	f04f 0300 	mov.w	r3, #0
 80a2ee4:	e004      	b.n	80a2ef0 <__aeabi_i2f+0x8>
 80a2ee6:	bf00      	nop

080a2ee8 <__aeabi_i2f>:
 80a2ee8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a2eec:	bf48      	it	mi
 80a2eee:	4240      	negmi	r0, r0
 80a2ef0:	ea5f 0c00 	movs.w	ip, r0
 80a2ef4:	bf08      	it	eq
 80a2ef6:	4770      	bxeq	lr
 80a2ef8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a2efc:	4601      	mov	r1, r0
 80a2efe:	f04f 0000 	mov.w	r0, #0
 80a2f02:	e01c      	b.n	80a2f3e <__aeabi_l2f+0x2a>

080a2f04 <__aeabi_ul2f>:
 80a2f04:	ea50 0201 	orrs.w	r2, r0, r1
 80a2f08:	bf08      	it	eq
 80a2f0a:	4770      	bxeq	lr
 80a2f0c:	f04f 0300 	mov.w	r3, #0
 80a2f10:	e00a      	b.n	80a2f28 <__aeabi_l2f+0x14>
 80a2f12:	bf00      	nop

080a2f14 <__aeabi_l2f>:
 80a2f14:	ea50 0201 	orrs.w	r2, r0, r1
 80a2f18:	bf08      	it	eq
 80a2f1a:	4770      	bxeq	lr
 80a2f1c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a2f20:	d502      	bpl.n	80a2f28 <__aeabi_l2f+0x14>
 80a2f22:	4240      	negs	r0, r0
 80a2f24:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a2f28:	ea5f 0c01 	movs.w	ip, r1
 80a2f2c:	bf02      	ittt	eq
 80a2f2e:	4684      	moveq	ip, r0
 80a2f30:	4601      	moveq	r1, r0
 80a2f32:	2000      	moveq	r0, #0
 80a2f34:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a2f38:	bf08      	it	eq
 80a2f3a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a2f3e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a2f42:	fabc f28c 	clz	r2, ip
 80a2f46:	3a08      	subs	r2, #8
 80a2f48:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a2f4c:	db10      	blt.n	80a2f70 <__aeabi_l2f+0x5c>
 80a2f4e:	fa01 fc02 	lsl.w	ip, r1, r2
 80a2f52:	4463      	add	r3, ip
 80a2f54:	fa00 fc02 	lsl.w	ip, r0, r2
 80a2f58:	f1c2 0220 	rsb	r2, r2, #32
 80a2f5c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a2f60:	fa20 f202 	lsr.w	r2, r0, r2
 80a2f64:	eb43 0002 	adc.w	r0, r3, r2
 80a2f68:	bf08      	it	eq
 80a2f6a:	f020 0001 	biceq.w	r0, r0, #1
 80a2f6e:	4770      	bx	lr
 80a2f70:	f102 0220 	add.w	r2, r2, #32
 80a2f74:	fa01 fc02 	lsl.w	ip, r1, r2
 80a2f78:	f1c2 0220 	rsb	r2, r2, #32
 80a2f7c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a2f80:	fa21 f202 	lsr.w	r2, r1, r2
 80a2f84:	eb43 0002 	adc.w	r0, r3, r2
 80a2f88:	bf08      	it	eq
 80a2f8a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a2f8e:	4770      	bx	lr

080a2f90 <__aeabi_fmul>:
 80a2f90:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a2f94:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a2f98:	bf1e      	ittt	ne
 80a2f9a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a2f9e:	ea92 0f0c 	teqne	r2, ip
 80a2fa2:	ea93 0f0c 	teqne	r3, ip
 80a2fa6:	d06f      	beq.n	80a3088 <__aeabi_fmul+0xf8>
 80a2fa8:	441a      	add	r2, r3
 80a2faa:	ea80 0c01 	eor.w	ip, r0, r1
 80a2fae:	0240      	lsls	r0, r0, #9
 80a2fb0:	bf18      	it	ne
 80a2fb2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a2fb6:	d01e      	beq.n	80a2ff6 <__aeabi_fmul+0x66>
 80a2fb8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a2fbc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a2fc0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a2fc4:	fba0 3101 	umull	r3, r1, r0, r1
 80a2fc8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a2fcc:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a2fd0:	bf3e      	ittt	cc
 80a2fd2:	0049      	lslcc	r1, r1, #1
 80a2fd4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a2fd8:	005b      	lslcc	r3, r3, #1
 80a2fda:	ea40 0001 	orr.w	r0, r0, r1
 80a2fde:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a2fe2:	2afd      	cmp	r2, #253	; 0xfd
 80a2fe4:	d81d      	bhi.n	80a3022 <__aeabi_fmul+0x92>
 80a2fe6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a2fea:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a2fee:	bf08      	it	eq
 80a2ff0:	f020 0001 	biceq.w	r0, r0, #1
 80a2ff4:	4770      	bx	lr
 80a2ff6:	f090 0f00 	teq	r0, #0
 80a2ffa:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a2ffe:	bf08      	it	eq
 80a3000:	0249      	lsleq	r1, r1, #9
 80a3002:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a3006:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a300a:	3a7f      	subs	r2, #127	; 0x7f
 80a300c:	bfc2      	ittt	gt
 80a300e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a3012:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a3016:	4770      	bxgt	lr
 80a3018:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a301c:	f04f 0300 	mov.w	r3, #0
 80a3020:	3a01      	subs	r2, #1
 80a3022:	dc5d      	bgt.n	80a30e0 <__aeabi_fmul+0x150>
 80a3024:	f112 0f19 	cmn.w	r2, #25
 80a3028:	bfdc      	itt	le
 80a302a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a302e:	4770      	bxle	lr
 80a3030:	f1c2 0200 	rsb	r2, r2, #0
 80a3034:	0041      	lsls	r1, r0, #1
 80a3036:	fa21 f102 	lsr.w	r1, r1, r2
 80a303a:	f1c2 0220 	rsb	r2, r2, #32
 80a303e:	fa00 fc02 	lsl.w	ip, r0, r2
 80a3042:	ea5f 0031 	movs.w	r0, r1, rrx
 80a3046:	f140 0000 	adc.w	r0, r0, #0
 80a304a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a304e:	bf08      	it	eq
 80a3050:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a3054:	4770      	bx	lr
 80a3056:	f092 0f00 	teq	r2, #0
 80a305a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a305e:	bf02      	ittt	eq
 80a3060:	0040      	lsleq	r0, r0, #1
 80a3062:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a3066:	3a01      	subeq	r2, #1
 80a3068:	d0f9      	beq.n	80a305e <__aeabi_fmul+0xce>
 80a306a:	ea40 000c 	orr.w	r0, r0, ip
 80a306e:	f093 0f00 	teq	r3, #0
 80a3072:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a3076:	bf02      	ittt	eq
 80a3078:	0049      	lsleq	r1, r1, #1
 80a307a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a307e:	3b01      	subeq	r3, #1
 80a3080:	d0f9      	beq.n	80a3076 <__aeabi_fmul+0xe6>
 80a3082:	ea41 010c 	orr.w	r1, r1, ip
 80a3086:	e78f      	b.n	80a2fa8 <__aeabi_fmul+0x18>
 80a3088:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a308c:	ea92 0f0c 	teq	r2, ip
 80a3090:	bf18      	it	ne
 80a3092:	ea93 0f0c 	teqne	r3, ip
 80a3096:	d00a      	beq.n	80a30ae <__aeabi_fmul+0x11e>
 80a3098:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a309c:	bf18      	it	ne
 80a309e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a30a2:	d1d8      	bne.n	80a3056 <__aeabi_fmul+0xc6>
 80a30a4:	ea80 0001 	eor.w	r0, r0, r1
 80a30a8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a30ac:	4770      	bx	lr
 80a30ae:	f090 0f00 	teq	r0, #0
 80a30b2:	bf17      	itett	ne
 80a30b4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a30b8:	4608      	moveq	r0, r1
 80a30ba:	f091 0f00 	teqne	r1, #0
 80a30be:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a30c2:	d014      	beq.n	80a30ee <__aeabi_fmul+0x15e>
 80a30c4:	ea92 0f0c 	teq	r2, ip
 80a30c8:	d101      	bne.n	80a30ce <__aeabi_fmul+0x13e>
 80a30ca:	0242      	lsls	r2, r0, #9
 80a30cc:	d10f      	bne.n	80a30ee <__aeabi_fmul+0x15e>
 80a30ce:	ea93 0f0c 	teq	r3, ip
 80a30d2:	d103      	bne.n	80a30dc <__aeabi_fmul+0x14c>
 80a30d4:	024b      	lsls	r3, r1, #9
 80a30d6:	bf18      	it	ne
 80a30d8:	4608      	movne	r0, r1
 80a30da:	d108      	bne.n	80a30ee <__aeabi_fmul+0x15e>
 80a30dc:	ea80 0001 	eor.w	r0, r0, r1
 80a30e0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a30e4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a30e8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a30ec:	4770      	bx	lr
 80a30ee:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a30f2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a30f6:	4770      	bx	lr

080a30f8 <__aeabi_fdiv>:
 80a30f8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a30fc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a3100:	bf1e      	ittt	ne
 80a3102:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a3106:	ea92 0f0c 	teqne	r2, ip
 80a310a:	ea93 0f0c 	teqne	r3, ip
 80a310e:	d069      	beq.n	80a31e4 <__aeabi_fdiv+0xec>
 80a3110:	eba2 0203 	sub.w	r2, r2, r3
 80a3114:	ea80 0c01 	eor.w	ip, r0, r1
 80a3118:	0249      	lsls	r1, r1, #9
 80a311a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a311e:	d037      	beq.n	80a3190 <__aeabi_fdiv+0x98>
 80a3120:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a3124:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a3128:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a312c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a3130:	428b      	cmp	r3, r1
 80a3132:	bf38      	it	cc
 80a3134:	005b      	lslcc	r3, r3, #1
 80a3136:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a313a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a313e:	428b      	cmp	r3, r1
 80a3140:	bf24      	itt	cs
 80a3142:	1a5b      	subcs	r3, r3, r1
 80a3144:	ea40 000c 	orrcs.w	r0, r0, ip
 80a3148:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a314c:	bf24      	itt	cs
 80a314e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a3152:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a3156:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a315a:	bf24      	itt	cs
 80a315c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a3160:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a3164:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a3168:	bf24      	itt	cs
 80a316a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a316e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a3172:	011b      	lsls	r3, r3, #4
 80a3174:	bf18      	it	ne
 80a3176:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a317a:	d1e0      	bne.n	80a313e <__aeabi_fdiv+0x46>
 80a317c:	2afd      	cmp	r2, #253	; 0xfd
 80a317e:	f63f af50 	bhi.w	80a3022 <__aeabi_fmul+0x92>
 80a3182:	428b      	cmp	r3, r1
 80a3184:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a3188:	bf08      	it	eq
 80a318a:	f020 0001 	biceq.w	r0, r0, #1
 80a318e:	4770      	bx	lr
 80a3190:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a3194:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a3198:	327f      	adds	r2, #127	; 0x7f
 80a319a:	bfc2      	ittt	gt
 80a319c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a31a0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a31a4:	4770      	bxgt	lr
 80a31a6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a31aa:	f04f 0300 	mov.w	r3, #0
 80a31ae:	3a01      	subs	r2, #1
 80a31b0:	e737      	b.n	80a3022 <__aeabi_fmul+0x92>
 80a31b2:	f092 0f00 	teq	r2, #0
 80a31b6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a31ba:	bf02      	ittt	eq
 80a31bc:	0040      	lsleq	r0, r0, #1
 80a31be:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a31c2:	3a01      	subeq	r2, #1
 80a31c4:	d0f9      	beq.n	80a31ba <__aeabi_fdiv+0xc2>
 80a31c6:	ea40 000c 	orr.w	r0, r0, ip
 80a31ca:	f093 0f00 	teq	r3, #0
 80a31ce:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a31d2:	bf02      	ittt	eq
 80a31d4:	0049      	lsleq	r1, r1, #1
 80a31d6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a31da:	3b01      	subeq	r3, #1
 80a31dc:	d0f9      	beq.n	80a31d2 <__aeabi_fdiv+0xda>
 80a31de:	ea41 010c 	orr.w	r1, r1, ip
 80a31e2:	e795      	b.n	80a3110 <__aeabi_fdiv+0x18>
 80a31e4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a31e8:	ea92 0f0c 	teq	r2, ip
 80a31ec:	d108      	bne.n	80a3200 <__aeabi_fdiv+0x108>
 80a31ee:	0242      	lsls	r2, r0, #9
 80a31f0:	f47f af7d 	bne.w	80a30ee <__aeabi_fmul+0x15e>
 80a31f4:	ea93 0f0c 	teq	r3, ip
 80a31f8:	f47f af70 	bne.w	80a30dc <__aeabi_fmul+0x14c>
 80a31fc:	4608      	mov	r0, r1
 80a31fe:	e776      	b.n	80a30ee <__aeabi_fmul+0x15e>
 80a3200:	ea93 0f0c 	teq	r3, ip
 80a3204:	d104      	bne.n	80a3210 <__aeabi_fdiv+0x118>
 80a3206:	024b      	lsls	r3, r1, #9
 80a3208:	f43f af4c 	beq.w	80a30a4 <__aeabi_fmul+0x114>
 80a320c:	4608      	mov	r0, r1
 80a320e:	e76e      	b.n	80a30ee <__aeabi_fmul+0x15e>
 80a3210:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a3214:	bf18      	it	ne
 80a3216:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a321a:	d1ca      	bne.n	80a31b2 <__aeabi_fdiv+0xba>
 80a321c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a3220:	f47f af5c 	bne.w	80a30dc <__aeabi_fmul+0x14c>
 80a3224:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a3228:	f47f af3c 	bne.w	80a30a4 <__aeabi_fmul+0x114>
 80a322c:	e75f      	b.n	80a30ee <__aeabi_fmul+0x15e>
 80a322e:	bf00      	nop

080a3230 <__cxa_atexit>:
 80a3230:	b510      	push	{r4, lr}
 80a3232:	4c05      	ldr	r4, [pc, #20]	; (80a3248 <__cxa_atexit+0x18>)
 80a3234:	4613      	mov	r3, r2
 80a3236:	b12c      	cbz	r4, 80a3244 <__cxa_atexit+0x14>
 80a3238:	460a      	mov	r2, r1
 80a323a:	4601      	mov	r1, r0
 80a323c:	2002      	movs	r0, #2
 80a323e:	f3af 8000 	nop.w
 80a3242:	bd10      	pop	{r4, pc}
 80a3244:	4620      	mov	r0, r4
 80a3246:	bd10      	pop	{r4, pc}
 80a3248:	00000000 	.word	0x00000000

080a324c <memcpy>:
 80a324c:	b510      	push	{r4, lr}
 80a324e:	1e43      	subs	r3, r0, #1
 80a3250:	440a      	add	r2, r1
 80a3252:	4291      	cmp	r1, r2
 80a3254:	d004      	beq.n	80a3260 <memcpy+0x14>
 80a3256:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a325a:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a325e:	e7f8      	b.n	80a3252 <memcpy+0x6>
 80a3260:	bd10      	pop	{r4, pc}

080a3262 <memset>:
 80a3262:	4603      	mov	r3, r0
 80a3264:	4402      	add	r2, r0
 80a3266:	4293      	cmp	r3, r2
 80a3268:	d002      	beq.n	80a3270 <memset+0xe>
 80a326a:	f803 1b01 	strb.w	r1, [r3], #1
 80a326e:	e7fa      	b.n	80a3266 <memset+0x4>
 80a3270:	4770      	bx	lr
	...

080a3274 <srand>:
 80a3274:	b538      	push	{r3, r4, r5, lr}
 80a3276:	4b12      	ldr	r3, [pc, #72]	; (80a32c0 <srand+0x4c>)
 80a3278:	4605      	mov	r5, r0
 80a327a:	681c      	ldr	r4, [r3, #0]
 80a327c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a327e:	b9d3      	cbnz	r3, 80a32b6 <srand+0x42>
 80a3280:	2018      	movs	r0, #24
 80a3282:	f7fd fd65 	bl	80a0d50 <malloc>
 80a3286:	f243 330e 	movw	r3, #13070	; 0x330e
 80a328a:	63a0      	str	r0, [r4, #56]	; 0x38
 80a328c:	8003      	strh	r3, [r0, #0]
 80a328e:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a3292:	8043      	strh	r3, [r0, #2]
 80a3294:	f241 2334 	movw	r3, #4660	; 0x1234
 80a3298:	8083      	strh	r3, [r0, #4]
 80a329a:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a329e:	80c3      	strh	r3, [r0, #6]
 80a32a0:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a32a4:	8103      	strh	r3, [r0, #8]
 80a32a6:	2305      	movs	r3, #5
 80a32a8:	8143      	strh	r3, [r0, #10]
 80a32aa:	230b      	movs	r3, #11
 80a32ac:	8183      	strh	r3, [r0, #12]
 80a32ae:	2201      	movs	r2, #1
 80a32b0:	2300      	movs	r3, #0
 80a32b2:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a32b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a32b8:	2200      	movs	r2, #0
 80a32ba:	611d      	str	r5, [r3, #16]
 80a32bc:	615a      	str	r2, [r3, #20]
 80a32be:	bd38      	pop	{r3, r4, r5, pc}
 80a32c0:	2000006c 	.word	0x2000006c

080a32c4 <strlen>:
 80a32c4:	4603      	mov	r3, r0
 80a32c6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a32ca:	2a00      	cmp	r2, #0
 80a32cc:	d1fb      	bne.n	80a32c6 <strlen+0x2>
 80a32ce:	1a18      	subs	r0, r3, r0
 80a32d0:	3801      	subs	r0, #1
 80a32d2:	4770      	bx	lr

080a32d4 <dynalib_user>:
 80a32d4:	0021 080a 0061 080a 008d 080a 0091 080a     !...a...........
 80a32e4:	0000 0000 504d 334c 3131 4135 2032 6f46     ....MPL3115A2 Fo
 80a32f4:	6e75 0064 6953 3037 3132 4620 756f 646e     und.Si7021 Found
 80a3304:	4800 5554 3132 2044 6f46 6e75 0064 504d     .HTU21D Found.MP
 80a3314:	334c 3131 4135 2032 4f4e 2054 6f46 6e75     L3115A2 NOT Foun
 80a3324:	0064 6f4e 5420 6d65 2f70 7548 696d 6964     d.No Temp/Humidi
 80a3334:	7974 4420 7665 6369 2065 6544 6574 7463     ty Device Detect
 80a3344:	6465 4e00 206f 6544 6976 6563 2073 6544     ed.No Devices De
 80a3354:	6574 7463 6465 c000 01a8 4331 6e6f 6574     tected....1Conte
 80a3364:	746e 4c2d 6e65 7467 3a68 2520 0064 6f63     nt-Length: %d.co
 80a3374:	6e6e 6365 6574 0064 4f50 5453 2f20 6577     nnected.POST /we
 80a3384:	7461 6568 2072 5448 5054 312f 312e 4800     ather HTTP/1.1.H
 80a3394:	736f 3a74 3120 3239 312e 3836 312e 342e     ost: 192.168.1.4
 80a33a4:	3a39 3033 3130 4300 6e6f 6574 746e 542d     9:3001.Content-T
 80a33b4:	7079 3a65 6120 7070 696c 6163 6974 6e6f     ype: application
 80a33c4:	6a2f 6f73 006e 6e55 6261 656c 5420 206f     /json.Unable To 
 80a33d4:	6f43 6e6e 6365 0074 2c46 0020 7548 696d     Connect.F, .Humi
 80a33e4:	6964 7974 003a 2c25 0020 6142 6f72 545f     dity:.%, .Baro_T
 80a33f4:	6d65 3a70 5000 6572 7373 7275 3a65 6800     emp:.Pressure:.h
 80a3404:	6150 202c 6800 6d75 6469 7469 0079 6162     Pa, .humidity.ba
 80a3414:	6f72 745f 6d65 0070 7270 7365 7573 6572     ro_temp.pressure
 80a3424:	2500 0073 6870 626f 6369 7473 6572 7465     .%s.phobicstreet
 80a3434:	3331 0039 6550 6b72 4d79 7365 0068 0000     139.PerkyMesh...

080a3444 <_ZTV7TwoWire>:
	...
 80a344c:	0db9 080a 0e03 080a 0ddb 080a 0dbb 080a     ................
 80a345c:	0de3 080a 0deb 080a 0df3 080a 0dfb 080a     ................

080a346c <_ZTV9IPAddress>:
	...
 80a3474:	0ecf 080a 0ebf 080a 0ec1 080a               ............

080a3480 <_ZTVN5spark16JSONBufferWriterE>:
	...
 80a3488:	0fb1 080a 0fb3 080a 0fc1 080a 0fe7 080a     ................
 80a3498:	2e30 0030 6166 736c 0065 7274 6575 2500     0.0.false.true.%
 80a34a8:	0075 2e25 6c2a 0066 6725 6e00 6c75 006c     u.%.*lf.%g.null.
 80a34b8:	2575 3430 0078 6162 6475 5300 7265 6169     u%04x.baud.Seria
 80a34c8:	006c 5355 5342 7265 6169 316c 7400 7079     l.USBSerial1.typ
 80a34d8:	0065 6170 6172 006d 6d63 0064 6469 6800     e.param.cmd.id.h
 80a34e8:	646e 7300 7274 006d 6966 746c 6c00 6c76     nd.strm.filt.lvl
 80a34f8:	6100 6464 6148 646e 656c 0072 6572 6f6d     .addHandler.remo
 80a3508:	6576 6148 646e 656c 0072 6e65 6d75 6148     veHandler.enumHa
 80a3518:	646e 656c 7372 4a00 4f53 534e 7274 6165     ndlers.JSONStrea
 80a3528:	4c6d 676f 6148 646e 656c 0072 7061 0070     mLogHandler.app.
 80a3538:	3025 3031 2075 5d00 0020 2928 203a 2000     %010u .] .(): . 
 80a3548:	005b 6f63 6564 3d20 0020 6925 6400 7465     [.code = .%i.det
 80a3558:	6961 736c 3d20 0020 0a0d 6c00 006e 6e66     ails = ....ln.fn
 80a3568:	6300 646f 0065 6564 6174 6c69 6e00 6e6f     .code.detail.non
 80a3578:	0065 7274 6361 0065 6e69 6f66 7700 7261     e.trace.info.war
 80a3588:	006e 7265 6f72 0072 6170 696e 0063 6c61     n.error.panic.al
 80a3598:	006c 0000                                   l...

080a359c <_ZTVN5spark12NetworkClassE>:
	...
 80a35a4:	1175 080a 117f 080a 1189 080a 1193 080a     u...............
 80a35b4:	119d 080a 11a9 080a 11b5 080a 11c1 080a     ................
 80a35c4:	11c9 080a 11d3 080a 11dd 080a 616e 006e     ............nan.
 80a35d4:	766f 0066 002e 6e69 0066 0000               ovf...inf...

080a35e0 <_ZTVSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
 80a35e8:	16a1 080a 16a7 080a 1abf 080a 16b5 080a     ................
 80a35f8:	16a3 080a                                   ....

080a35fc <_ZTV9TCPClient>:
	...
 80a3604:	056d 080a 05a1 080a 165d 080a 1677 080a     m.......]...w...
 80a3614:	17bd 080a 1727 080a 16f9 080a 169f 080a     ....'...........
 80a3624:	1869 080a 1ad9 080a 175b 080a 1835 080a     i.......[...5...
 80a3634:	19b7 080a 1a09 080a 1687 080a 197b 080a     ............{...
 80a3644:	16d9 080a 6977 6972 676e 5400 5043 6c43     ....wiring.TCPCl
 80a3654:	6569 746e 7320 636f 656b 3d74 7825 5a00     ient socket=%x.Z
 80a3664:	2500 302b 6433 253a 3230 0075 5925 252d     .%+03d:%02u.%Y-%
 80a3674:	2d6d 6425 2554 3a48 4d25 253a 2553 007a     m-%dT%H:%M:%S%z.
 80a3684:	7361 7463 6d69 0065                         asctime.

080a368c <_ZTV11USARTSerial>:
	...
 80a3694:	1b59 080a 1ba9 080a 1bb7 080a 1259 080a     Y...........Y...
 80a36a4:	1b6d 080a 1b8f 080a 1b7b 080a 1ba3 080a     m.......{.......
 80a36b4:	1b5b 080a 1b5f 080a                         [..._...

080a36bc <_ZTV9USBSerial>:
	...
 80a36c4:	1c59 080a 1ca9 080a 1cb7 080a 1259 080a     Y...........Y...
 80a36d4:	1c95 080a 1c5b 080a 1c71 080a 1ca3 080a     ....[...q.......
 80a36e4:	1c87 080a 1c55 080a                         ....U...

080a36ec <_ZTVN5spark9WiFiClassE>:
	...
 80a36f4:	1e9b 080a 1e91 080a 1e87 080a 1df9 080a     ................
 80a3704:	1e7b 080a 1e6f 080a 1e63 080a 1e5b 080a     {...o...c...[...
 80a3714:	1e51 080a 1e47 080a 1e03 080a               Q...G.......

080a3720 <_ZSt7nothrow>:
 80a3720:	0000 0000                                   ....

080a3724 <__sf_fake_stdin>:
	...

080a3744 <__sf_fake_stdout>:
	...

080a3764 <__sf_fake_stderr>:
	...
 80a3784:	0043                                        C.

080a3786 <link_const_variable_data_end>:
	...

080a3788 <link_constructors_location>:
 80a3788:	080a0569 	.word	0x080a0569
 80a378c:	080a098d 	.word	0x080a098d
 80a3790:	080a1165 	.word	0x080a1165
 80a3794:	080a1245 	.word	0x080a1245
 80a3798:	080a1539 	.word	0x080a1539
 80a379c:	080a1629 	.word	0x080a1629
 80a37a0:	080a1b45 	.word	0x080a1b45
 80a37a4:	080a1ea5 	.word	0x080a1ea5
 80a37a8:	080a2071 	.word	0x080a2071
 80a37ac:	080a20e5 	.word	0x080a20e5
 80a37b0:	080a21a9 	.word	0x080a21a9
 80a37b4:	080a222d 	.word	0x080a222d
 80a37b8:	080a22b1 	.word	0x080a22b1

080a37bc <link_constructors_end>:
 80a37bc:	00000000 	.word	0x00000000
